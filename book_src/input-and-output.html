<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!-- Mirrored from learnyouahaskell.com/input-and-output by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 19 Nov 2013 17:20:06 GMT -->
<head>
<title>Input and Output - Learn You a Haskell for Great Good!</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<base >
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="favicon.png" type="image/png">
        <link rel="prev" href="making-our-own-types-and-typeclasses.html">
        <link rel="next" href="functionally-solving-problems.html">
<link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
<link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
</head>
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                                        <a href="making-our-own-types-and-typeclasses.html" class="prevlink">Making Our Own Types and Typeclasses</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters.html">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="functionally-solving-problems.html" class="nxtlink">Functionally Solving Problems</a>
                                            </li>
                </ul>
            </div>
        <h1>Input and Output</h1>
<img src="lyah/dognap.png" alt="poor dog" class="right" width="261" height="382">
<p>We've mentioned that Haskell is a purely functional language. Whereas in imperative languages you usually get things done by giving the computer a series of steps to execute, functional programming is more of defining what stuff is. In Haskell, a function can't change some state, like changing the contents of a variable (when a function changes state, we say that the function has <i>side-effects</i>). The only thing a function can do in Haskell is give us back some result based on the parameters we gave it. If a function is called two times with the same parameters, it has to return the same result. While this may seem a bit limiting when you're coming from an imperative world, we've seen that it's actually really cool. In an imperative language, you have no guarantee that a simple function that should just crunch some numbers won't burn down your house, kidnap your dog and scratch your car with a potato while crunching those numbers. For instance, when we were making a binary search tree, we didn't insert an element into a tree by modifying some tree in place. Our function for inserting into a binary search tree actually returned a new tree, because it can't change the old one.</p>
<p>While functions being unable to change state is good because it helps us reason about our programs, there's one problem with that. If a function can't change anything in the world, how is it supposed to tell us what it calculated? In order to tell us what it calculated, it has to change the state of an output device (usually the state of the screen), which then emits photons that travel to our brain and change the state of our mind, man.</p>
<p>Do not despair, all is not lost. It turns out that Haskell actually has a really clever system for dealing with functions that have side-effects that neatly separates the part of our program that is pure and the part of our program that is impure, which does all the dirty work like talking to the keyboard and the screen. With those two parts separated, we can still reason about our pure program and take advantage of all the things that purity offers, like laziness, robustness and modularity while efficiently communicating with the outside world.</p>
<a name="hello-world"></a><h2>Hello, world!</h2>
<img src="lyah/helloworld.png" alt="HELLO!" class="left" width="223" height="179">
<p>Up until now, we've always loaded our functions into GHCI to test them out and play with them. We've also explored the standard library functions that way. But now, after eight or so chapters, we're finally going to write our first <i>real</i> Haskell program! Yay! And sure enough, we're going to do the good old <code class="fixed">"hello, world"</code> schtick.</p>
<div class="hintbox"><em>Hey!</em> For the purposes of this chapter, I'm going to assume you're using a unix-y environment for learning Haskell. If you're in Windows, I'd suggest you download <a href="http://www.cygwin.com/">Cygwin</a>, which is a Linux-like environment for Windows, A.K.A. just what you need.</div>
<p>So, for starters, punch in the following in your favorite text editor:</p>
<pre name="code" class="haskell:hs">
main = putStrLn "hello, world"
</pre>
<p>We just defined a name called <code class="fixed">main</code> and in it we call a function called <code class="fixed">putStrLn</code> with the parameter <code class="fixed">"hello, world"</code>. Looks pretty much run of the mill, but it isn't, as we'll see in just a few moments. Save that file as <code class="fixed">helloworld.hs</code>.</p>
<p>And now, we're going to do something we've never done before. We're actually going to compile our program! I'm so excited! Open up your terminal and navigate to the directory where <code class="fixed">helloworld.hs</code> is located and do the following:</p>
<pre name="code" class="plain">
$ ghc --make helloworld
[1 of 1] Compiling Main             ( helloworld.hs, helloworld.o )
Linking helloworld ...
</pre>
<p>Okay! With any luck, you got something like this and now you can run your program by doing <code class="fixed">./helloworld</code>.</p> 
<pre name="code" class="haskell:hs">
$ ./helloworld
hello, world
</pre>
<p>And there we go, our first compiled program that printed out something to the terminal. How extraordinarily boring!</p>
<p>Let's examine what we wrote. First, let's look at the type of the function <code class="fixed">putStrLn</code>.</p>
<pre name="code" class="haskell:hs">
ghci&gt; :t putStrLn
putStrLn :: String -&gt; IO ()
ghci&gt; :t putStrLn "hello, world"
putStrLn "hello, world" :: IO ()
</pre>
<p>We can read the type of <code class="fixed">putStrLn</code> like this: <code class="fixed">putStrLn</code> takes a string and returns an <em>I/O action</em> that has a result type of <code class="fixed">()</code> (i.e. the empty tuple, also know as unit). An I/O action is something that, when performed, will carry out an action with a side-effect (that's usually either reading from the input or printing stuff to the screen) and will also contain some kind of return value inside it. Printing a string to the terminal doesn't really have any kind of meaningful return value, so a dummy value of <code class="fixed">()</code> is used.</p>
<div class="hintbox">The empty tuple is a value of <code class="fixed">()</code> and it also has a type of <code class="fixed">()</code>.</div>
<p>So, when will an I/O action be performed? Well, this is where <code class="fixed">main</code> comes in. An I/O action will be performed when we give it a name of <code class="fixed">main</code> and then run our program.</p>
<p>Having your whole program be just one I/O action seems kind of limiting. That's why we can use <i>do</i> syntax to glue together several I/O actions into one. Take a look at the following example:</p>
<pre name="code" class="haskell:hs">
main = do
    putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
</pre>
<p>Ah, interesting, new syntax! And this reads pretty much like an imperative program. If you compile it and try it out, it will probably behave just like you expect it to. Notice that we said <i>do</i> and then we laid out a series of steps, like we would in an imperative program. Each of these steps is an I/O action. By putting them together with <i>do</i> syntax, we glued them into one I/O action. The action that we got has a type of <code class="fixed">IO ()</code>, because that's the type of the last I/O action inside.</p>
<p>Because of that, <code class="fixed">main</code> always has a type signature of <code class="fixed">main :: IO <i>something</i></code>, where <code class="fixed"><i>something</i></code> is some concrete type. By convention, we don't usually specify a type declaration for <code class="fixed">main</code>.</p>
<p>An interesting thing that we haven't met before is the third line, which states <code class="fixed">name &lt;- getLine</code>. It looks like it reads a line from the input and stores it into a variable called <code class="fixed">name</code>. Does it really? Well, let's examine the type of <code class="fixed">getLine</code>.</p>
<pre name="code" class="haskell:hs">
ghci&gt; :t getLine
getLine :: IO String
</pre>
<img src="lyah/luggage.png" alt="luggage" class="left" width="204" height="200">
<p>Aha, o-kay. <code class="fixed">getLine</code> is an I/O action that contains a result type of <code class="fixed">String</code>. That makes sense, because it will wait for the user to input something at the terminal and then that something will be represented as a string. So what's up with <code class="fixed">name &lt;- getLine</code> then? You can read that piece of code like this: <em>perform the I/O action <code class="fixed">getLine</code> and then bind its result value to <code class="fixed">name</code></em>. <code class="fixed">getLine</code> has a type of <code class="fixed">IO String</code>, so <code class="fixed">name</code> will have a type of <code class="fixed">String</code>. You can think of an I/O action as a box with little feet that will go out into the real world and do something there (like write some graffiti on a wall) and maybe bring back some data. Once it's fetched that data for you, the only way to open the box and get the data inside it is to use the <code class="fixed">&lt;-</code> construct. And if we're taking data out of an I/O action, we can only take it out when we're inside another I/O action. This is how Haskell manages to neatly separate the pure and impure parts of our code. <code class="fixed">getLine</code> is in a sense impure because its result value is not guaranteed to be the same when performed twice. That's why it's sort of <i>tainted</i> with the <code class="fixed">IO</code> type constructor and we can only get that data out in I/O code. And because I/O code is tainted too, any computation that depends on tainted I/O data will have a tainted result.</p>
<p>When I say <i>tainted</i>, I don't mean tainted in such a way that we can never use the result contained in an I/O action ever again in pure code. No, we temporarily <i>un-taint</i> the data inside an I/O action when we bind it to a name. When we do <code class="fixed">name &lt;- getLine</code>, <code class="fixed">name</code> is just a normal string, because it represents what's inside the box. We can have a really complicated function that, say, takes your name (a normal string) as a parameter and tells you your fortune and your whole life's future based on your name. We can do this:</p>
<pre name="code" class="haskell:hs">
main = do
    putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn $ "Read this carefully, because this is your future: " ++ tellFortune name
</pre>
<p>and <code class="fixed">tellFortune</code> (or any of the functions it passes <code class="fixed">name</code> to) doesn't have to know anything about I/O, it's just a normal <code class="fixed">String -&gt; String</code> function!</p>
<p>Take a look at this piece of code. Is it valid?</p>
<pre name="code" class="haskell:hs">
nameTag = "Hello, my name is " ++ getLine
</pre>
<p>If you said no, go eat a cookie. If you said yes, drink a bowl of molten lava. Just kidding, don't! The reason that this doesn't work is that <code class="fixed">++</code> requires both its parameters to be lists over the same type. The left parameter has a type of <code class="fixed">String</code> (or <code class="fixed">[Char]</code> if you will), whilst <code class="fixed">getLine</code> has a type of <code class="fixed">IO String</code>. You can't concatenate a string and an I/O action. We first have to get the result out of the I/O action to get a value of type <code class="fixed">String</code> and the only way to do that is to say something like <code class="fixed">name &lt;- getLine</code> inside some other I/O action. If we want to deal with impure data, we have to do it in an impure environment. So the taint of impurity spreads around much like the undead scourge and it's in our best interest to keep the I/O parts of our code as small as possible.</p>
<p>Every I/O action that gets performed has a result encapsulated within it. That's why our previous example program could also have been written like this:</p>
<pre name="code" class="haskell:hs">
main = do
    foo &lt;- putStrLn "Hello, what's your name?"
    name &lt;- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
</pre>
<p>However, <code class="fixed">foo</code> would just have a value of <code class="fixed">()</code>, so doing that would be kind of moot. Notice that we didn't bind the last <code class="fixed">putStrLn</code> to anything. That's because in a <i>do</i> block, <em>the last action cannot be bound to a name</em> like the first two were. We'll see exactly why that is so a bit later when we venture off into the world of monads. For now, you can think of it in the way that the <i>do</i> block automatically extracts the value from the last action and binds it to its own result.</p>
<p>Except for the last line, every line in a <i>do</i> block that doesn't bind can also be written with a bind. So <code class="fixed">putStrLn "BLAH"</code> can be written as <code class="fixed">_ &lt;- putStrLn "BLAH"</code>. But that's useless, so we leave out the <code class="fixed">&lt;-</code> for I/O actions that don't contain an important result, like <code class="fixed">putStrLn <i>something</i></code>.</p>
<p>Beginners sometimes think that doing</p>
<pre name="code" class="haskell:hs">
name = getLine
</pre>
<p>will read from the input and then bind the value of that to <code class="fixed">name</code>. Well, it won't, all this does is give the <code class="fixed">getLine</code> I/O action a different name called, well, <code class="fixed">name</code>. Remember, to get the value out of an I/O action, you have to perform it inside another I/O action by binding it to a name with <code class="fixed">&lt;-</code>.</p>
<p>I/O actions will only be performed when they are given a name of <code class="fixed">main</code> or when they're inside a bigger I/O action that we composed with a <i>do</i> block. We can also use a <i>do</i> block to glue together a few I/O actions and then we can use that I/O action in another <i>do</i> block and so on. Either way, they'll be performed only if they eventually fall into <code class="fixed">main</code>.</p>
<p>Oh, right, there's also one more case when I/O actions will be performed. When we type out an I/O action in GHCI and press return, it will be performed.</p>
<pre name="code" class="haskell:hs">
ghci&gt; putStrLn "HEEY"
HEEY
</pre>
<p>Even when we just punch out a number or call a function in GHCI and press return, it will evaluate it (as much as it needs) and then call <code class="fixed">show</code> on it and then it will print that string to the terminal using <code class="fixed">putStrLn</code> implicitly.</p>
<p>Remember <i>let</i> bindings? If you don't, refresh your memory on them by reading <a href="syntax-in-functions.html#let-it-be">this section</a>. They have to be in the form of <code class="fixed">let <i>bindings</i> in <i>expression</i></code>, where <code class="fixed"><i>bindings</i></code> are names to be given to expressions and <code class="fixed"><i>expression</i></code> is the expression that is to be evaluated that sees them. We also said that in list comprehensions, the <i>in</i> part isn't needed. Well, you can use them in <i>do</i> blocks pretty much like you use them in list comprehensions. Check this out:</p>
<pre name="code" class="haskell:hs">
import Data.Char

main = do
    putStrLn "What's your first name?"
    firstName &lt;- getLine
    putStrLn "What's your last name?"
    lastName &lt;- getLine
    let bigFirstName = map toUpper firstName
        bigLastName = map toUpper lastName
    putStrLn $ "hey " ++ bigFirstName ++ " " ++ bigLastName ++ ", how are you?"
</pre>
<p>See how the I/O actions in the <i>do</i> block are lined up? Also notice how the <i>let</i> is lined up with the I/O actions and the names of the <i>let</i> are lined up with each other? That's good practice, because indentation is important in Haskell. Now, we did <code class="fixed">map toUpper firstName</code>, which turns something like <code class="fixed">"John"</code> into a much cooler string like <code class="fixed">"JOHN"</code>. We bound that uppercased string to a name and then used it in a string later on that we printed to the terminal.</p>
<p>You may be wondering when to use <code class="fixed">&lt;-</code> and when to use <i>let</i> bindings? Well, remember, <code class="fixed">&lt;-</code> is (for now) for performing I/O actions and binding their results to names. <code class="fixed">map toUpper firstName</code>, however, isn't an I/O action. It's a pure expression in Haskell. So use <code class="fixed">&lt;-</code> when you want to bind results of I/O actions to names and you can use <i>let</i> bindings to bind pure expressions to names. Had we done something like <code class="fixed">let firstName = getLine</code>, we would have just called the <code class="fixed">getLine</code> I/O action a different name and we'd still have to run it through a <code class="fixed">&lt;-</code> to perform it.</p>
<p>Now we're going to make a program that continuously reads a line and prints out the same line with the words reversed. The program's execution will stop when we input a blank line. This is the program:</p>
<pre name="code" class="haskell:hs">
main = do 
    line &lt;- getLine
    if null line
        then return ()
        else do
            putStrLn $ reverseWords line
            main

reverseWords :: String -&gt; String
reverseWords = unwords . map reverse . words
</pre>
<p>To get a feel of what it does, you can run it before we go over the code.</p>
<div class="hintbox"><em>Protip</em>: To run a program you can either compile it and then run the produced executable file by doing <code class="fixed">ghc --make helloworld</code> and then <code class="fixed">./helloworld</code> or you can use the <code class="fixed">runhaskell</code> command like so: <code class="fixed">runhaskell helloworld.hs</code> and your program will be executed on the fly.</div>
<p>First, let's take a look at the <code class="fixed">reverseWords</code> function. It's just a normal function that takes a string like <code class="fixed">"hey there man"</code> and then calls <code class="fixed">words</code> with it to produce a list of words like <code class="fixed">["hey","there","man"]</code>. Then we map <code class="fixed">reverse</code> on the list, getting <code class="fixed">["yeh","ereht","nam"]</code> and then we put that back into one string by using <code class="fixed">unwords</code> and the final result is <code class="fixed">"yeh ereht nam"</code>. See how we used function composition here. Without function composition, we'd have to write something like <code class="fixed">reverseWords st = unwords (map reverse (words st))</code>.</p>
<p>What about <code class="fixed">main</code>? First, we get a line from the terminal by performing <code class="fixed">getLine</code> call that line <code class="fixed">line</code>. And now, we have a conditional expression. Remember that in Haskell, every <i>if</i> must have a corresponding <i>else</i> because every expression has to have some sort of value. We make the <i>if</i> so that when a condition is true (in our case, the line that we entered is blank), we perform one I/O action and when it isn't, the I/O action under the <i>else</i> is performed. That's why in an I/O <i>do</i> block, <i>if</i>s have to have a form of <code class="fixed">if <i>condition</i> then <i>I/O action</i> else <i>I/O action</i>.</code>
<p>Let's first take a look at what happens under the <i>else</i> clause. Because, we have to have exactly one I/O action after the <i>else</i>, we use a <i>do</i> block to glue together two I/O actions into one. You could also write that part out as:</p>
<pre name="code" class="haskell:hs">
        else (do
            putStrLn $ reverseWords line
            main)
</pre>
<p>This makes it more explicit that the <i>do</i> block can be viewed as one I/O action, but it's uglier. Anyway, inside the <i>do</i> block, we call <code class="fixed">reverseWords</code> on the line that we got from <code class="fixed">getLine</code> and then print that out to the terminal. After that, we just perform <code class="fixed">main</code>. It's called recursively and that's okay, because <code class="fixed">main</code> is itself an I/O action. So in a sense, we go back to the start of the program.</p>
<p>Now what happens when <code class="fixed">null line</code> holds true? What's after the <i>then</i> is performed in that case. If we look up, we'll see that it says <code class="fixed">then return ()</code>. If you've done imperative languages like C, Java or Python, you're probably thinking that you know what this <code class="fixed">return</code> does and chances are you've already skipped this really long paragraph. Well, here's the thing: <em>the <code class="fixed">return</code> in Haskell is really nothing like the <code class="fixed">return</code> in most other languages!</em> It has the same name, which confuses a lot of people, but in reality it's quite different. In imperative languages, <code class="fixed">return</code> usually ends the execution of a method or subroutine and makes it report some sort of value to whoever called it. In Haskell (in I/O actions specifically), it makes an I/O action out of a pure value. If you think about the box analogy from before, it takes a value and wraps it up in a box. The resulting I/O action doesn't actually do anything, it just has that value encapsulated as its result. So in an I/O context, <code class="fixed">return "haha"</code> will have a type of <code class="fixed">IO String</code>. What's the point of just transforming a pure value into an I/O action that doesn't do anything? Why taint our program with <code class="fixed">IO</code> more than it has to be? Well, we needed some I/O action to carry out in the case of an empty input line. That's why we just made a bogus I/O action that doesn't do anything by writing <code class="fixed">return ()</code>. </p>
<p>Using <code class="fixed">return</code> doesn't cause the I/O <i>do</i> block to end in execution or anything like that. For instance, this program will quite happily carry out all the way to the last line:</p>
<pre name="code" class="haskell:hs">
main = do
    return ()
    return "HAHAHA"
    line &lt;- getLine
    return "BLAH BLAH BLAH"
    return 4
    putStrLn line
</pre>
<p>All these <code class="fixed">return</code>s do is that they make I/O actions that don't really do anything except have an encapsulated result and that result is thrown away because it isn't bound to a name. We can use <code class="fixed">return</code> in combination with <code class="fixed">&lt;-</code> to bind stuff to names.</p>
<pre name="code" class="haskell:hs">
main = do
    a &lt;- return "hell"
    b &lt;- return "yeah!"
    putStrLn $ a ++ " " ++ b
</pre>
<p>So you see, <code class="fixed">return</code> is sort of the opposite to <code class="fixed">&lt;-</code>. While <code class="fixed">return</code> takes a value and wraps it up in a box, <code class="fixed">&lt;-</code> takes a box (and performs it) and takes the value out of it, binding it to a name. But doing this is kind of redundant, especially since you can use <i>let</i> bindings in <i>do</i> blocks to bind to names, like so: </p>
<pre name="code" class="haskell:hs">
main = do
    let a = "hell"
        b = "yeah"
    putStrLn $ a ++ " " ++ b
</pre>
<p>When dealing with I/O <i>do</i> blocks, we mostly use <code class="fixed">return</code> either because we need to create an I/O action that doesn't do anything or because we don't want the I/O action that's made up from a <i>do</i> block to have the result value of its last action, but we want it to have a different result value, so we use <code class="fixed">return</code> to make an I/O action that always has our desired result contained and we put it at the end.</p>
<div class="hintbox">A <i>do</i> block can also have just one I/O action. In that case, it's the same as just writing the I/O action. Some people would prefer writing <code class="fixed">then do return ()</code> in this case because the <i>else</i> also has a <i>do</i>.</div>
<p>Before we move on to files, let's take a look at some functions that are useful when dealing with I/O.</p>
<p><code class="label function">putStr</code> is much like <code class="fixed">putStrLn</code> in that it takes a string as a parameter and returns an I/O action that will print that string to the terminal, only <code class="fixed">putStr</code> doesn't jump into a new line after printing out the string while <code class="fixed">putStrLn</code> does.</p>
<pre name="code" class="haskell:hs">
main = do   putStr "Hey, "
            putStr "I'm "
            putStrLn "Andy!" 
</pre>
<pre name="code" class="plain">
$ runhaskell putstr_test.hs
Hey, I'm Andy!
</pre>
<p>Its type signature is <code class="fixed">putStr :: String -&gt; IO ()</code>, so the result encapsulated within the resulting I/O action is the unit. A dud value, so it doesn't make sense to bind it.</p>
<p><code class="label function">putChar</code> takes a character and returns an I/O action that will print it out to the terminal.</p>
<pre name="code" class="haskell:hs">
main = do   putChar 't'
            putChar 'e'
            putChar 'h'
</pre>
<pre name="code" class="plain">
$ runhaskell putchar_test.hs
teh
</pre>
<p><code class="fixed">putStr</code> is actually defined recursively with the help of <code class="fixed">putChar</code>. The edge condition of <code class="fixed">putStr</code> is the empty string, so if we're printing an empty string, just return an I/O action that does nothing by using <code class="fixed">return ()</code>. If it's not empty, then print the first character of the string by doing <code class="fixed">putChar</code> and then print of them using <code class="fixed">putStr</code>.</p>
<pre name="code" class="haskell:hs">
putStr :: String -&gt; IO ()
putStr [] = return ()
putStr (x:xs) = do
    putChar x
    putStr xs
</pre>
<p>See how we can use recursion in I/O, just like we can use it in pure code. Just like in pure code, we define the edge case and then think what the result actually is. It's an action that first outputs the first character and then outputs the rest of the string.</p>
<p><code class="label function">print</code> takes a value of any type that's an instance of <code class="fixed">Show</code> (meaning that we know how to represent it as a string), calls <code class="fixed">show</code> with that value to stringify it and then outputs that string to the terminal. Basically, it's just <code class="fixed">putStrLn . show</code>. It first runs <code class="fixed">show</code> on a value and then feeds that to <code class="fixed">putStrLn</code>, which returns an I/O action that will print out our value.</p>
<pre name="code" class="haskell:hs">
main = do   print True
            print 2
            print "haha"
            print 3.2
            print [3,4,3]
</pre>
<pre name="code" class="haskell:hs">
$ runhaskell print_test.hs
True
2
"haha"
3.2
[3,4,3]
</pre>
<p>As you can see, it's a very handy function. Remember how we talked about how I/O actions are performed only when they fall into <code class="fixed">main</code> or when we try to evaluate them in the GHCI prompt? When we type out a value (like <code class="fixed">3</code> or <code class="fixed">[1,2,3]</code>) and press the return key, GHCI actually uses <code class="fixed">print</code> on that value to display it on our terminal! </p>
<pre name="code" class="haskell:hs">
ghci&gt; 3
3
ghci&gt; print 3
3
ghci&gt; map (++"!") ["hey","ho","woo"]
["hey!","ho!","woo!"]
ghci&gt; print (map (++"!") ["hey","ho","woo"])
["hey!","ho!","woo!"]
</pre>
<p>When we want to print out strings, we usually use <code class="fixed">putStrLn</code> because we don't want the quotes around them, but for printing out values of other types to the terminal, <code class="fixed">print</code> is used the most.</p>
<p><span class="function label">getChar</span> is an I/O action that reads a character from the input. Thus, its type signature is <code class="fixed">getChar :: IO Char</code>, because the result contained within the I/O action is a <code class="fixed">Char</code>. Note that due to buffering, reading of the characters won't actually happen until the user mashes the return key.</p>
<pre name="code" class="haskell:hs">
main = do   
    c &lt;- getChar
    if c /= ' '
        then do
            putChar c
            main
        else return ()
</pre>
<p>This program looks like it should read a character and then check if it's a space. If it is, halt execution and if it isn't, print it to the terminal and then do the same thing all over again. Well, it kind of does, only not in the way you might expect. Check this out:</p>
<pre name="code" class="plain">
$ runhaskell getchar_test.hs
hello sir
hello
</pre>
<p>The second line is the input. We input <code class="fixed">hello sir</code> and then press return. Due to buffering, the execution of the program will begin only when after we've hit return and not after every inputted character. But once we press return, it acts on what we've been putting in so far. Try playing with this program to get a feel for it!</p>
<p>The <code class="label function">when</code> function is found in <code class="fixed">Control.Monad</code> (to get access to it, do <code class="fixed">import Control.Monad</code>). It's interesting because in a <i>do</i> block it looks like a control flow statement, but it's actually a normal function. It takes a boolean value and an I/O action if that boolean value is <code class="fixed">True</code>, it returns the same I/O action that we supplied to it. However, if it's <code class="fixed">False</code>, it returns the <code class="fixed">return ()</code>, action, so an I/O action that doesn't do anything. Here's how we could rewrite the previous piece of code with which we demonstrated <code class="fixed">getChar</code> by using <code class="fixed">when</code>:</p>
<pre name="code" class="haskell:hs">
import Control.Monad 

main = do
    c &lt;- getChar
    when (c /= ' ') $ do
        putChar c
        main
</pre>
<p>So as you can see, it's useful for encapsulating the <code class="fixed">if <i>something</i> then do <i>some I/O action</i> else return ()</code> pattern.</p>
<p><code class="label function">sequence</code> takes a list of I/O actions and returns an I/O actions that will perform those actions one after the other. The result contained in that I/O action will be a list of the results of all the I/O actions that were performed. Its type signature is <code class="fixed">sequence :: [IO a] -&gt; IO [a]</code>. Doing this:</p>
<pre name="code" class="haskell:hs">
main = do
    a &lt;- getLine
    b &lt;- getLine
    c &lt;- getLine
    print [a,b,c]
</pre>
<p>Is exactly the same as doing this:.</p>
<pre name="code" class="haskell:hs">
main = do
    rs &lt;- sequence [getLine, getLine, getLine]
    print rs
</pre>
<p>So <code class="fixed">sequence [getLine, getLine, getLine]</code> makes an I/O action that will perform <code class="fixed">getLine</code> three times. If we bind that action to a name, the result is a list of all the results, so in our case, a list of three things that the user entered at the prompt.</p>
<p>A common pattern with <code class="fixed">sequence</code> is when we map functions like <code class="fixed">print</code> or <code class="fixed">putStrLn</code> over lists. Doing <code class="fixed">map print [1,2,3,4]</code> won't create an I/O action. It will create a list of I/O actions, because that's like writing <code class="fixed">[print 1, print 2, print 3, print 4]</code>. If we want to transform that list of I/O actions into an I/O action, we have to sequence it.</p>
<pre name="code" class="haskell:hs">
ghci&gt; sequence (map print [1,2,3,4,5])
1
2
3
4
5
[(),(),(),(),()]
</pre>
<p>What's with the <code class="fixed">[(),(),(),(),()]</code> at the end? Well, when we evaluate an I/O action in GHCI, it's performed and then its result is printed out, unless that result is <code class="fixed">()</code>, in which case it's not printed out. That's why evaluating <code class="fixed">putStrLn "hehe"</code> in GHCI just prints out <code class="fixed">hehe</code> (because the contained result in <code class="fixed">putStrLn "hehe"</code> is <code class="fixed">()</code>). But when we do <code class="fixed">getLine</code> in GHCI, the result of that I/O action is printed out, because <code class="fixed">getLine</code> has a type of <code class="fixed">IO String</code>.</p>
<p>Because mapping a function that returns an I/O action over a list and then sequencing it is so common, the utility functions <code class="label function">mapM</code> and <code class="label function">mapM_</code> were introduced. <code class="fixed">mapM</code> takes a function and a list, maps the function over the list and then sequences it. <code class="fixed">mapM_</code> does the same, only it throws away the result later. We usually use <code class="fixed">mapM_</code> when we don't care what result our sequenced I/O actions have.</p>
<pre name="code" class="haskell:hs">
ghci&gt; mapM print [1,2,3]
1
2
3
[(),(),()]
ghci&gt; mapM_ print [1,2,3]
1
2
3
</pre>
<p><code class="label function">forever</code> takes an I/O action and returns an I/O action that just repeats the I/O action it got forever. It's located in <code class="fixed">Control.Monad</code>. This little program will indefinitely ask the user for some input and spit it back to him, CAPSLOCKED:</p>
<pre name="code" class="haskell:hs">
import Control.Monad
import Data.Char

main = forever $ do
    putStr "Give me some input: "
    l &lt;- getLine
    putStrLn $ map toUpper l
</pre>
<p><code class="label function">forM</code> (located in <code class="fixed">Control.Monad</code>) is like <code class="fixed">mapM</code>, only that it has its parameters switched around. The first parameter is the list and the second one is the function to map over that list, which is then sequenced. Why is that useful? Well, with some creative use of lambdas and <i>do</i> notation, we can do stuff like this:</p>
<pre name="code" class="haskell:hs">
import Control.Monad

main = do 
    colors &lt;- forM [1,2,3,4] (\a -&gt; do
        putStrLn $ "Which color do you associate with the number " ++ show a ++ "?"
        color &lt;- getLine
        return color)
    putStrLn "The colors that you associate with 1, 2, 3 and 4 are: "
    mapM putStrLn colors
</pre>
<p>The <code class="fixed">(\a -&gt; do ... )</code> is a function that takes a number and returns an I/O action. We have to surround it with parentheses, otherwise the lambda thinks the last two I/O actions belong to it. Notice that we do <code class="fixed">return color</code> in the inside <i>do</i> block. We do that so that the I/O action which the <i>do</i> block defines has the result of our color contained within it. We actually didn't have to do that, because <code class="fixed">getLine</code> already has that contained within it. Doing <code class="fixed">color &lt;- getLine</code> and then <code class="fixed">return color</code> is just unpacking the result from <code class="fixed">getLine</code> and then repackaging it again, so it's the same as just doing <code class="fixed">getLine</code>. The <code class="fixed">forM</code> (called with its two parameters) produces an I/O action, whose result we bind to <code class="fixed">colors</code>. <code class="fixed">colors</code> is just a normal list that holds strings. At the end, we print out all those colors by doing <code class="fixed">mapM putStrLn colors</code>.</p>
<p>You can think of <code class="fixed">forM</code> as meaning: make an I/O action for every element in this list. What each I/O action will do can depend on the element that was used to make the action. Finally, perform those actions and bind their results to something. We don't have to bind it, we can also just throw it away.</p>
<pre name="code" class="plain">
$ runhaskell form_test.hs
Which color do you associate with the number 1?
white
Which color do you associate with the number 2?
blue
Which color do you associate with the number 3?
red
Which color do you associate with the number 4?
orange
The colors that you associate with 1, 2, 3 and 4 are:
white
blue
red
orange
</pre>
<p>We could have actually done that without <code class="fixed">forM</code>, only with <code class="fixed">forM</code> it's more readable. Normally we write <code class="fixed">forM</code> when we want to map and sequence some actions that we define there on the spot using <i>do</i> notation. In the same vein, we could have replaced the last line with <code class="fixed">forM colors putStrLn</code>.</p>
<p>In this section, we learned the basics of input and output. We also found out what I/O actions are, how they enable us to do input and output and when they are actually performed. To reiterate, I/O actions are values much like any other value in Haskell. We can pass them as parameters to functions and functions can return I/O actions as results. What's special about them is that if they fall into the <code class="fixed">main</code> function (or are the result in a GHCI line), they are performed. And that's when they get to write stuff on your screen or play Yakety Sax through your speakers. Each I/O action can also encapsulate a result with which it tells you what it got from the real world.</p>
<p>Don't think of a function like <code class="fixed">putStrLn</code> as a function that takes a string and prints it to the screen. Think of it as a function that takes a string and returns an I/O action. That I/O action will, when performed, print beautiful poetry to your terminal.</p>
<a name="files-and-streams"></a><h2>Files and streams</h2>
<img src="lyah/streams.png" alt="streams" class="right" width="464" height="322">
<p><code class="fixed">getChar</code> is an I/O action that reads a single character from the terminal. <code class="fixed">getLine</code> is an I/O action that reads a line from the terminal. These two are pretty straightforward and most programming languages have some functions or statements that are parallel to them. But now, let's meet <code class="label function">getContents</code>. <code class="fixed">getContents</code> is an I/O action that reads everything from the standard input until it encounters an end-of-file character. Its type is <code class="fixed">getContents :: IO String</code>. What's cool about <code class="fixed">getContents</code> is that it does lazy I/O. When we do <code class="fixed">foo &lt;- getContents</code>, it doesn't read all of the input at once, store it in memory and then bind it to <code class="fixed">foo</code>. No, it's lazy! It'll say: <i>"Yeah yeah, I'll read the input from the terminal later as we go along, when you really need it!"</i>. </p>
<p><code class="fixed">getContents</code> is really useful when we're piping the output from one program into the input of our program. In case you don't know how piping works in unix-y systems, here's a quick primer. Let's make a text file that contains the following little haiku:</p>
<pre name="code" class="plain">
I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless 
</pre>
<p>Yeah, the haiku sucks, what of it? If anyone knows of any good haiku tutorials, let me know.</p>
<p>Now, recall the little program we wrote when we were introducing the <code class="fixed">forever</code> function. It prompted the user for a line, returned it to him in CAPSLOCK and then did that all over again, indefinitely. Just so you don't have to scroll all the way back, here it is again:</p>
<pre name="code" class="haskell:hs">
import Control.Monad
import Data.Char

main = forever $ do
    putStr "Give me some input: "
    l &lt;- getLine
    putStrLn $ map toUpper l
</pre>
<p>We'll save that program as <code class="fixed">capslocker.hs</code> or something and compile it. And then, we're going to use a unix pipe to feed our text file directly to our little program. We're going to use the help of the GNU <i>cat</i> program, which prints out a file that's given to it as an argument. Check it out, booyaka!</p>
<pre name="code" class="plain">
$ ghc --make capslocker 
[1 of 1] Compiling Main             ( capslocker.hs, capslocker.o )
Linking capslocker ...
$ cat haiku.txt
I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless
$ cat haiku.txt | ./capslocker
I'M A LIL' TEAPOT
WHAT'S WITH THAT AIRPLANE FOOD, HUH?
IT'S SO SMALL, TASTELESS
capslocker &lt;stdin&gt;: hGetLine: end of file
</pre>
<p>As you can see, piping the output of one program (in our case that was <i>cat</i>) to the input of another (<i>capslocker</i>) is done with the <code class="fixed">|</code> character. What we've done is pretty much equivalent to just running <i>capslocker</i>, typing our haiku at the terminal and then issuing an end-of-file character (that's usually done by pressing Ctrl-D). It's like running <i>cat haiku.txt</i> and saying: &ldquo;Wait, don't print this out to the terminal, tell it to <i>capslocker</i> instead!&rdquo;.</p>
<p>So what we're essentially doing with that use of <code class="fixed">forever</code> is taking the input and transforming it into some output. That's why we can use <code class="fixed">getContents</code> to make our program even shorter and better:</p>
<pre name="code" class="haskell:hs">
import Data.Char

main = do
    contents &lt;- getContents
    putStr (map toUpper contents)
</pre>
<p>We run the <code class="fixed">getContents</code> I/O action and name the string it produces <code class="fixed">contents</code>. Then, we map <code class="fixed">toUpper</code> over that string and print that to the terminal. Keep in mind that because strings are basically lists, which are lazy, and <code class="fixed">getContents</code> is I/O lazy, it won't try to read the whole content at once and store it into memory before printing out the capslocked version. Rather, it will print out the capslocked version as it reads it, because it will only read a line from the input when it really needs to.</p>
<pre name="code" class="plain">
$ cat haiku.txt | ./capslocker
I'M A LIL' TEAPOT
WHAT'S WITH THAT AIRPLANE FOOD, HUH?
IT'S SO SMALL, TASTELESS
</pre>
<p>Cool, it works. What if we just run <i>capslocker</i> and try to type in the lines ourselves?</p>
<pre name="code" class="plain">
$ ./capslocker
hey ho
HEY HO
lets go
LETS GO
</pre>
<p>We got out of that by pressing Ctrl-D. Pretty nice! As you can see, it prints out our capslocked input back to us line by line. When the result of <code class="fixed">getContents</code> is bound to <code class="fixed">contents</code>, it's not represented in memory as a real string, but more like a promise that it will produce the string eventually. When we map <code class="fixed">toUpper</code> over <code class="fixed">contents</code>, that's also a promise to map that function over the eventual contents. And finally when <code class="fixed">putStr</code> happens, it says to the previous promise: <i>"Hey, I need a capslocked line!"</i>. It doesn't have any lines yet, so it says to <code class="fixed">contents</code>: <i>"Hey, how about actually getting a line from the terminal?"</i>. So that's when <code class="fixed">getContents</code> actually reads from the terminal and gives a line to the code that asked it to produce something tangible. That code then maps <code class="fixed">toUpper</code> over that line and gives it to <code class="fixed">putStr</code>, which prints it. And then, <code class="fixed">putStr</code> says: <i>"Hey, I need the next line, come on!"</i> and this repeats until there's no more input, which is signified by an end-of-file character.</p>
<p>Let's make program that takes some input and prints out only those lines that are shorter than 10 characters. Observe:</p>
<pre name="code" class="haskell:hs">
main = do
    contents &lt;- getContents
    putStr (shortLinesOnly contents)

shortLinesOnly :: String -&gt; String
shortLinesOnly input = 
    let allLines = lines input
        shortLines = filter (\line -&gt; length line &lt; 10) allLines
        result = unlines shortLines
    in  result
</pre>
<p>We've made our I/O part of the program as short as possible. Because our program is supposed to take some input and print out some output based on the input, we can implement it by reading the input contents, running a function on them and then printing out what the function gave back.</p>
<p>The <code class="fixed">shortLinesOnly</code> function works like this: it takes a string, like <code class="fixed">"short\nlooooooooooooooong\nshort again"</code>. That string has three lines, two of them are short and the middle one is long. It runs the <code class="fixed">lines</code> function on that string, which converts it to <code class="fixed">["short", "looooooooooooooong", "short again"]</code>, which we then bind to the name <code class="fixed">allLines</code>. That list of string is then filtered so that only those lines that are shorter than 10 characters remain in the list, producing <code class="fixed">["short", "short again"]</code>. And finally, <code class="fixed">unlines</code> joins that list into a single newline delimited string, giving <code class="fixed">"short\nshort again"</code>. Let's give it a go.</p>
<pre name="code" class="plain:hs">
i'm short
so am i
i am a loooooooooong line!!!
yeah i'm long so what hahahaha!!!!!!
short line
loooooooooooooooooooooooooooong
short
</pre>
<pre name="code" class="plain:hs">
$ ghc --make shortlinesonly
[1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )
Linking shortlinesonly ...
$ cat shortlines.txt | ./shortlinesonly
i'm short
so am i
short
</pre>
<p>We pipe the contents of <i>shortlines.txt</i> into the output of <i>shortlinesonly</i> and as the output, we only get the short lines.</p>
<p>This pattern of getting some string from the input, transforming it with a function and then outputting that is so common that there exists a function which makes that even easier, called <code class="label function">interact</code>. <code class="fixed">interact</code> takes a function of type <code class="fixed">String -&gt; String</code> as a parameter and returns an I/O action that will take some input, run that function on it and then print out the function's result. Let's modify our program to use that.</p>
<pre name="code" class="haskell:hs">
main = interact shortLinesOnly

shortLinesOnly :: String -&gt; String
shortLinesOnly input = 
    let allLines = lines input
        shortLines = filter (\line -&gt; length line &lt; 10) allLines
        result = unlines shortLines
    in  result
</pre>
<p>Just to show that this can be achieved in much less code (even though it will be less readable) and to demonstrate our function composition skill, we're going to rework that a bit further.</p>
<pre name="code" class="haskell:hs">
main = interact $ unlines . filter ((&lt;10) . length) . lines
</pre>
<p>Wow, we actually reduced that to just one line, which is pretty cool!</p>
<p><code class="fixed">interact</code> can be used to make programs that are piped some contents into them and then dump some result out or it can be used to make programs that appear to take a line of input from the user, give back some result based on that line and then take another line and so on. There isn't actually a real distinction between the two, it just depends on how the user is supposed to use them.</p>
<p>Let's make a program that continuously reads a line and then tells us if the line is a palindrome or not. We could just use <code class="fixed">getLine</code> to read a line, tell the user if it's a palindrome and then run <code class="fixed">main</code> all over again. But it's simpler if we use <code class="fixed">interact</code>. When using <code class="fixed">interact</code>, think about what you need to do to transform some input into the desired output. In our case, we have to replace each line of the input with either <code class="fixed">"palindrome"</code> or <code class="fixed">"not a palindrome"</code>. So we have to write a function that transforms something like <code class="fixed">"elephant\nABCBA\nwhatever"</code> into <code class="fixed">"not a palindrome\npalindrome\nnot a palindrome"</code>. Let's do this!</p>
<pre name="code" class="haskell:hs">
respondPalindromes contents = unlines (map (\xs -&gt; if isPalindrome xs then "palindrome" else "not a palindrome") (lines contents))
    where   isPalindrome xs = xs == reverse xs
</pre>
<p>Let's write this in point-free.</p>
<pre name="code" class="haskell:hs">
respondPalindromes = unlines . map (\xs -&gt; if isPalindrome xs then "palindrome" else "not a palindrome") . lines
    where   isPalindrome xs = xs == reverse xs
</pre>
<p>Pretty straightforward. First it turns something like <code class="fixed">"elephant\nABCBA\nwhatever"</code> into <code class="fixed">["elephant", "ABCBA", "whatever"]</code> and then it maps that lambda over it, giving <code class="fixed">["not a palindrome", "palindrome", "not a palindrome"]</code> and then <code class="fixed">unlines</code> joins that list into a single, newline delimited string. Now we can do</p>
<pre name="code" class="haskell:hs">
main = interact respondPalindromes
</pre>
<p>Let's test this out:</p>
<pre name="code" class="plain">
$ runhaskell palindromes.hs
hehe
not a palindrome
ABCBA
palindrome
cookie
not a palindrome

</pre>
<p>Even though we made a program that transforms one big string of input into another, it acts like we made a program that does it line by line. That's because Haskell is lazy and it wants to print the first line of the result string, but it can't because it doesn't have the first line of the input yet. So as soon as we give it the first line of input, it prints the first line of the output. We get out of the program by issuing an end-of-line character.</p>
<p>We can also use this program by just piping a file into it. Let's say we have this file:</p>
<pre name="code" class="plain">
dogaroo
radar
rotor
madam
</pre>
<p>and we save it as <code class="fixed">words.txt</code>. This is what we get by piping it into our program:</p>
<pre name="code" class="plain">
$ cat words.txt | runhaskell palindromes.hs
not a palindrome
palindrome
palindrome
palindrome
</pre>
<p>Again, we get the same output as if we had run our program and put in the words ourselves at the standard input. We just don't see the input that <code class="fixed">palindromes.hs</code> because the input came from the file and not from us typing the words in.</p>
<p>So now you probably see how lazy I/O works and how we can use it to our advantage. You can just think in terms of what the output is supposed to be for some given input and write a function to do that transformation. In lazy I/O, nothing is eaten from the input until it absolutely has to be because what we want to print right now depends on that input.</p>
<p>So far, we've worked with I/O by printing out stuff to the terminal and reading from it. But what about reading and writing files? Well, in a way, we've already been doing that. One way to think about reading from the terminal is to imagine that it's like reading from a (somewhat special) file. Same goes for writing to the terminal, it's kind of like writing to a file. We can call these two files <code class="fixed">stdout</code> and <code class="fixed">stdin</code>, meaning <i>standard output</i> and <i>standard input</i>, respectively. Keeping that in mind, we'll see that writing to and reading from files is very much like writing to the standard output and reading from the standard input.</p>
<p>We'll start off with a really simple program that opens a file called <i>girlfriend.txt</i>, which contains a verse from Avril Lavigne's #1&nbsp;hit <i>Girlfriend</i>, and just prints out out to the terminal. Here's <i>girlfriend.txt</i>:</p>
<pre name="code" class="plain">
Hey! Hey! You! You! 
I don't like your girlfriend! 
No way! No way! 
I think you need a new one!
</pre>
<p>And here's our program:</p>
<pre name="code" class="haskell:hs">
import System.IO

main = do
    handle &lt;- openFile "girlfriend.txt" ReadMode
    contents &lt;- hGetContents handle
    putStr contents
    hClose handle
</pre>
<p>Running it, we get the expected result:</p>
<pre name="code" class="plain">
$ runhaskell girlfriend.hs
Hey! Hey! You! You!
I don't like your girlfriend!
No way! No way!
I think you need a new one!
</pre>
<p>Let's go over this line by line. The first line is just four exclamations, to get our attention. In the second line, Avril tells us that she doesn't like our current romantic partner. The third line serves to emphasize that disapproval, whereas the fourth line suggests we should seek out a new girlfriend.</p>
<p>Let's also go over the program line by line! Our program is several I/O actions glued together with a <i>do</i> block. In the first line of the <i>do</i> block, we notice a new function called <code class="label function">openFile</code>. This is its type signature: <code class="fixed">openFile :: FilePath -&gt; IOMode -&gt; IO Handle</code>. If you read that out loud, it states: <code class="fixed">openFile</code> takes a file path and an <code class="fixed">IOMode</code> and returns an I/O action that will open a file and have the file's associated handle encapsulated as its result.</p>
<p><code class="fixed">FilePath</code> is just a <a href="making-our-own-types-and-typeclasses.html#type-synonyms">type synonym</a> for <code class="fixed">String</code>, simply defined as:</p>
<pre name="code" class="haskell:hs">
type FilePath = String
</pre>
<p><code class="fixed">IOMode</code> is a type that's defined like this:</p>
<pre name="code" class="haskell:hs">
data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
</pre>
<img src="lyah/file.png" alt="A FILE IN A CAKE!!!" class="left" width="232" height="340">
<p>Just like our type that represents the seven possible values for the days of the week, this type is an enumeration that represents what we want to do with our opened file. Very simple. Just note that this type is <code class="fixed">IOMode</code> and not <code class="fixed">IO Mode</code>. <code class="fixed">IO Mode</code> would be the type of an I/O action that has a value of some type <code class="fixed">Mode</code> as its result, but <code class="fixed">IOMode</code> is just a simple enumeration.</p>
<p>Finally, it returns an I/O action that will open the specified file in the specified mode. If we bind that action to something we get a <code class="fixed">Handle</code>. A value of type <code class="fixed">Handle</code> represents where our file is. We'll use that handle so we know which file to read from. It would be stupid to read a file but not bind that read to a handle because we wouldn't be able to do anything with the file. So in our case, we bound the handle to <code class="fixed">handle</code>.</p>
<p>In the next line, we see a function called <code class="label function">hGetContents</code>. It takes a <code class="fixed">Handle</code>, so it knows which file to get the contents from and returns an <code class="fixed">IO String</code> &mdash; an I/O action that holds as its result the contents of the file. This function is pretty much like <code class="fixed">getContents</code>. The only difference is that <code class="fixed">getContents</code> will automatically read from the standard input (that is from the terminal), whereas <code class="fixed">hGetContents</code> takes a file handle which tells it which file to read from. In all other respects, they work the same. And just like <code class="fixed">getContents</code>, <code class="fixed">hGetContents</code> won't attempt to read the file at once and store it in memory, but it will read it as needed. That's really cool because we can treat <code class="fixed">contents</code> as the whole contents of the file, but it's not really loaded in memory. So if this were a really huge file, doing <code class="fixed">hGetContents</code> wouldn't choke up our memory, but it would read only what it needed to from the file, when it needed to.</p>
<p>Note the difference between the handle used to identify a file and the contents of the file, bound in our program to <code class="fixed">handle</code> and <code class="fixed">contents</code>. The handle is just something by which we know what our file is. If you imagine your whole file system to be a really big book and each file is a chapter in the book, the handle is a bookmark that shows where you're currently reading (or writing) a chapter, whereas the contents are the actual chapter.</p>
<p>With <code class="fixed">putStr contents</code> we just print the contents out to the standard output and then we do <code class="label function">hClose</code>, which takes a handle and returns an I/O action that closes the file. You have to close the file yourself after opening it with <code class="fixed">openFile</code>!</p>
<p>Another way of doing what we just did is to use the <code class="label function">withFile</code> function, which has a type signature of <code class="fixed">withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a</code>. It takes a path to a file, an <code class="fixed">IOMode</code> and then it takes a function that takes a handle and returns some I/O action. What it returns is an I/O action that will open that file, do something we want with the file and then close it. The result encapsulated in the final I/O action that's returned is the same as the result of the I/O action that the function we give it returns. This might sound a bit complicated, but it's really simple, especially with lambdas, here's our previous example rewritten to use <code class="fixed">withFile</code>:</p>
<pre name="code" class="haskell:hs">
import System.IO   
  
main = do   
    withFile "girlfriend.txt" ReadMode (\handle -&gt; do
        contents &lt;- hGetContents handle   
        putStr contents)
</pre>
<p>As you can see, it's very similar to the previous piece of code. <code class="fixed">(\handle -&gt; ... )</code> is the function that takes a handle and returns an I/O action and it's usually done like this, with a lambda. The reason it has to take a function that returns an I/O action instead of just taking an I/O action to do and then close the file is because the I/O action that we'd pass to it wouldn't know on which file to operate. This way, <code class="fixed">withFile</code> opens the file and then passes the handle to the function we gave it. It gets an I/O action back from that function and then makes an I/O action that's just like it, only it closes the file afterwards. Here's how we can make our own <code class="fixed">withFile</code> function:</p>
<pre name="code" class="haskell:hs">
withFile' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a
withFile' path mode f = do
    handle &lt;- openFile path mode 
    result &lt;- f handle
    hClose handle
    return result
</pre>
<img src="lyah/edd.png" alt="butter toast" class="right" width="246" height="360">
<p>We know the result will be an I/O action so we can just start off with a <i>do</i>. First we open the file and get a handle from it. Then, we apply <code class="fixed">handle</code> to our function to get back the I/O action that does all the work. We bind that action to <code class="fixed">result</code>, close the handle and then do <code class="fixed">return result</code>. By <code class="fixed">return</code>ing the result encapsulated in the I/O action that we got from <code class="fixed">f</code>, we make it so that our I/O action encapsulates the same result as the one we got from <code class="fixed">f handle</code>. So if <code class="fixed">f handle</code> returns an action that will read a number of lines from the standard input and write them to a file and have as its result encapsulated the number of lines it read, if we used that with <code class="fixed">withFile'</code>, the resulting I/O action would also have as its result the number of lines read.</p>
<p>Just like we have <code class="fixed">hGetContents</code> that works like <code class="fixed">getContents</code> but for a specific file, there's also <code class="label function">hGetLine</code>, <code class="label function">hPutStr</code>, <code class="label function">hPutStrLn</code>, <code class="label function">hGetChar</code>, etc. They work just like their counterparts without the <i>h</i>, only they take a handle as a parameter and operate on that specific file instead of operating on standard input or standard output. Example: <code class="fixed">putStrLn</code> is a function that takes a string and returns an I/O action that will print out that string to the terminal and a newline after it. <code class="fixed">hPutStrLn</code> takes a handle and a string and returns an I/O action that will write that string to the file associated with the handle and then put a newline after it. In the same vein, <code class="fixed">hGetLine</code> takes a handle and returns an I/O action that reads a line from its file.</p>
<p>Loading files and then treating their contents as strings is so common that we have these three nice little functions to make our work even easier:</p>
<p>
<code class="label function">readFile</code> has a type signature of <code class="fixed">readFile :: FilePath -&gt; IO String</code>. 
Remember, <code class="fixed">FilePath</code> is just a fancy name for <code class="fixed">String</code>. 
<code class="fixed">readFile</code> takes a path to a file and returns an I/O action that will read that file (lazily, of course) and bind its contents to something as a string. 
It's usually more handy than doing <code class="fixed">openFile</code> and binding it to a handle and then doing <code class="fixed">hGetContents</code>.
Here's how we could have written our previous example with <code class="fixed">readFile</code>:
</p>
<pre name="code" class="haskell:hs">
import System.IO

main = do
    contents &lt;- readFile "girlfriend.txt"
    putStr contents
</pre>
<p>
Because we don't get a handle with which to identify our file, we can't close it manually, so Haskell does that for us when we use <code class="fixed">readFile</code>.
</p>
<p>
<code class="label function">writeFile</code> has a type of <code class="fixed">writeFile :: FilePath -&gt; String -&gt; IO ()</code>.
It takes a path to a file and a string to write to that file and returns an I/O action that will do the writing. If such a file already exists, it will be stomped down to zero length before being written on. Here's how to turn <i>girlfriend.txt</i> into a CAPSLOCKED version and write it to <i>girlfriendcaps.txt</i>:
</p>
<pre name="code" class="haskell:hs">
import System.IO   
import Data.Char
  
main = do   
    contents &lt;- readFile "girlfriend.txt"   
    writeFile "girlfriendcaps.txt" (map toUpper contents)
</pre>
<pre name="code" class="plain">
$ runhaskell girlfriendtocaps.hs
$ cat girlfriendcaps.txt
HEY! HEY! YOU! YOU!
I DON'T LIKE YOUR GIRLFRIEND!
NO WAY! NO WAY!
I THINK YOU NEED A NEW ONE!
</pre>
<p><code class="label function">appendFile</code> has a type signature that's just like <code class="fixed">writeFile</code>, only <code class="fixed">appendFile</code> doesn't truncate the file to zero length if it already exists but it appends stuff to it.</p>
<p>Let's say we have a file <i>todo.txt</i> that has one task per line that we have to do. Now let's make a program that takes a line from the standard input and adds that to our to-do list.</p>
<pre name="code" class="haskell:hs">
import System.IO   
  
main = do   
    todoItem &lt;- getLine
    appendFile "todo.txt" (todoItem ++ "\n")
</pre>
<pre name="code" class="plain">
$ runhaskell appendtodo.hs
Iron the dishes
$ runhaskell appendtodo.hs
Dust the dog
$ runhaskell appendtodo.hs
Take salad out of the oven
$ cat todo.txt
Iron the dishes
Dust the dog
Take salad out of the oven
</pre>
<p>We needed to add the <code class="fixed">"\n"</code> to the end of each line because <code class="fixed">getLine</code> doesn't give us a newline character at the end.</p>
<p>Ooh, one more thing. We talked about how doing <code class="fixed">contents &lt;- hGetContents handle</code> doesn't cause the whole file to be read at once and stored in-memory. It's I/O lazy, so doing this:</p>
<pre name="code" class="haskell:hs">
main = do 
    withFile "something.txt" ReadMode (\handle -&gt; do
        contents &lt;- hGetContents handle
        putStr contents)
</pre>
<p>is actually like connecting a pipe from the file to the output. Just like you can think of lists as streams, you can also think of files as streams. This will read one line at a time and print it out to the terminal as it goes along. So you may be asking, how wide is this pipe then? How often will the disk be accessed? Well, for text files, the default buffering is line-buffering usually. That means that the smallest part of the file to be read at once is one line. That's why in this case it actually reads a line, prints it to the output, reads the next line, prints it, etc. For binary files, the default buffering is usually block-buffering. That means that it will read the file chunk by chunk. The chunk size is some size that your operating system thinks is cool.</p>
<p>You can control how exactly buffering is done by using the <code class="fixed">hSetBuffering</code> function. It takes a handle and a <code class="fixed">BufferMode</code> and returns an I/O action that sets the buffering. <code class="fixed">BufferMode</code> is a simple enumeration data type and the possible values it can hold are: <code class="fixed">NoBuffering</code>, <code class="fixed">LineBuffering</code> or <code class="fixed">BlockBuffering (Maybe Int)</code>. The <code class="fixed">Maybe Int</code> is for how big the chunk should be, in bytes. If it's <code class="fixed">Nothing</code>, then the operating system determines the chunk size. <code class="fixed">NoBuffering</code> means that it will be read one character at a time. <code class="fixed">NoBuffering</code> usually sucks as a buffering mode because it has to access the disk so much.</p>
<p>Here's our previous piece of code, only it doesn't read it line by line but reads the whole file in chunks of 2048 bytes.</p>
<pre name="code" class="haskell:hs">
main = do 
    withFile "something.txt" ReadMode (\handle -&gt; do
        hSetBuffering handle $ BlockBuffering (Just 2048)
        contents &lt;- hGetContents handle
        putStr contents)
</pre>
<p>Reading files in bigger chunks can help if we want to minimize disk access or when our file is actually a slow network resource.</p>
<p>We can also use <code class="label function">hFlush</code>, which is a function that takes a handle and returns an I/O action that will flush the buffer of the file associated with the handle. When we're doing line-buffering, the buffer is flushed after every line. When we're doing block-buffering, it's after we've read a chunk. It's also flushed after closing a handle. That means that when we've reached a newline character, the reading (or writing) mechanism reports all the data so far. But we can use <code class="fixed">hFlush</code> to force that reporting of data that has been read so far. After flushing, the data is available to other programs that are running at the same time.</p>
<p>Think of reading a block-buffered file like this: your toilet bowl is set to flush itself after it has one gallon of water inside it. So you start pouring in water and once the gallon mark is reached, that water is automatically flushed and the data in the water that you've poured in so far is read. But you can flush the toilet manually too by pressing the button on the toilet. This makes the toilet flush and all the water (data) inside the toilet is read. In case you haven't noticed, flushing the toilet manually is a metaphor for <code class="fixed">hFlush</code>. This is not a very great analogy by programming analogy standards, but I wanted a real world object that can be flushed for the punchline.</p>
<p>We already made a program to add a new item to our to-do list in <i>todo.txt</i>, now let's make a program to remove an item. I'll just paste the code and then we'll go over the program together so you see that it's really easy. We'll be using a few new functions from <code class="fixed">System.Directory</code> and one new function from <code class="fixed">System.IO</code>, but they'll all be explained.</p>
<p>Anyway, here's the program for removing an item from <i>todo.txt</i>:</p>
<pre name="code" class="haskell:hs">
import System.IO
import System.Directory
import Data.List

main = do      
    handle &lt;- openFile "todo.txt" ReadMode
    (tempName, tempHandle) &lt;- openTempFile "." "temp"
    contents &lt;- hGetContents handle
    let todoTasks = lines contents   
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line) [0..] todoTasks   
    putStrLn "These are your TO-DO items:"
    putStr $ unlines numberedTasks
    putStrLn "Which one do you want to delete?"   
    numberString &lt;- getLine   
    let number = read numberString   
        newTodoItems = delete (todoTasks !! number) todoTasks   
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile "todo.txt"
    renameFile tempName "todo.txt"
</pre>
<p>At first, we just open <i>todo.txt</i> in read mode and bind its handle to <code class="fixed">handle</code>.
<p>Next up, we use a function that we haven't met before which is from <code class="fixed">System.IO</code> &mdash; <code class="label function">openTempFile</code>. Its name is pretty self-explanatory. It takes a path to a temporary directory and a template name for a file and opens a temporary file. We used <code class="fixed">"."</code> for the temporary directory, because <code class="fixed">.</code> denotes the current directory on just about any OS. We used <code class="fixed">"temp"</code> as the template name for the temporary file, which means that the temporary file will be named <i>temp</i> plus some random characters. It returns an I/O action that makes the temporary file and the result in that I/O action is a pair of values: the name of the temporary file and a handle. We could just open a normal file called <i>todo2.txt</i> or something like that but it's better practice to use <code class="fixed">openTempFile</code> so you know you're probably not overwriting anything.
</p>
<p>The reason we didn't use <code class="fixed">getCurrentDirectory</code> to get the current directory and then pass it to <code class="fixed">openTempFile</code> but instead just passed <code class="fixed">"."</code> to <code class="fixed">openTempFile</code> is because <code class="fixed">.</code> refers to the current directory on unix-like system and Windows
<p>Next up, we bind the contents of <i>todo.txt</i> to <code class="fixed">contents</code>. Then, split that string into a list of strings, each string one line. So <code class="fixed">todoTasks</code> is now something like <code class="fixed">["Iron the dishes", "Dust the dog", "Take salad out of the oven"]</code>. We zip the numbers from 0 onwards and that list with a function that takes a number, like 3, and a string, like <code class="fixed">"hey"</code> and returns <code class="fixed">"3 - hey"</code>, so <code class="fixed">numberedTasks</code> is <code class="fixed">["0 - Iron the dishes", "1 - Dust the dog" ...</code>. We join that list of strings into a single newline delimited string with <code class="fixed">unlines</code> and print that string out to the terminal. Note that instead of doing that, we could have also done <code class="fixed">mapM putStrLn numberedTasks</code></p>
<p>We ask the user which one they want to delete and wait for them to enter a number. Let's say they want to delete number 1, which is <code class="fixed">Dust the dog</code>, so they punch in <code class="fixed">1</code>. <code class="fixed">numberString</code> is now <code class="fixed">"1"</code> and because we want a number, not a string, we run <code class="fixed">read</code> on that to get <code class="fixed">1</code> and bind that to <code class="fixed">number</code>.</p>
<p>Remember the <code class="fixed">delete</code> and <code class="fixed">!!</code> functions from <code class="fixed">Data.List</code>. <code class="fixed">!!</code> returns an element from a list with some index and <code class="fixed">delete</code> deletes the first occurence of an element in a list and returns a new list without that occurence. <code class="fixed">(todoTasks !! number)</code> (number is now <code class="fixed">1</code>) returns <code class="fixed">"Dust the dog"</code>. We bind <code class="fixed">todoTasks</code> without the first occurence of <code class="fixed">"Dust the dog"</code> to <code class="fixed">newTodoItems</code> and then join that into a single string with <code class="fixed">unlines</code> before writing it to the temporary file that we opened. The old file is now unchanged and the temporary file contains all the lines that the old one does, except the one we deleted.</p>
<p>After that we close both the original and the temporary files and then we remove the original one with <code class="label function">removeFile</code>, which, as you can see, takes a path to a file and deletes it. After deleting the old <i>todo.txt</i>, we use <code class="label function">renameFile</code> to rename the temporary file to <i>todo.txt</i>. Be careful, <code class="fixed">removeFile</code> and <code class="fixed">renameFile</code> (which are both in <code class="fixed">System.Directory</code> by the way) take file paths as their parameters, not handles.</p>
<p>And that's that! We could have done this in even fewer lines, but we were very careful not to overwrite any existing files and politely asked the operating system to tell us where we can put our temporary file. Let's give this a go!</p>
<pre name="code" class="plain">
$ runhaskell deletetodo.hs
These are your TO-DO items:
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven
Which one do you want to delete?
1

$ cat todo.txt
Iron the dishes
Take salad out of the oven

$ runhaskell deletetodo.hs
These are your TO-DO items:
0 - Iron the dishes
1 - Take salad out of the oven
Which one do you want to delete?
0

$ cat todo.txt
Take salad out of the oven
</pre>
<a name="command-line-arguments"></a><h2>Command line arguments</h2>
<img src="lyah/arguments.png" alt="COMMAND LINE ARGUMENTS!!! ARGH" width="449" height="380" class="right">
<p>Dealing with command line arguments is pretty much a necessity if you want to make a script or application that runs on a terminal. Luckily, Haskell's standard library has a nice way of getting command line arguments of a program.</p>
<p>In the previous section, we made one program for adding a to-do item to our to-do list and one program for removing an item. There are two problems with the approach we took. The first one is that we just hardcoded the name of our to-do file in our code. We just decided that the file will be named <i>todo.txt</i> and that the user will never have a need for managing several to-do lists.</p>
<p>One way to solve that is to always ask the user which file they want to use as their to-do list. We used that approach when we wanted to know which item the user wants to delete. It works, but it's not so good, because it requires the user to run the program, wait for the program to ask something and then tell that to the program. That's called an interactive program and the difficult bit with interactive command line programs is this &mdash; what if you want to automate the execution of that program, like with a batch script? It's harder to make a batch script that interacts with a program than a batch script that just calls one program or several of them.</p>
<p>That's why it's sometimes better to have the user tell the program what they want when they run the program, instead of having the program ask the user once it's run. And what better way to have the user tell the program what they want it to do when they run it than via command line arguments!</p>
<p>The <code class="fixed">System.Environment</code> module has two cool I/O actions. One is <code class="label function">getArgs</code>, which has a type of <code class="fixed">getArgs :: IO [String]</code> and is an I/O action that will get the arguments that the program was run with and have as its contained result a list with the arguments. <code class="label function">getProgName</code> has a type of <code class="fixed">getProgName :: IO String</code> and is an I/O action that contains the program name.</p>
<p>Here's a small program that demonstrates how these two work:</p>
<pre name="code" class="haskell:hs">
 import System.Environment 
 import Data.List
 
 main = do
    args &lt;- getArgs
    progName &lt;- getProgName
    putStrLn "The arguments are:"
    mapM putStrLn args
    putStrLn "The program name is:"
    putStrLn progName
</pre> 
<p>We bind <code class="fixed">getArgs</code> and <code class="fixed">progName</code> to <code class="fixed">args</code> and <code class="fixed">progName</code>. We say <code class="fixed">The arguments are:</code> and then for every argument in <code class="fixed">args</code>, we do <code class="fixed">putStrLn</code>. Finally, we also print out the program name. Let's compile this as <code class="fixed">arg-test</code>.</p>
<pre name="code" class="plain">
$ ./arg-test first second w00t "multi word arg"
The arguments are:
first
second
w00t
multi word arg
The program name is:
arg-test
</pre>
<p>Nice. Armed with this knowledge you could create some cool command line apps. In fact, let's go ahead and make one. In the previous section, we made a separate program for adding tasks and a separate program for deleting them. Now, we're going to join that into one program, what it does will depend on the command line arguments. We're also going to make it so it can operate on different files, not just <i>todo.txt</i>.</p>
<p>We'll call it simply <i>todo</i> and it'll be able to do (haha!) three different things:</p>
<ul>
    <li>View tasks</li>
    <li>Add tasks</li>
    <li>Delete tasks</li>
</ul>
<p>We're not going to concern ourselves with possible bad input too much right now.</p>
<p>Our program will be made so that if we want to add the task <code class="fixed">Find the magic sword of power</code> to the file <i>todo.txt</i>, we have to punch in <code class="fixed">todo add todo.txt "Find the magic sword of power"</code> in our terminal. To view the tasks we'll just do <code class="fixed">todo view todo.txt</code> and to remove the task with the index of 2, we'll do <code class="fixed">todo remove todo.txt 2</code>.</p>
<p>We'll start by making a dispatch association list. It's going to be a simple association list that has command line arguments as keys and functions as their corresponding values. All these functions will be of type <code class="fixed">[String] -&gt; IO ()</code>. They're going to take the argument list as a parameter and return an I/O action that does the viewing, adding, deleting, etc.</p>
<pre name="code" class="haskell:hs">
import System.Environment 
import System.Directory
import System.IO
import Data.List

dispatch :: [(String, [String] -&gt; IO ())]
dispatch =  [ ("add", add)
            , ("view", view)
            , ("remove", remove)
            ]
</pre>
<p>We have yet to define <code class="fixed">main</code>, <code class="fixed">add</code>, <code class="fixed">view</code> and <code class="fixed">remove</code>, so let's start with <code class="fixed">main</code>:</p>
<pre name="code" class="haskell:hs">
main = do
    (command:args) &lt;- getArgs
    let (Just action) = lookup command dispatch
    action args
</pre>
<p>First, we get the arguments and bind them to <code class="fixed">(command:args)</code>. If you remember your pattern matching, this means that the first argument will get bound to <code class="fixed">command</code> and the rest of them will get bound to <code class="fixed">args</code>. If we call our program like <code class="fixed">todo add todo.txt "Spank the monkey"</code>, <code class="fixed">command</code> will be <code class="fixed">"add"</code> and <code class="fixed">args</code> will be <code class="fixed">["todo.xt", "Spank the monkey"]</code>.</p>
<p>In the next line, we look up our command in the dispatch list. Because <code class="fixed">"add"</code> points to <code class="fixed">add</code>, we get <code class="fixed">Just add</code> as a result. We use pattern matching again to extract our function out of the <code class="fixed">Maybe</code>. What happens if our command isn't in the dispatch list? Well then the lookup will return <code class="fixed">Nothing</code>, but we said we won't concern ourselves with failing gracefully too much, so the pattern matching will fail and our program will throw a fit.</p>
<p>Finally, we call our <code class="fixed">action</code> function with the rest of the argument list. That will return an I/O action that either adds an item, displays a list of items or deletes an item and because that action is part of the <code class="fixed">main</code> <i>do</i> block, it will get performed. If we follow our concrete example so far and our <code class="fixed">action</code> function is <code class="fixed">add</code>, it will get called with <code class="fixed">args</code> (so <code class="fixed">["todo.txt", "Spank the monkey"]</code>) and return an I/O action that adds <code class="fixed">Spank the monkey</code> to <i>todo.txt</i>.</p>
<p>Great! All that's left now is to implement <code class="fixed">add</code>, <code class="fixed">view</code> and <code class="fixed">remove</code>. Let's start with <code class="fixed">add</code>:</p>
<pre name="code" class="haskell:hs">
add :: [String] -&gt; IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")
</pre>
<p>If we call our program like <code class="fixed">todo add todo.txt "Spank the monkey"</code>, the <code class="fixed">"add"</code> will get bound to <code class="fixed">command</code> in the first pattern match in the <code class="fixed">main</code> block, whereas <code class="fixed">["todo.txt", "Spank the monkey"]</code> will get passed to the function that we get from the dispatch list. So, because we're not dealing with bad input right now, we just pattern match against a list with those two elements right away and return an I/O action that appends that line to the end of the file, along with a newline character.</p>
<p>Next, let's implement the list viewing functionality. If we want to view the items in a file, we do <code class="fixed">todo view todo.txt</code>. So in the first pattern match, <code class="fixed">command</code> will be <code class="fixed">"view"</code> and <code class="fixed">args</code> will be <code class="fixed">["todo.txt"]</code>.</p>
<pre name="code" class="haskell:hs">
view :: [String] -&gt; IO ()
view [fileName] = do
    contents &lt;- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line) [0..] todoTasks
    putStr $ unlines numberedTasks
</pre>
<p>We already did pretty much the same thing in the program that only deleted tasks when we were displaying the tasks so that the user can choose one for deletion, only here we just display the tasks.</p>
<p>And finally, we're going to implement <code class="fixed">remove</code>. It's going to be very similar to the program that only deleted the tasks, so if you don't understand how deleting an item here works, check out the explanation under that program. The main difference is that we're not hardcoding <i>todo.txt</i> but getting it as an argument. We're also not prompting the user for the task number to delete, we're getting it as an argument.</p>
<pre name="code" class="haskell:hs">
remove :: [String] -&gt; IO ()
remove [fileName, numberString] = do
    handle &lt;- openFile fileName ReadMode
    (tempName, tempHandle) &lt;- openTempFile "." "temp"
    contents &lt;- hGetContents handle
    let number = read numberString
        todoTasks = lines contents
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
</pre>
<p>We opened up the file based on <code class="fixed">fileName</code> and opened a temporary file, deleted the line with the index that the user wants to delete, wrote that to the temporary file, removed the original file and renamed the temporary file back to <code class="fixed">fileName</code>.</p>
<p>Here's the whole program at once, in all its glory!</p>
<pre name="code" class="haskell:hs">
import System.Environment 
import System.Directory
import System.IO
import Data.List

dispatch :: [(String, [String] -&gt; IO ())]
dispatch =  [ ("add", add)
            , ("view", view)
            , ("remove", remove)
            ]
 
main = do
    (command:args) &lt;- getArgs
    let (Just action) = lookup command dispatch
    action args

add :: [String] -&gt; IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ "\n")

view :: [String] -&gt; IO ()
view [fileName] = do
    contents &lt;- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -&gt; show n ++ " - " ++ line) [0..] todoTasks
    putStr $ unlines numberedTasks

remove :: [String] -&gt; IO ()
remove [fileName, numberString] = do
    handle &lt;- openFile fileName ReadMode
    (tempName, tempHandle) &lt;- openTempFile "." "temp"
    contents &lt;- hGetContents handle
    let number = read numberString
        todoTasks = lines contents
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
</pre>
<img src="lyah/salad.png" alt="fresh baked salad" class="left" width="143" height="200">
<p>To summarize our solution: we made a dispatch association that maps from commands to functions that take some command line arguments and return an I/O action. We see what the command is and based on that we get the appropriate function from the dispatch list. We call that function with the rest of the command line arguments to get back an I/O action that will do the appropriate thing and then just perform that action!</p>
<p>In other languages, we might have implemented this with a big switch case statement or whatever, but using higher order functions allows us to just tell the dispatch list to give us the appropriate function and then tell that function to give us an I/O action for some command line arguments.</p>
<p>Let's try our app out!</p>
<pre name="code" class="plain">
$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven

$ ./todo add todo.txt "Pick up children from drycleaners"

$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Take salad out of the oven
3 - Pick up children from drycleaners

$ ./todo remove todo.txt 2

$ ./todo view todo.txt
0 - Iron the dishes
1 - Dust the dog
2 - Pick up children from drycleaners
</pre>
<p>Another cool thing about this is that it's easy to add extra functionality. Just add an entry in the dispatch association list and implement the corresponding function and you're laughing! As an exercise, you can try implementing a <code class="fixed">bump</code> function that will take a file and a task number and return an I/O action that bumps that task to the top of the to-do list.</p>
<p>You could make this program fail a bit more gracefully in case of bad input (for example, if someone runs <code class="fixed">todo UP YOURS HAHAHAHA</code>) by making an I/O action that just reports there has been an error (say, <code class="fixed">errorExit :: IO ()</code>) and then check for possible erronous input and if there is erronous input, perform the error reporting I/O action. Another way is to use exceptions, which we will meet soon.</p>
<a name="randomness"></a><h2>Randomness</h2>
<img src="lyah/random.png" alt="this picture is the ultimate source of randomness and wackiness" width="358" height="362" class="right">
<p>Many times while programming, you need to get some random data. Maybe you're making a game where a die needs to be thrown or you need to generate some test data to test out your program. There are a lot of uses for random data when programming. Well, actually, pseudo-random, because we all know that the only true source of randomness is a monkey on a unicycle with a cheese in one hand and its butt in the other. In this section, we'll take a look at how to make Haskell generate seemingly random data.</p>
<p>In most other programming languages, you have functions that give you back some random number. Each time you call that function, you get back a (hopefully) different random number. How about Haskell? Well, remember, Haskell is a pure functional language. What that means is that it has referential transparency. What THAT means is that a function, if given the same parameters twice, must produce the same result twice. That's really cool because it allows us to reason differently about programs and it enables us to defer evaluation until we really need it. If I call a function, I can be sure that it won't do any funny stuff before giving me the results. All that matters are its results. However, this makes it a bit tricky for getting random numbers. If I have a function like this:</p>
<pre name="code" class="haskell:hs">
randomNumber :: (Num a) =&gt; a
randomNumber = 4
</pre>
<p>It's not very useful as a random number function because it will always return <code class="fixed">4</code>, even though I can assure you that the 4 is completely random, because I used a die to determine it.</p>
<p>How do other languages make seemingly random numbers? Well, they take various info from your computer, like the current time, how much and where you moved your mouse and what kind of noises you made behind your computer and based on that, give a number that looks really random. The combination of those factors (that randomness) is probably different in any given moment in time, so you get a different random number.</p>
<p>Ah. So in Haskell, we can make a random number then if we make a function that takes as its parameter that randomness and based on that returns some number (or other data type).</P>
<p>Enter the <code class="fixed">System.Random</code> module. It has all the functions that satisfy our need for randomness. Let's just dive into one of the functions it exports then, namely <code class="label function">random</code>. Here's its type: <code class="fixed">random :: (RandomGen g, Random a) =&gt; g -&gt; (a, g)</code>. Whoa! Some new typeclasses in this type declaration up in here! The <code class="label class">RandomGen</code> typeclass is for types that can act as sources of randomness. The <code class="label class">Random</code> typeclass is for things that can take on random values. A boolean value can take on a random value, namely <code class="fixed">True</code> or <code class="fixed">False</code>. A number can also take up a plethora of different random values. Can a function take on a random value? I don't think so, probably not! If we try to translate the type declaration of <code class="fixed">random</code> to English, we get something like: it takes a random generator (that's our source of randomness) and returns a random value and a new random generator. Why does it also return a new generator as well as a random value? Well, we'll see in a moment.</p>
<p>To use our <code class="fixed">random</code> function, we have to get our hands on one of those random generators. The <code class="fixed">System.Random</code> module exports a cool type, namely <code class="label type">StdGen</code> that is an instance of the <code class="fixed">RandomGen</code> typeclass. We can either make a <code class="fixed">StdGen</code> manually or we can tell the system to give us one based on a multitude of sort of random stuff.</p>
<p>To manually make a random generator, use the <code class="label function">mkStdGen</code> function. It has a type of <code class="fixed">mkStdGen :: Int -&gt; StdGen</code>. It takes an integer and based on that, gives us a random generator. Okay then, let's try using <code class="fixed">random</code> and <code class="fixed">mkStdGen</code> in tandem to get a (hardly random) number.</p>
<pre name="code" class="haskell:hs">
ghci&gt; random (mkStdGen 100)
</pre>
<pre name="code" class="plain">
&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraint:
      `Random a' arising from a use of `random' at &lt;interactive&gt;:1:0-20
    Probable fix: add a type signature that fixes these type variable(s)
</pre>
<p>What's this? Ah, right, the <code class="fixed">random</code> function can return a value of any type that's part of the <code class="fixed">Random</code> typeclass, so we have to inform Haskell what kind of type we want. Also let's not forget that it returns a random value and a random generator in a pair.</p>
<pre name="code" class="haskell:hs">
ghci&gt; random (mkStdGen 100) :: (Int, StdGen)
(-1352021624,651872571 1655838864)
</pre>
<p>Finally! A number that looks kind of random! The first component of the tuple is our number whereas the second component is a textual representation of our new random generator. What happens if we call <code class="fixed">random</code> with the same random generator again?</p>
<pre name="code" class="haskell:hs">
ghci&gt; random (mkStdGen 100) :: (Int, StdGen)
(-1352021624,651872571 1655838864)
</pre>
<p>Of course. The same result for the same parameters. So let's try giving it a different random generator as a parameter.</p>
<pre name="code" class="haskell:hs">
ghci&gt; random (mkStdGen 949494) :: (Int, StdGen)
(539963926,466647808 1655838864)
</pre>
<p>Alright, cool, great, a different number. We can use the type annotation to get different types back from that function. </p>
<pre name="code" class="haskell:hs">
ghci&gt; random (mkStdGen 949488) :: (Float, StdGen)
(0.8938442,1597344447 1655838864)
ghci&gt; random (mkStdGen 949488) :: (Bool, StdGen)
(False,1485632275 40692)
ghci&gt; random (mkStdGen 949488) :: (Integer, StdGen)
(1691547873,1597344447 1655838864)
</pre>
<p>Let's make a function that simulates tossing a coin three times. If <code class="fixed">random</code> didn't return a new generator along with a random value, we'd have to make this function take three random generators as a parameter and then return coin tosses for each of them. But that sounds wrong because if one generator can make a random value of type <code class="fixed">Int</code> (which can take on a load of different values), it should be able to make three coin tosses (which can take on precisely eight combinations). So this is where <code class="fixed">random</code> returning a new generator along with a value really comes in handy.</p>
<p>We'll represent a coin with a simple <code class="fixed">Bool</code>. <code class="fixed">True</code> is tails, <code class="fixed">False</code> is heads.</p>
<pre name="code" class="haskell:hs">
threeCoins :: StdGen -&gt; (Bool, Bool, Bool)
threeCoins gen = 
    let (firstCoin, newGen) = random gen
        (secondCoin, newGen') = random newGen
        (thirdCoin, newGen'') = random newGen'
    in  (firstCoin, secondCoin, thirdCoin)
</pre>
<p>We call <code class="fixed">random</code> with the generator we got as a parameter to get a coin and a new generator. Then we call it again, only this time with our new generator, to get the second coin. We do the same for the third coin. Had we called it with the same generator every time, all the coins would have had the same value and we'd only be able to get <code class="fixed">(False, False, False)</code> or <code class="fixed">(True, True, True)</code> as a result.</p>
<pre name="code" class="haskell:hs">
ghci&gt; threeCoins (mkStdGen 21)
(True,True,True)
ghci&gt; threeCoins (mkStdGen 22)
(True,False,True)
ghci&gt; threeCoins (mkStdGen 943)
(True,False,True)
ghci&gt; threeCoins (mkStdGen 944)
(True,True,True)
</pre>
<p>Notice that we didn't have to do <code class="fixed">random gen :: (Bool, StdGen)</code>. That's because we already specified that we want booleans in the type declaration of the function. That's why Haskell can infer that we want a boolean value in this case.</p>
<p>So what if we want to flip four coins? Or five? Well, there's a function called <code class="label function">randoms</code> that takes a generator and returns an infinite sequence of values based on that generator.</p>
<pre name="code" class="haskell:hs">
ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Int]
[-1807975507,545074951,-1015194702,-1622477312,-502893664]
ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Bool]
[True,True,True,True,False]
ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Float]
[7.904789e-2,0.62691015,0.26363158,0.12223756,0.38291094]
</pre>
<p>Why doesn't <code class="fixed">randoms</code> return a new generator as well as a list? We could implement the <code class="fixed">randoms</code> function very easily like this:</p>
<pre name="code" class="haskell:hs">
randoms' :: (RandomGen g, Random a) =&gt; g -&gt; [a]
randoms' gen = let (value, newGen) = random gen in value:randoms' newGen
</pre>
<p>A recursive definition. We get a random value and a new generator from the current generator and then make a list that has the value as its head and random numbers based on the new generator as its tail. Because we have to be able to potentially generate an infinite amount of numbers, we can't give the new random generator back.</p>
<p>We could make a function that generates a finite stream of numbers and a new generator like this:</p>
<pre name="code" class="haskell:hs">
finiteRandoms :: (RandomGen g, Random a, Num n) =&gt; n -&gt; g -&gt; ([a], g)
finiteRandoms 0 gen = ([], gen)
finiteRandoms n gen = 
    let (value, newGen) = random gen
        (restOfList, finalGen) = finiteRandoms (n-1) newGen
    in  (value:restOfList, finalGen)
</pre>
<p>Again, a recursive definition. We say that if we want 0 numbers, we just return an empty list and the generator that was given to us. For any other number of random values, we first get one random number and a new generator. That will be the head. Then we say that the tail will be <i>n - 1</i> numbers generated with the new generator. Then we return the head and the rest of the list joined and the final generator that we got from getting the <i>n - 1</i> random numbers.</p> 
<p>What if we want a random value in some sort of range? All the random integers so far were outrageously big or small. What if we want to to throw a die? Well, we use <code class="label function">randomR</code> for that purpose. It has a type of <code class="fixed">randomR :: (RandomGen g, Random a) :: (a, a) -&gt; g -&gt; (a, g)</code>, meaning that it's kind of like <code class="fixed">random</code>, only it takes as its first parameter a pair of values that set the lower and upper bounds and the final value produced will be within those bounds.<p>
<pre name="code" class="haskell:hs">
ghci&gt; randomR (1,6) (mkStdGen 359353)
(6,1494289578 40692)
ghci&gt; randomR (1,6) (mkStdGen 35935335)
(3,1250031057 40692)
</pre>
<p>There's also <code class="label function">randomRs</code>, which produces a stream of random values within our defined ranges. Check this out:</p>
<pre name="code" class="haskell:hs">
ghci&gt; take 10 $ randomRs ('a','z') (mkStdGen 3) :: [Char]
"ndkxbvmomg"
</pre>
<p>Nice, looks like a super secret password or something.</p>
<p>You may be asking yourself, what does this section have to do with I/O anyway? We haven't done anything concerning I/O so far. Well, so far we've always made our random number generator manually by making it with some arbitrary integer. The problem is, if we do that in our real programs, they will always return the same random numbers, which is no good for us. That's why <code class="fixed">System.Random</code> offers the <code class="label function">getStdGen</code> I/O action, which has a type of <code class="fixed">IO StdGen</code>. When your program starts, it asks the system for a good random number generator and stores that in a so called global generator. <code class="fixed">getStdGen</code> fetches you that global random generator when you bind it to something. </p>
<p>Here's a simple program that generates a random string.</p>
<pre name="code" class="haskell:hs">
import System.Random

main = do
    gen &lt;- getStdGen
    putStr $ take 20 (randomRs ('a','z') gen)
</pre>
<pre name="code" class="plain">
$ runhaskell random_string.hs
pybphhzzhuepknbykxhe
$ runhaskell random_string.hs
eiqgcxykivpudlsvvjpg
$ runhaskell random_string.hs
nzdceoconysdgcyqjruo
$ runhaskell random_string.hs
bakzhnnuzrkgvesqplrx
</pre>
<p>Be careful though, just performing <code class="fixed">getStdGen</code> twice will ask the system for the same global generator twice. If you do this:</p>
<pre name="code" class="haskell:hs">
import System.Random

main = do
    gen &lt;- getStdGen
    putStrLn $ take 20 (randomRs ('a','z') gen)
    gen2 &lt;- getStdGen
    putStr $ take 20 (randomRs ('a','z') gen2)
</pre>
<p>you will get the same string printed out twice! One way to get two different strings of length 20 is to set up an infinite stream and then take the first 20 characters and print them out in one line and then take the second set of 20 characters and print them out in the second line. For this, we can use the <code class="fixed">splitAt</code> function from <code class="fixed">Data.List</code>, which splits a list at some index and returns a tuple that has the first part as the first component and the second part as the second component.</p>
<pre name="code" class="haskell:hs">
import System.Random
import Data.List

main = do
    gen &lt;- getStdGen
    let randomChars = randomRs ('a','z') gen
        (first20, rest) = splitAt 20 randomChars
        (second20, _) = splitAt 20 rest
    putStrLn first20
    putStr second20
</pre>
<p>Another way is to use the <code class="label function">newStdGen</code> action, which splits our current random generator into two generators. It updates the global random generator with one of them and encapsulates the other as its result.</p>
<pre name="code" class="haskell:hs">
import System.Random

main = do   
    gen &lt;- getStdGen   
    putStrLn $ take 20 (randomRs ('a','z') gen)   
    gen' &lt;- newStdGen
    putStr $ take 20 (randomRs ('a','z') gen')   
</pre>
<p>Not only do we get a new random generator when we bind <code class="fixed">newStdGen</code> to something, the global one gets updated as well, so if we do <code class="fixed">getStdGen</code> again and bind it to something, we'll get a generator that's not the same as <code class="fixed">gen</code>.</p>
<p>Here's a little program that will make the user guess which number it's thinking of.</p>
<pre name="code" class="haskell:hs">
import System.Random
import Control.Monad(when)

main = do
    gen &lt;- getStdGen
    askForNumber gen

askForNumber :: StdGen -&gt; IO ()
askForNumber gen = do
    let (randNumber, newGen) = randomR (1,10) gen :: (Int, StdGen)
    putStr "Which number in the range from 1 to 10 am I thinking of? "
    numberString &lt;- getLine
    when (not $ null numberString) $ do
        let number = read numberString
        if randNumber == number 
            then putStrLn "You are correct!"
            else putStrLn $ "Sorry, it was " ++ show randNumber
        askForNumber newGen
</pre>
<img src="lyah/jackofdiamonds.png" alt="jack of diamonds" class="left" width="313" height="280">
<p>We make a function <code class="fixed">askForNumber</code>, which takes a random number generator and returns an I/O action that will prompt the user for a number and tell him if he guessed it right. In that function, we first generate a random number and a new generator based on the generator that we got as a parameter and call them <code class="fixed">randNumber</code> and <code class="fixed">newGen</code>. Let's say that the number generated was <code class="fixed">7</code>. Then we tell the user to guess which number we're thinking of. We perform <code class="fixed">getLine</code> and bind its result to <code class="fixed">numberString</code>. When the user enters <code class="fixed">7</code>, <code class="fixed">numberString</code> becomes <code class="fixed">"7"</code>. Next, we use <code class="fixed">when</code> to check if the string the user entered is an empty string. If it is, an empty I/O action of <code class="fixed">return ()</code> is performed, which effectively ends the program. If it isn't, the action consisting of that <i>do</i> block right there gets performed. We use <code class="fixed">read</code> on <code class="fixed">numberString</code> to convert it to a number, so <code class="fixed">number</code> is now <code class="fixed">7</code>.</p>
<div class="hintbox"><b>Excuse me!</b> If the user gives us some input here that <code class="fixed">read</code> can't read (like <code class="fixed">"haha"</code>), our program will crash with an ugly error message. If you don't want your program to crash on erronous input, use <code class="label function">reads</code>, which returns an empty list when it fails to read a string. When it succeeds, it returns a singleton list with a tuple that has our desired value as one component and a string with what it didn't consume as the other.</div>
<p>We check if the number that we entered is equal to the one generated randomly and give the user the appropriate message. And then we call <code class="fixed">askForNumber</code> recursively, only this time with the new generator that we got, which gives us an I/O action that's just like the one we performed, only it depends on a different generator and we perform it.</p>
<p><code class="fixed">main</code> consists of just getting a random generator from the system and calling <code class="fixed">askForNumber</code> with it to get the initial action.</p>
<p>Here's our program in action!</p>
<pre name="code" class="plain">
$ runhaskell guess_the_number.hs
Which number in the range from 1 to 10 am I thinking of? 4
Sorry, it was 3
Which number in the range from 1 to 10 am I thinking of? 10
You are correct!
Which number in the range from 1 to 10 am I thinking of? 2
Sorry, it was 4
Which number in the range from 1 to 10 am I thinking of? 5
Sorry, it was 10
Which number in the range from 1 to 10 am I thinking of?

</pre>
<p>Another way to make this same program is like this:</p>
<pre name="code" class="haskell:hs">
import System.Random
import Control.Monad(when)

main = do
    gen &lt;- getStdGen
    let (randNumber, _) = randomR (1,10) gen :: (Int, StdGen)   
    putStr "Which number in the range from 1 to 10 am I thinking of? "
    numberString &lt;- getLine
    when (not $ null numberString) $ do
        let number = read numberString
        if randNumber == number
            then putStrLn "You are correct!"
            else putStrLn $ "Sorry, it was " ++ show randNumber
        newStdGen
        main
</pre>
<p>It's very similar to the previous version, only instead of making a function that takes a generator and then calls itself recursively with the new updated generator, we do all the work in <code class="fixed">main</code>. After telling the user whether they were correct in their guess or not, we update the global generator and then call <code class="fixed">main</code> again. Both approaches are valid but I like the first one more since it does less stuff in <code class="fixed">main</code> and also provides us with a function that we can reuse easily.</p>
<a name="bytestrings"></a><h2>Bytestrings</h2>
<img src="lyah/chainchomp.png" alt="like normal string, only they byte ... what a pedestrian pun this is" class="right" width="306" height="390">
<p>Lists are a cool and useful data structure. So far, we've used them pretty much everywhere. There are a multitude of functions that operate on them and Haskell's laziness allows us to exchange the for and while loops of other languages for filtering and mapping over lists, because evaluation will only happen once it really needs to, so things like infinite lists (and even infinite lists of infinite lists!) are no problem for us. That's why lists can also be used to represent streams, either when reading from the standard input or when reading from files. We can just open a file and read it as a string, even though it will only be accessed when the need arises.</p>
<p>However, processing files as strings has one drawback: it tends to be slow. As you know, <code class="fixed">String</code> is a type synonym for <code class="fixed">[Char]</code>. <code class="fixed">Char</code>s don't have a fixed size, because it takes several bytes to represent a character from, say, Unicode. Furthemore, lists are really lazy. If you have a list like <code class="fixed">[1,2,3,4]</code>, it will be evaluated only when completely necessary. So the whole list is sort of a promise of a list. Remember that <code class="fixed">[1,2,3,4]</code> is syntactic sugar for <code class="fixed">1:2:3:4:[]</code>. When the first element of the list is forcibly evaluated (say by printing it), the rest of the list <code class="fixed">2:3:4:[]</code> is still just a promise of a list, and so on. So you can think of lists as promises that the next element will be delivered once it really has to and along with it, the promise of the element after it. It doesn't take a big mental leap to conclude that processing a simple list of numbers as a series of promises might not be the most efficient thing in the world.</p>
<p>That overhead doesn't bother us so much most of the time, but it turns out to be a liability when reading big files and manipulating them. That's why Haskell has <em>bytestrings</em>. Bytestrings are sort of like lists, only each element is one byte (or 8 bits) in size. The way they handle laziness is also different. </p>
<p>Bytestrings come in two flavors: strict and lazy ones. Strict bytestrings reside in <code class="fixed">Data.ByteString</code> and they do away with the laziness completely. There are no promises involved; a strict bytestring represents a series of bytes in an array. You can't have things like infinite strict bytestrings. If you evaluate the first byte of a strict bytestring, you have to evaluate it whole. The upside is that there's less overhead because there are no thunks (the technical term for <i>promise</i>) involved. The downside is that they're likely to fill your memory up faster because they're read into memory at once.</p>
<p>The other variety of bytestrings resides in <code class="fixed">Data.ByteString.Lazy</code>. They're lazy, but not quite as lazy as lists. Like we said before, there are as many thunks in a list as there are elements. That's what makes them kind of slow for some purposes. Lazy bytestrings take a different approach &mdash; they are stored in chunks (not to be confused with thunks!), each chunk has a size of 64K. So if you evaluate a byte in a lazy bytestring (by printing it or something), the first 64K will be evaluated. After that, it's just a promise for the rest of the chunks. Lazy bytestrings are kind of like lists of strict bytestrings with a size of 64K. When you process a file with lazy bytestrings, it will be read chunk by chunk. This is cool because it won't cause the memory usage to skyrocket and the 64K probably fits neatly into your CPU's L2 cache.</p>
<p>If you look through the <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html">documentation</a> for <code class="fixed">Data.ByteString.Lazy</code>, you'll see that it has a lot of functions that have the same names as the ones from <code class="fixed">Data.List</code>, only the type signatures have <code class="fixed">ByteString</code> instead of <code class="fixed">[a]</code> and <code class="fixed">Word8</code> instead of <code class="fixed">a</code> in them. The functions with the same names mostly act the same as the ones that work on lists. Because the names are the same, we're going to do a qualified import in a script and then load that script into GHCI to play with bytestrings. </p>
<pre name="code" class="haskell:hs">
import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString as S
</pre>
<p><code class="fixed">B</code> has lazy bytestring types and functions, whereas <code class="fixed">S</code> has strict ones. We'll mostly be using the lazy version.</p>
<p>The function <span class="function label">pack</span> has the type signature <code class="fixed">pack :: [Word8] -&gt; ByteString</code>. What that means is that it takes a list of bytes of type <code class="fixed">Word8</code> and returns a <code class="fixed">ByteString</code>. You can think of it as taking a list, which is lazy, and making it less lazy, so that it's lazy only at 64K intervals.</p>
<p>What's the deal with that <code class="fixed">Word8</code> type? Well, it's like <code class="fixed">Int</code>, only that it has a much smaller range, namely 0-255. It represents an 8-bit number. And just like <code class="fixed">Int</code>, it's in the <code class="fixed">Num</code> typeclass. For instance, we know that the value <code class="fixed">5</code> is polymorphic in that it can act like any numeral type. Well, it can also take the type of <code class="fixed">Word8</code>.</p>
<pre name="code" class="haskell:hs">
ghci&gt; B.pack [99,97,110]
Chunk "can" Empty
ghci&gt; B.pack [98..120]
Chunk "bcdefghijklmnopqrstuvwx" Empty
</pre>
<p>As you can see, you usually don't have to worry about the <code class="fixed">Word8</code> too much, because the type system can makes the numbers choose that type. If you try to use a big number, like <code class="fixed">336</code> as a <code class="fixed">Word8</code>, it will just wrap around to <code class="fixed">80</code>.</p>
<p>We packed only a handful of values into a <code class="fixed">ByteString</code>, so they fit inside one chunk. The <code class="fixed">Empty</code> is like the <code class="fixed">[]</code> for lists.</p>
<p><code class="label function">unpack</code> is the inverse function of <code class="fixed">pack</code>. It takes a bytestring and turns it into a list of bytes.</p> 
<p><code class="label function">fromChunks</code> takes a list of strict bytestrings and converts it to a lazy bytestring. <code class="label function">toChunks</code> takes a lazy bytestring and converts it to a list of strict ones.</p>
<pre name="code" class="haskell:hs">
ghci&gt; B.fromChunks [S.pack [40,41,42], S.pack [43,44,45], S.pack [46,47,48]]
Chunk "()*" (Chunk "+,-" (Chunk "./0" Empty))
</pre>
<p>This is good if you have a lot of small strict bytestrings and you want to process them efficiently without joining them into one big strict bytestring in memory first.</p>
<p>The bytestring version of <code class="fixed">:</code> is called <code class="label function">cons</code> It takes a byte and a bytestring and puts the byte at the beginning. It's lazy though, so it will make a new chunk even if the first chunk in the bytestring isn't full. That's why it's better to use the strict version of <code class="fixed">cons</code>, <code class="label function">cons'</code> if you're going to be inserting a lot of bytes at the beginning of a bytestring.</p>
<pre name="code" class="haskell:hs">
ghci&gt; B.cons 85 $ B.pack [80,81,82,84]
Chunk "U" (Chunk "PQRT" Empty)
ghci&gt; B.cons' 85 $ B.pack [80,81,82,84]
Chunk "UPQRT" Empty
ghci&gt; foldr B.cons B.empty [50..60]
Chunk "2" (Chunk "3" (Chunk "4" (Chunk "5" (Chunk "6" (Chunk "7" (Chunk "8" (Chunk "9" (Chunk ":" (Chunk ";" (Chunk "&lt;"
Empty))))))))))
ghci&gt; foldr B.cons' B.empty [50..60]
Chunk "23456789:;&lt;" Empty
</pre>
<p>As you can see <code class="label function">empty</code> makes an empty bytestring. See the difference between <code class="fixed">cons</code> and <code class="fixed">cons'</code>? With the <code class="fixed">foldr</code>, we started with an empty bytestring and then went over the list of numbers from the right, adding each number to the beginning of the bytestring. When we used <code class="fixed">cons</code>, we ended up with one chunk for every byte, which kind of defeats the purpose.</p>
<p>Otherwise, the bytestring modules have a load of functions that are analogous to those in <code class="fixed">Data.List</code>, including, but not limited to, <code class="fixed">head</code>, <code class="fixed">tail</code>, <code class="fixed">init</code>, <code class="fixed">null</code>, <code class="fixed">length</code>, <code class="fixed">map</code>, <code class="fixed">reverse</code>, <code class="fixed">foldl</code>, <code class="fixed">foldr</code>, <code class="fixed">concat</code>, <code class="fixed">takeWhile</code>, <code class="fixed">filter</code>, etc. </p>
<p>It also has functions that have the same name and behave the same as some functions found in <code class="fixed">System.IO</code>, only <code class="fixed">String</code>s are replaced with <code class="fixed">ByteString</code>s. For instance, the <code class="fixed">readFile</code> function in <code class="fixed">System.IO</code> has a type of <code class="fixed">readFile :: FilePath -&gt; IO String</code>, while the <code class="label function">readFile</code> from the bytestring modules has a type of <code class="fixed">readFile :: FilePath -&gt; IO ByteString</code>. Watch out, if you're using strict bytestrings and you attempt to read a file, it will read it into memory at once! With lazy bytestrings, it will read it into neat chunks.</p>
<p>Let's make a simple program that takes two filenames as command-line arguments and copies the first file into the second file. Note that <code class="fixed">System.Directory</code> already has a function called <code class="fixed">copyFile</code>, but we're going to implement our own file copying function and program anyway.</p>
<pre name="code" class="haskell:hs">
import System.Environment
import qualified Data.ByteString.Lazy as B

main = do
    (fileName1:fileName2:_) &lt;- getArgs
    copyFile fileName1 fileName2

copyFile :: FilePath -&gt; FilePath -&gt; IO ()
copyFile source dest = do
    contents &lt;- B.readFile source
    B.writeFile dest contents
</pre>
<p>We make our own function that takes two <code class="fixed">FilePath</code>s (remember, <code class="fixed">FilePath</code> is just a synonym for <code class="fixed">String</code>) and returns an I/O action that will copy one file into another using bytestring. In the <code class="fixed">main</code> function, we just get the arguments and call our function with them to get the I/O action, which is then performed.</p>
<pre name="code" class="plain">
$ runhaskell bytestringcopy.hs something.txt ../../something.txt
</pre>
<p>Notice that a program that doesn't use bytestrings could look just like this, the only difference is that we used <code class="fixed">B.readFile</code> and <code class="fixed">B.writeFile</code> instead of <code class="fixed">readFile</code> and <code class="fixed">writeFile</code>. Many times, you can convert a program that uses normal strings to a program that uses bytestrings by just doing the necessary imports and then putting the qualified module names in front of some functions. Sometimes, you have to convert functions that you wrote to work on strings so that they work on bytestrings, but that's not hard.</p>
<p>Whenever you need better performance in a program that reads a lot of data into strings, give bytestrings a try, chances are you'll get some good performance boosts with very little effort on your part. I usually write programs by using normal strings and then convert them to use bytestrings if the performance is not satisfactory.</p> 
<a name="exceptions"></a><h2>Exceptions</h2>
<img src="lyah/timber.png" class="left" alt="timberr!!!!" width="308" height="394">
<p>All languages have procedures, functions, and pieces of code that might fail in some way. That's just a fact of life. Different languages have different ways of handling those failures. In C, we usually use some abnormal return value (like <code class="fixed">-1</code> or a null pointer) to indicate that what a function returned shouldn't be treated like a normal value. Java and C#, on the other hand, tend to use exceptions to handle failure. When an exception is thrown, the control flow jumps to some code that we've defined that does some cleanup and then maybe re-throws the exception so that some other error handling code can take care of some other stuff.</p>
<p>Haskell has a very good type system. Algebraic data types allow for types like <code class="fixed">Maybe</code> and <code class="fixed">Either</code> and we can use values of those types to represent results that may be there or not. In C, returning, say, <code class="fixed">-1</code> on failure is completely a matter of convention. It only has special meaning to humans. If we're not careful, we might treat these abnormal values as ordinary ones and then they can cause havoc and dismay in our code. Haskell's type system gives us some much-needed safety in that aspect. A function <code class="fixed">a -&gt; Maybe b</code> clearly indicates that it it may produce a <code class="fixed">b</code> wrapped in <code class="fixed">Just</code> or that it may return <code class="fixed">Nothing</code>. The type is different from just plain <code class="fixed">a -&gt; b</code> and if we try to use those two functions interchangeably, the compiler will complain at us.</p>
<p>Despite having expressive types that support failed computations, Haskell still has support for exceptions, because they make more sense in I/O contexts. A lot of things can go wrong when dealing with the outside world because it is so unreliable. For instance, when opening a file, a bunch of things can go wrong. The file might be locked, it might not be there at all or the hard disk drive or something might not be there at all. So it's good to be able to jump to some error handling part of our code when such an error occurs.</p>
<p>Okay, so I/O code (i.e. impure code) can throw exceptions. It makes sense. But what about pure code? Well, it can throw exceptions too. Think about the <code class="fixed">div</code> and <code class="fixed">head</code> functions. They have types of <code class="fixed">(Integral a) =&gt; a -&gt; a -&gt; a</code> and <code class="fixed">[a] -&gt; a</code>, respectively. No <code class="fixed">Maybe</code> or <code class="fixed">Either</code> in their return type and yet they can both fail! <code class="fixed">div</code> explodes in your face if you try to divide by zero and <code class="fixed">head</code> throws a tantrum when you give it an empty list.</p>
<pre name="code" class="haskell:hs">
ghci&gt; 4 `div` 0
*** Exception: divide by zero
ghci&gt; head []
*** Exception: Prelude.head: empty list
</pre>
<img src="lyah/police.png" width="241" height="328" alt="Stop right there, criminal scum! Nobody breaks the law on my watch! Now pay your fine or it's off to jail." class="left">
<p>Pure code can throw exceptions, but it they can only be caught in the I/O part of our code (when we're inside a <i>do</i> block that goes into <code class="fixed">main</code>). That's because you don't know when (or if) anything will be evaluated in pure code, because it is lazy and doesn't have a well-defined order of execution, whereas I/O code does.</p>
<p>Earlier, we talked about how we should spend as little time as possible in the I/O part of our program. The logic of our program should reside mostly within our pure functions, because their results are dependant only on the parameters that the functions are called with. When dealing with pure functions, you only have to think about what a function returns, because it can't do anything else. This makes your life easier. Even though doing some logic in I/O is necessary (like opening files and the like), it should preferably be kept to a minimum. Pure functions are lazy by default, which means that we don't know when they will be evaluated and that it really shouldn't matter. However, once pure functions start throwing exceptions, it matters when they are evaluated. That's why we can only catch exceptions thrown from pure functions in the I/O part of our code. And that's bad, because we want to keep the I/O part as small as possible. However, if we don't catch them in the I/O part of our code, our program crashes. The solution? Don't mix exceptions and pure code. Take advantage of Haskell's powerful type system and use types like <code class="fixed">Either</code> and <code class="fixed">Maybe</code> to represent results that may have failed.</p>
<p>That's why we'll just be looking at how to use I/O exceptions for now. I/O exceptions are exceptions that are caused when something goes wrong while we are communicating with the outside world in an I/O action that's part of <code class="fixed">main</code>. For example, we can try opening a file and then it turns out that the file has been deleted or something. Take a look at this program that opens a file whose name is given to it as a command line argument and tells us how many lines the file has.</p>
<pre name="code" class="haskell:hs">
import System.Environment
import System.IO

main = do (fileName:_) &lt;- getArgs
          contents &lt;- readFile fileName
          putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"
</pre>
<p>A very simple program. We perform the <code class="fixed">getArgs</code> I/O action and bind the first string in the list that it yields to <code class="fixed">fileName</code>. Then we call the contents of the file with that name <code class="fixed">contents</code>. Lastly, we apply <code class="fixed">lines</code> to those contents to get a list of lines and then we get the length of that list and give it to <code class="fixed">show</code> to get a string representation of that number. It works as expected, but what happens when we give it the name of a file that doesn't exist?</p>
<pre name="code" class="plain">
$ runhaskell linecount.hs i_dont_exist.txt
linecount.hs: i_dont_exist.txt: openFile: does not exist (No such file or directory)
</pre>
<p>Aha, we get an error from GHC, telling us that the file does not exist. Our program crashes. What if we wanted to print out a nicer message if the file doesn't exist? One way to do that is to check if the file exists before trying to open it by using the <code class="label function">doesFileExist</code> function from <code class="fixed">System.Directory</code>.</p>
<pre name="code" class="haskell:hs">
import System.Environment
import System.IO
import System.Directory

main = do (fileName:_) &lt;- getArgs
          fileExists &lt;- doesFileExist fileName
          if fileExists
              then do contents &lt;- readFile fileName
                      putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"
              else do putStrLn "The file doesn't exist!"
</pre>
<p>We did <code class="fixed">fileExists &lt;- doesFileExist fileName</code> because <code class="fixed">doesFileExist</code> has a type of <code class="fixed">doesFileExist :: FilePath -&gt; IO Bool</code>, which means that it returns an I/O action that has as its result a boolean value which tells us if the file exists. We can't just use <code class="fixed">doesFileExist</code> in an <i>if</i> expression directly.</p>
<p>Another solution here would be to use exceptions. It's perfectly acceptable to use them in this context. A file not existing is an exception that arises from I/O, so catching it in I/O is fine and dandy.</p>
<p>To deal with this by using exceptions, we're going to take advantage of the <code class="label function">catch</code> function from <code class="fixed">System.IO.Error</code>. Its type is <code class="fixed">catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a</code>. It takes two parameters. The first one is an I/O action. For instance, it could be an I/O action that tries to open a file. The second one is the so-called handler. If the first I/O action passed to <code class="fixed">catch</code> throws an I/O exception, that exception gets passed to the handler, which then decides what to do. So the final result is an I/O action that will either act the same as the first parameter or it will do what the handler tells it if the first I/O action throws an exception.</p>
<img src="lyah/puppy.png" alt="non sequitor" class="right" width="334" height="240">
<p>If you're familiar with <i>try-catch</i> blocks in languages like Java or Python, the <code class="fixed">catch</code> function is similar to them. The first parameter is the thing to try, kind of like the stuff in the <i>try</i> block in other, imperative languages. The second parameter is the handler that takes an exception, just like most <i>catch</i> blocks take exceptions that you can then examine to see what happened. The handler is invoked if an exception is thrown.</p>
<p>The handler takes a value of type <code class="fixed">IOError</code>, which is a value that signifies that an I/O exception occurred. It also carries information regarding the type of the exception that was thrown. How this type is implemented depends on the implementation of the language itself, which means that we can't inspect values of the type <code class="fixed">IOError</code> by pattern matching against them, just like we can't pattern match against values of type <code class="fixed">IO <i>something</i></code>. We can use a bunch of useful predicates to find out stuff about values of type <code class="fixed">IOError</code> as we'll learn in a second.</p>
<p>So let's put our new friend <code class="fixed">catch</code> to use!</p>
<pre name="code" class="haskell:hs">
import System.Environment
import System.IO
import System.IO.Error

main = toTry `catch` handler
            
toTry :: IO ()
toTry = do (fileName:_) &lt;- getArgs
           contents &lt;- readFile fileName
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"

handler :: IOError -&gt; IO ()
handler e = putStrLn "Whoops, had some trouble!"
</pre>
<p>First of all, you'll see that put backticks around it so that we can use it as an infix function, because it takes two parameters. Using it as an infix function makes it more readable. So <code class="fixed">toTry `catch` handler</code> is the same as <code class="fixed">catch toTry handler</code>, which fits well with its type. <code class="fixed">toTry</code> is the I/O action that we try to carry out and <code class="fixed">handler</code> is the function that takes an <code class="fixed">IOError</code> and returns an action to be carried out in case of an exception.</p>
<p>Let's give this a go:</p>
<pre name="code" class="plain">
$ runhaskell count_lines.hs i_exist.txt
The file has 3 lines!

$ runhaskell count_lines.hs i_dont_exist.txt
Whoops, had some trouble!
</pre>
<p>In the handler, we didn't check to see what kind of <code class="fixed">IOError</code> we got. We just say <code class="fixed">"Whoops, had some trouble!"</code> for any kind of error. Just catching all types of exceptions in one handler is bad practice in Haskell just like it is in most other languages. What if some other exception happens that we don't want to catch, like us interrupting the program or something? That's why we're going to do the same thing that's usually done in other languages as well: we'll check to see what kind of exception we got. If it's the kind of exception we're waiting to catch, we do our stuff. If it's not, we throw that exception back into the wild. Let's modify our program to catch only the exceptions caused by a file not existing.</p>
<pre name="code" class="haskell:hs">
import System.Environment
import System.IO
import System.IO.Error

main = toTry `catch` handler
            
toTry :: IO ()
toTry = do (fileName:_) &lt;- getArgs
           contents &lt;- readFile fileName
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"

handler :: IOError -&gt; IO ()
handler e
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"
    | otherwise = ioError e
</pre>
<p>Everything stays the same except the handler, which we modified to only catch a certain group of I/O exceptions. Here we used two new functions from <code class="fixed">System.IO.Error</code> &mdash; <code class="label function">isDoesNotExistError</code> and <code class="label function">ioError</code>. <code class="fixed">isDoesNotExistError</code> is a predicate over <code class="fixed">IOError</code>s, which means that it's a function that takes an <code class="fixed">IOError</code> and returns a <code class="fixed">True</code> or <code class="fixed">False</code>, meaning it has a type of <code class="fixed">isDoesNotExistError :: IOError -&gt; Bool</code>. We use it on the exception that gets passed to our handler to see if it's an error caused by a file not existing. We use <a href="syntax-in-functions.html#guards-guards">guard</a> syntax here, but we could have also used an <i>if else</i>. If it's not caused by a file not existing, we re-throw the exception that was passed by the handler with the <code class="fixed">ioError</code> function. It has a type of <code class="fixed">ioError :: IOException -&gt; IO a</code>, so it takes an <code class="fixed">IOError</code> and produces an I/O action that will throw it. The I/O action has a type of <code class="fixed">IO a</code>, because it never actually yields a result, so it can act as <code class="fixed">IO <i>anything</i></code>.</p>
<p>So the exception thrown in the <code class="fixed">toTry</code> I/O action that we glued together with a <i>do</i> block isn't caused by a file existing, <code class="fixed">toTry `catch` handler</code> will catch that and then re-throw it. Pretty cool, huh?</p>
<p>There are several predicates that act on <code class="fixed">IOError</code> and if a guard doesn't evaluate to <code class="fixed">True</code>, evaluation falls through to the next guard. The predicates that act on <code class="fixed">IOError</code> are:</p>
<ul>
    <li><span class="function label">isAlreadyExistsError</span></li>
    <li><span class="function label">isDoesNotExistError</span></li>
    <li><span class="function label">isAlreadyInUseError</span></li>
    <li><span class="function label">isFullError</span></li>
    <li><span class="function label">isEOFError</span></li>
    <li><span class="function label">isIllegalOperation</span></li>
    <li><span class="function label">isPermissionError</span></li>
    <li><span class="function label">isUserError</span></li>
</ul>
<p>Most of these are pretty self-explanatory. <code class="fixed">isUserError</code> evaluates to <code class="fixed">True</code> when we use the function <code class="label function">userError</code> to make the exception, which is used for making exceptions from our code and equipping them with a string. For instance, you can do <code class="fixed">ioError $ userError "remote computer unplugged!"</code>, although It's prefered you use types like <code class="fixed">Either</code> and <code class="fixed">Maybe</code> to express possible failure instead of throwing exceptions yourself with <code class="fixed">userError</code>.</p>
<p>So you could have a handler that looks something like this:</p>
<pre name="code" class="haskell:hs">
handler :: IOError -&gt; IO ()
handler e
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"
    | isFullError e = freeSomeSpace
    | isIllegalOperation e = notifyCops
    | otherwise = ioError e
</pre>
<p>Where <code class="fixed">notifyCops</code> and <code class="fixed">freeSomeSpace</code> are some I/O actions that you define. Be sure to re-throw exceptions if they don't match any of your criteria, otherwise you're causing your program to fail silently in some cases where it shouldn't.</p>
<p><code class="fixed">System.IO.Error</code> also exports functions that enable us to ask our exceptions for some attributes, like what the handle of the file that caused the error is, or what the filename is. These start with <code class="fixed">ioe</code> and you can see a <a href="http://www.haskell.org/ghc/docs/6.10.1/html/libraries/base/System-IO-Error.html#3">full list of them</a> in the documentation. Say we want to print the filename that caused our error. We can't print the <code class="fixed">fileName</code> that we got from <code class="fixed">getArgs</code>, because only the <code class="fixed">IOError</code> is passed to the handler and the handler doesn't know about anything else. A function depends only on the parameters it was called with. That's why we can use the <code class="label function">ioeGetFileName</code> function, which has a type of <code class="fixed">ioeGetFileName :: IOError -&gt; Maybe FilePath</code>. It takes an <code class="fixed">IOError</code> as a parameter and maybe returns a <code class="fixed">FilePath</code> (which is just a type synonym for <code class="fixed">String</code>, remember, so it's kind of the same thing). Basically, what it does is it extracts the file path from the <code class="fixed">IOError</code>, if it can. Let's modify our program to print out the file path that's responsible for the exception occurring.
<pre name="code" class="haskell:hs">
import System.Environment   
import System.IO   
import System.IO.Error   
  
main = toTry `catch` handler   
               
toTry :: IO ()   
toTry = do (fileName:_) &lt;- getArgs   
           contents &lt;- readFile fileName   
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"   
  
handler :: IOError -&gt; IO ()   
handler e   
    | isDoesNotExistError e = 
        case ioeGetFileName e of Just path -&gt; putStrLn $ "Whoops! File does not exist at: " ++ path
                                 Nothing -&gt; putStrLn "Whoops! File does not exist at unknown location!"
    | otherwise = ioError e   
</pre>
<p>In the guard where <code class="fixed">isDoesNotExistError</code> is <code class="fixed">True</code>, we used a <i>case</i> expression to call <code class="fixed">ioeGetFileName</code> with <code class="fixed">e</code> and then pattern match against the <code class="fixed">Maybe</code> value that it returned. Using <i>case</i> expressions is commonly used when you want to pattern match against something without bringing in a new function.</p>
<p>You don't have to use one handler to <code class="fixed">catch</code> exceptions in your whole I/O part. You can just cover certain parts of your I/O code with <code class="fixed">catch</code> or you can cover several of them with <code class="fixed">catch</code> and use different handlers for them, like so:</p>
<pre name="code" class="haskell:hs">
main = do toTry `catch` handler1
          thenTryThis `catch` handler2
          launchRockets
</pre>
<p>Here, <code class="fixed">toTry</code> uses <code class="fixed">handler1</code> as the handler and <code class="fixed">thenTryThis</code> uses <code class="fixed">handler2</code>. <code class="fixed">launchRockets</code> isn't a parameter to <code class="fixed">catch</code>, so whichever exceptions it might throw will likely crash our program, unless <code class="fixed">launchRockets</code> uses <code class="fixed">catch</code> internally to handle its own exceptions. Of course <code class="fixed">toTry</code>, <code class="fixed">thenTryThis</code> and <code class="fixed">launchRockets</code> are I/O actions that have been glued together using <i>do</i> syntax and hypothetically defined somewhere else. This is kind of similar to <i>try-catch</i> blocks of other languages, where you can surround your whole program in a single <i>try-catch</i> or you can use a more fine-grained approach and use different ones in different parts of your code to control what kind of error handling happens where.</p>
<p>Now you know how to deal with I/O exceptions! Throwing exceptions from pure code and dealing with them hasn't been covered here, mainly because, like we said, Haskell offers much better ways to indicate errors than reverting to I/O to catch them. Even when glueing together I/O actions that might fail, I prefer to have their type be something like <code class="fixed">IO (Either a b)</code>, meaning that they're normal I/O actions but the result that they yield when performed is of type <code class="fixed">Either a b</code>, meaning it's either <code class="fixed">Left a</code> or <code class="fixed">Right b</code>.</p>
                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                                        <a href="making-our-own-types-and-typeclasses.html" class="prevlink">Making Our Own Types and Typeclasses</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters.html">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="functionally-solving-problems.html" class="nxtlink">Functionally Solving Problems</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="shBrushHaskell.js"></script>
    <script type="text/javascript" src="shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = 'sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script>
</body>

<!-- Mirrored from learnyouahaskell.com/input-and-output by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 19 Nov 2013 17:20:15 GMT -->
</html>
