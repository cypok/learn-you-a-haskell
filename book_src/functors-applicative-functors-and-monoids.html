<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!-- Mirrored from learnyouahaskell.com/functors-applicative-functors-and-monoids by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 19 Nov 2013 17:20:18 GMT -->
<head>
<title>Functors, Applicative Functors and Monoids - Learn You a Haskell for Great Good!</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<base >
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="favicon.png" type="image/png">
        <link rel="prev" href="functionally-solving-problems.html">
        <link rel="next" href="a-fistful-of-monads.html">
<link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
<link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
</head>
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                                        <a href="functionally-solving-problems.html" class="prevlink">Functionally Solving Problems</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters.html">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="a-fistful-of-monads.html" class="nxtlink">A Fistful of Monads</a>
                                            </li>
                </ul>
            </div>
        <h1>Functors, Applicative Functors and Monoids</h1>
<p>Haskell's combination of purity, higher order functions, parameterized algebraic data types, and typeclasses allows us to implement polymorphism on a much higher level than possible in other languages. We don't have to think about types belonging to a big hierarchy of types. Instead, we think about what the types can act like and then connect them with the appropriate typeclasses. An <code class="fixed">Int</code> can act like a lot of things. It can act like an equatable thing, like an ordered thing, like an enumerable thing, etc.</p>
<p>Typeclasses are open, which means that we can define our own data type, think about what it can act like and connect it with the typeclasses that define its behaviors. Because of that and because of Haskell's great type system that allows us to know a lot about a function just by knowing its type declaration, we can define typeclasses that define behavior that's very general and abstract. We've met typeclasses that define operations for seeing if two things are equal or comparing two things by some ordering. Those are very abstract and elegant behaviors, but we just don't think of them as anything very special because we've been dealing with them for most of our lives. We recently met functors, which are basically things that can be mapped over. That's an example of a useful and yet still pretty abstract property that typeclasses can describe. In this chapter, we'll take a closer look at functors, along with slightly stronger and more useful versions of functors called applicative functors. We'll also take a look at monoids, which are sort of like socks.</p>
<a name="functors-redux"></a><h2>Functors redux</h2>
<img src="lyah/frogtor.png" alt="frogs dont even need money" class="right" width="369" height="243">
<p>We've already talked about functors in <a href="making-our-own-types-and-typeclasses.html#the-functor-typeclass">their own little section</a>. If you haven't read it yet, you should probably give it a glance right now, or maybe later when you have more time. Or you can just pretend you read it.</p>
<p>Still, here's a quick refresher: Functors are things that can be mapped over, like lists, <code class="fixed">Maybe</code>s, trees, and such. In Haskell, they're described by the typeclass <code class="fixed">Functor</code>, which has only one typeclass method, namely <code class="fixed">fmap</code>, which has a type of <code class="fixed">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. It says: give me a function that takes an <code class="fixed">a</code> and returns a <code class="fixed">b</code> and a box with an <code class="fixed">a</code> (or several of them) inside it and I'll give you a box with a <code class="fixed">b</code> (or several of them) inside it. It kind of applies the function to the element inside the box.</p>
<div class="hintbox"><em>A word of advice.</em> Many times the box analogy is used to help you get some intuition for how functors work, and later, we'll probably use the same analogy for applicative functors and monads. It's an okay analogy that helps people understand functors at first, just don't take it too literally, because for some functors the box analogy has to be stretched really thin to still hold some truth. A more correct term for what a functor is would be <i>computational context</i>. The context might be that the computation can have a value or it might have failed (<code class="fixed">Maybe</code> and <code class="fixed">Either a</code>) or that there might be more values (lists), stuff like that.</div>
<p>If we want to make a type constructor an instance of <code class="fixed">Functor</code>, it has to have a kind of <code class="fixed">* -&gt; *</code>, which means that it has to take exactly one concrete type as a type parameter. For example, <code class="fixed">Maybe</code> can be made an instance because it takes one type parameter to produce a concrete type, like <code class="fixed">Maybe Int</code> or <code class="fixed">Maybe String</code>. If a type constructor takes two parameters, like <code class="fixed">Either</code>, we have to partially apply the type constructor until it only takes one type parameter. So we can't write <code class="fixed">instance Functor Either where</code>, but we can write <code class="fixed">instance Functor (Either a) where</code> and then if we imagine that <code class="fixed">fmap</code> is only for <code class="fixed">Either a</code>, it would have a type declaration of <code class="fixed">fmap :: (b -&gt; c) -&gt; Either a b -&gt; Either a c</code>. As you can see, the <code class="fixed">Either a</code> part is fixed, because <code class="fixed">Either a</code> takes only one type parameter, whereas just <code class="fixed">Either</code> takes two so <code class="fixed">fmap :: (b -&gt; c) -&gt; Either b -&gt; Either c</code> wouldn't really make sense.</p>
<p>We've learned by now how a lot of types (well, type constructors really) are instances of <code class="fixed">Functor</code>, like <code class="fixed">[]</code>, <code class="fixed">Maybe</code>, <code class="fixed">Either a</code> and a <code class="fixed">Tree</code> type that we made on our own. We saw how we can map functions over them for great good. In this section, we'll take a look at two more instances of functor, namely <code class="fixed">IO</code> and <code class="fixed">(-&gt;) r</code>.</p>
<p>If some value has a type of, say, <code class="fixed">IO String</code>, that means that it's an I/O action that, when performed, will go out into the real world and get some string for us, which it will yield as a result. We can use <code class="fixed">&lt;-</code> in <i>do</i> syntax to bind that result to a name. We mentioned that I/O actions are like boxes with little feet that go out and fetch some value from the outside world for us. We can inspect what they fetched, but after inspecting, we have to wrap the value back in <code class="fixed">IO</code>. By thinking about this box with little feet analogy, we can see how <code class="fixed">IO</code> acts like a functor.</p>
<p>
Let's see how <code class="fixed">IO</code> is an instance of <code class="fixed">Functor</code>. When we <code class="fixed">fmap</code> a function over an I/O action, we want to get back an I/O action that does the same thing, but has our function applied over its result value.</p>
<pre name="code" class="haskell:hs">
instance Functor IO where
    fmap f action = do
        result &lt;- action
        return (f result)
</pre>
<p>
The result of mapping something over an I/O action will be an I/O action, so right off the bat we use <i>do</i> syntax to glue two actions and make a new one. In the implementation for <code class="fixed">fmap</code>, we make a new I/O action that first performs the original I/O action and calls its result <code class="fixed">result</code>. Then, we do <code class="fixed">return (f result)</code>. <code class="fixed">return</code> is, as you know, a function that makes an I/O action that doesn't do anything but only presents something as its result. The action that a <i>do</i> block produces will always have the result value of its last action. That's why we use return to make an I/O action that doesn't really do anything, it just presents <code class="fixed">f result</code> as the result of the new I/O action.
</p><p>We can play around with it to gain some intuition. It's pretty simple really. Check out this piece of code:</p>
<pre name="code" class="haskell:hs">
main = do line &lt;- getLine 
          let line' = reverse line
          putStrLn $ "You said " ++ line' ++ " backwards!"
          putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"
</pre>
<p>The user is prompted for a line and we give it back to the user, only reversed. Here's how to rewrite this by using <code class="fixed">fmap</code>:</p>
<pre name="code" class="haskell:hs">
main = do line &lt;- fmap reverse getLine
          putStrLn $ "You said " ++ line ++ " backwards!"
          putStrLn $ "Yes, you really said" ++ line ++ " backwards!"
</pre>
<img src="lyah/alien.png" alt="w00ooOoooOO" class="left" width="262" height="212">
<p>Just like when we <code class="fixed">fmap</code> <code class="fixed">reverse</code> over <code class="fixed">Just "blah"</code> to get <code class="fixed">Just "halb"</code>, we can <code class="fixed">fmap</code> <code class="fixed">reverse</code> over <code class="fixed">getLine</code>. <code class="fixed">getLine</code> is an I/O action that has a type of <code class="fixed">IO String</code> and mapping <code class="fixed">reverse</code> over it gives us an I/O action that will go out into the real world and get a line and then apply <code class="fixed">reverse</code> to its result. Like we can apply a function to something that's inside a <code class="fixed">Maybe</code> box, we can apply a function to what's inside an <code class="fixed">IO</code> box, only it has to go out into the real world to get something. Then when we bind it to a name by using <code class="fixed">&lt;-</code>, the name will reflect the result that already has <code class="fixed">reverse</code> applied to it.</p>
<p>The I/O action <code class="fixed">fmap (++"!") getLine</code> behaves just like <code class="fixed">getLine</code>, only that its result always has <code class="fixed">"!"</code> appended to it!</p>
<p>If we look at what <code class="fixed">fmap</code>'s type would be if it were limited to <code class="fixed">IO</code>, it would be <code class="fixed">fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b</code>. <code class="fixed">fmap</code> takes a function and an I/O action and returns a new I/O action that's like the old one, except that the function is applied to its contained result.</p>
<p>If you ever find yourself binding the result of an I/O action to a name, only to apply a function to that and call that something else, consider using <code class="fixed">fmap</code>, because it looks prettier. If you want to apply multiple transformations to some data inside a functor, you can declare your own function at the top level, make a lambda function or ideally, use function composition:</p>
<pre name="code" class="haskell:hs">
import Data.Char
import Data.List

main = do line &lt;- fmap (intersperse '-' . reverse . map toUpper) getLine
          putStrLn line
</pre>
<pre name="code" class="plain">
$ runhaskell fmapping_io.hs
hello there
E-R-E-H-T- -O-L-L-E-H
</pre>
<p>As you probably know, <code class="fixed">intersperse '-' . reverse . map toUpper</code> is a function that takes a string, maps <code class="fixed">toUpper</code> over it, the applies <code class="fixed">reverse</code> to that result and then applies <code class="fixed">intersperse '-'</code> to that result. It's like writing <code class="fixed">(\xs -&gt; intersperse '-' (reverse (map toUpper xs)))</code>, only prettier.</p>
<p>Another instance of <code class="fixed">Functor</code> that we've been dealing with all along but didn't know was a <code class="fixed">Functor</code> is <code class="fixed">(-&gt;) r</code>. You're probably slightly confused now, since what the heck does <code class="fixed">(-&gt;) r</code> mean? The function type <code class="fixed">r -&gt; a</code> can be rewritten as <code class="fixed">(-&gt;) r a</code>, much like we can write <code class="fixed">2 + 3</code> as <code class="fixed">(+) 2 3</code>. When we look at it as <code class="fixed">(-&gt;) r a</code>, we can see  <code class="fixed">(-&gt;)</code> in a slighty different light, because we see that it's just a type constructor that takes two type parameters, just like <code class="fixed">Either</code>. But remember, we said that a type constructor has to take exactly one type parameter so that it can be made an instance of <code class="fixed">Functor</code>. That's why we can't make <code class="fixed">(-&gt;)</code> an instance of <code class="fixed">Functor</code>, but if we partially apply it to <code class="fixed">(-&gt;) r</code>, it doesn't pose any problems. If the syntax allowed for type constructors to be partially applied with sections (like we can partially apply <code class="fixed">+</code> by doing <code class="fixed">(2+)</code>, which is the same as <code class="fixed">(+) 2</code>), you could write <code class="fixed">(-&gt;) r</code> as <code class="fixed">(r -&gt;)</code>. How are functions functors? Well, let's take a look at the implementation, which lies in <code class="fixed">Control.Monad.Instances</code></p>
<div class="hintbox">We usually mark functions that take anything and return anything as <code class="fixed">a -&gt; b</code>. <code class="fixed">r -&gt; a</code> is the same thing, we just used different letters for the type variables.</div>
<pre name="code" class="haskell:hs">
instance Functor ((-&gt;) r) where
    fmap f g = (\x -&gt; f (g x))
</pre>
<p>If the syntax allowed for it, it could have been written as</p>
<pre name="code" class="haskell:hs">
instance Functor (r -&gt;) where
    fmap f g = (\x -&gt; f (g x))
</pre>
<p>But it doesn't, so we have to write it in the former fashion.</p>
<p>First of all, let's think about <code class="fixed">fmap</code>'s type. It's <code class="fixed">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. Now what we'll do is mentally replace all the <code class="fixed">f</code>'s, which are the role that our functor instance plays, with <code class="fixed">(-&gt;) r</code>'s. We'll do that to see how <code class="fixed">fmap</code> should behave for this particular instance. We get <code class="fixed">fmap :: (a -&gt; b) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b)</code>. Now what we can do is write the <code class="fixed">(-&gt;) r a</code> and <code class="fixed">(-&gt; r b)</code> types as infix <code class="fixed">r -&gt; a</code> and <code class="fixed">r -&gt; b</code>, like we normally do with functions. What we get now is <code class="fixed">fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code>.</p>
<p>Hmmm OK. Mapping one function over a function has to produce a function, just like mapping a function over a <code class="fixed">Maybe</code> has to produce a <code class="fixed">Maybe</code> and mapping a function over a list has to produce a list. What does the type <code class="fixed">fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code> for this instance tell us? Well, we see that it takes a function from <code class="fixed">a</code> to <code class="fixed">b</code> and a function from <code class="fixed">r</code> to <code class="fixed">a</code> and returns a function from <code class="fixed">r</code> to <code class="fixed">b</code>. Does this remind you of anything? Yes! Function composition! We pipe the output of <code class="fixed">r -&gt; a</code> into the input of <code class="fixed">a -&gt; b</code> to get a function <code class="fixed">r -&gt; b</code>, which is exactly what function composition is about. If you look at how the instance is defined above, you'll see that it's just function composition. Another way to write this instance would be:</p>
<pre name="code" class="haskell:hs">
instance Functor ((-&gt;) r) where
    fmap = (.)
</pre>
<p>This makes the revelation that using <code class="fixed">fmap</code> over functions is just composition sort of obvious. Do <code class="fixed">:m + Control.Monad.Instances</code>, since that's where the instance is defined and then try playing with mapping over functions.</p>
<pre name="code" class="haskell:hs">
ghci&gt; :t fmap (*3) (+100)
fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a
ghci&gt; fmap (*3) (+100) 1
303
ghci&gt; (*3) `fmap` (+100) $ 1
303
ghci&gt; (*3) . (+100) $ 1
303
ghci&gt; fmap (show . (*3)) (*100) 1
"300"
</pre>
<p>We can call <code class="fixed">fmap</code> as an infix function so that the resemblance to <code class="fixed">.</code> is clear. In the second input line, we're mapping <code class="fixed">(*3)</code> over <code class="fixed">(+100)</code>, which results in a function that will take an input, call <code class="fixed">(+100)</code> on that and then call <code class="fixed">(*3)</code> on that result. We call that function with <code class="fixed">1</code>.</p>
<p>How does the box analogy hold here? Well, if you stretch it, it holds. When we use <code class="fixed">fmap (+3)</code> over <code class="fixed">Just 3</code>, it's easy to imagine the <code class="fixed">Maybe</code> as a box that has some contents on which we apply the function <code class="fixed">(+3)</code>. But what about when we're doing <code class="fixed">fmap (*3) (+100)</code>? Well, you can think of the function <code class="fixed">(+100)</code> as a box that contains its eventual result. Sort of like how an I/O action can be thought of as a box that will go out into the real world and fetch some result. Using <code class="fixed">fmap (*3)</code> on <code class="fixed">(+100)</code> will create another function that acts like <code class="fixed">(+100)</code>, only before producing a result, <code class="fixed">(*3)</code> will be applied to that result. Now we can see how <code class="fixed">fmap</code> acts just like <code class="fixed">.</code> for functions.</p>
<p>The fact that <code class="fixed">fmap</code> is function composition when used on functions isn't so terribly useful right now, but at least it's very interesting. It also bends our minds a bit and let us see how things that act more like computations than boxes (<code class="fixed">IO</code> and <code class="fixed">(-&gt;) r</code>) can be functors. The function being mapped over a computation results in the same computation but the result of that computation is modified with the function.</p>
<img src="lyah/lifter.png" alt="lifting a function is easier than lifting a million pounds" class="right" width="443" height="450">
<p>Before we go on to the rules that <code class="fixed">fmap</code> should follow, let's think about the type of <code class="fixed">fmap</code> once more. Its type is <code class="fixed">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. We're missing the class constraint <code class="fixed">(Functor f) =&gt;</code>, but we left it out here for brevity, because we're talking about functors anyway so we know what the <code class="fixed">f</code> stands for. When we first learned about <a href="higher-order-functions.html#curried-functions">curried functions</a>, we said that all Haskell functions actually take one parameter. A function <code class="fixed">a -&gt; b -&gt; c</code> actually takes just one parameter of type <code class="fixed">a</code> and then returns a function <code class="fixed">b -&gt; c</code>, which takes one parameter and returns a <code class="fixed">c</code>. That's how if we call a function with too few parameters (i.e. partially apply it), we get back a function that takes the number of parameters that we left out (if we're thinking about functions as taking several parameters again). So <code class="fixed">a -&gt; b -&gt; c</code> can be written as <code class="fixed">a -&gt; (b -&gt; c)</code>, to make the currying more apparent.</p>
<p>In the same vein, if we write <code class="fixed">fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code>, we can think of <code class="fixed">fmap</code> not as a function that takes one function and a functor and returns a functor, but as a function that takes a function and returns a new function that's just like the old one, only it takes a functor as a parameter and returns a functor as the result. It takes an <code class="fixed">a -&gt; b</code> function and returns a function <code class="fixed">f a -&gt; f b</code>. This is called <i>lifting</i> a function. Let's play around with that idea by using GHCI's <code class="fixed">:t</code> command:</p>
<pre name="code" class="haskell:hs">
ghci&gt; :t fmap (*2)
fmap (*2) :: (Num a, Functor f) =&gt; f a -&gt; f a
ghci&gt; :t fmap (replicate 3)
fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f [a]
</pre>
<p>The expression <code class="fixed">fmap (*2)</code> is a function that takes a functor <code class="fixed">f</code> over numbers and returns a functor over numbers. That functor can be a list, a <code class="fixed">Maybe </code>, an <code class="fixed">Either String</code>, whatever. The expression <code class="fixed">fmap (replicate 3)</code> will take a functor over any type and return a functor over a list of elements of that type.</p>
<div class="hintbox">When we say <i>a functor over numbers</i>, you can think of that as <i>a functor that has numbers in it</i>. The former is a bit fancier and more technically correct, but the latter is usually easier to get.</div>
<p>This is even more apparent if we partially apply, say, <code class="fixed">fmap (++"!")</code> and then bind it to a name in GHCI.</p>
<p>You can think of <code class="fixed">fmap</code> as either a function that takes a function and a functor and then maps that function over the functor, or you can think of it as a function that takes a function and lifts that function so that it operates on functors. Both views are correct and in Haskell, equivalent.</p>
<p>The type <code class="fixed">fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f [a]</code> means that the function will work on any functor. What exactly it will do depends on which functor we use it on. If we use <code class="fixed">fmap (replicate 3)</code> on a list, the list's implementation for <code class="fixed">fmap</code> will be chosen, which is just <code class="fixed">map</code>. If we use it on a <code class="fixed">Maybe a</code>, it'll apply <code class="fixed">replicate 3</code> to the value inside the <code class="fixed">Just</code>, or if it's <code class="fixed">Nothing</code>, then it stays <code class="fixed">Nothing</code>.</p>
<pre name="code" class="haskell:hs">
ghci&gt; fmap (replicate 3) [1,2,3,4]
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
ghci&gt; fmap (replicate 3) (Just 4)
Just [4,4,4]
ghci&gt; fmap (replicate 3) (Right "blah")
Right ["blah","blah","blah"]
ghci&gt; fmap (replicate 3) Nothing
Nothing
ghci&gt; fmap (replicate 3) (Left "foo")
Left "foo"
</pre>
<p>Next up, we're going to look at the <em>functor laws</em>. In order for something to be a functor, it should satisfy some laws. All functors are expected to exhibit certain kinds of functor-like properties and behaviors. They should reliably behave as things that can be mapped over. Calling <code class="fixed">fmap</code> on a functor should just map a function over the functor, nothing more. This behavior is described in the functor laws. There are two of them that all instances of <code class="fixed">Functor</code> should abide by. They aren't enforced by Haskell automatically, so you have to test them out yourself.</p>
<p><em>The first functor law states that if we map the <code class="fixed">id</code> function over a functor, the functor that we get back should be the same as the original functor.</em> If we write that a bit more formally, it means that <code class="label law">fmap id = id</code>. So essentially, this says that if we do <code class="fixed">fmap id</code> over a functor, it should be the same as just calling <code class="fixed">id</code> on the functor. Remember, <code class="fixed">id</code> is the identity function, which just returns its parameter unmodified. It can also be written as <code class="fixed">\x -&gt; x</code>. If we view the functor as something that can be mapped over, the <code class="label law">fmap id = id</code> law seems kind of trivial or obvious.</p>
<p>Let's see if this law holds for a few values of functors.</p>
<pre name="code" class="haskell:hs">
ghci&gt; fmap id (Just 3)
Just 3
ghci&gt; id (Just 3)
Just 3
ghci&gt; fmap id [1..5]
[1,2,3,4,5]
ghci&gt; id [1..5]
[1,2,3,4,5]
ghci&gt; fmap id []
[]
ghci&gt; fmap id Nothing
Nothing
</pre>
<p>If we look at the implementation of <code class="fixed">fmap</code> for, say, <code class="fixed">Maybe</code>, we can figure out why the first functor law holds.</p>
<pre name="code" class="haskell:hs">
instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
</pre>
<p>We imagine that <code class="fixed">id</code> plays the role of the <code class="fixed">f</code> parameter in the implementation. We see that if wee <code class="fixed">fmap id</code> over <code class="fixed">Just x</code>, the result will be <code class="fixed">Just (id x)</code>, and because <code class="fixed">id</code> just returns its parameter, we can deduce that <code class="fixed">Just (id x)</code> equals <code class="fixed">Just x</code>. So now we know that if we map <code class="fixed">id</code> over a <code class="fixed">Maybe</code> value with a <code class="fixed">Just</code> value constructor, we get that same value back.</p>
<p>Seeing that mapping <code class="fixed">id</code> over a <code class="fixed">Nothing</code> value returns the same value is trivial. So from these two equations in the implementation for <code class="fixed">fmap</code>, we see that the law <code class="fixed">fmap id = id</code> holds.</p>
<img src="lyah/justice.png" alt="justice is blind, but so is my dog" class="left" width="345" height="428">
<p><em>The second law says that composing two functions and then mapping the resulting function over a functor should be the same as first mapping one function over the functor and then mapping the other one.</em> Formally written, that means that <code class="label law">fmap (f . g) = fmap f . fmap g</code>. Or to write it in another way, for any functor <i>F</i>, the following should hold: <code class="label law">fmap (f . g) F = fmap f (fmap g F)</code>.</p>
<p>If we can show that some type obeys both functor laws, we can rely on it having the same fundamental behaviors as other functors when it comes to mapping. We can know that when we use <code class="fixed">fmap</code> on it, there won't be anything other than mapping going on behind the scenes and that it will act like a thing that can be mapped over, i.e. a functor. You figure out how the second law holds for some type by looking at the implementation of <code class="fixed">fmap</code> for that type and then using the method that we used to check if <code class="fixed">Maybe</code> obeys the first law.</p>
<p>If you want, we can check out how the second functor law holds for <code class="fixed">Maybe</code>. If we do <code class="fixed">fmap (f . g)</code> over <code class="fixed">Nothing</code>, we get <code class="fixed">Nothing</code>, because doing a <code class="fixed">fmap</code> with any function over <code class="fixed">Nothing</code> returns <code class="fixed">Nothing</code>. If we do <code class="fixed">fmap f (fmap g Nothing)</code>, we get <code class="fixed">Nothing</code>, for the same reason. OK, seeing how the second law holds for <code class="fixed">Maybe</code> if it's a <code class="fixed">Nothing</code> value is pretty easy, almost trivial. </p><p>How about if it's a <code class="fixed">Just <i>something</i></code> value? Well, if we do <code class="fixed">fmap (f . g) (Just x)</code>, we see from the implementation that it's implemented as <code class="fixed">Just ((f . g) x)</code>, which is, of course, <code class="fixed">Just (f (g x))</code>. If we do <code class="fixed">fmap f (fmap g (Just x))</code>, we see from the implementation that <code class="fixed">fmap g (Just x)</code> is <code class="fixed">Just (g x)</code>. Ergo, <code class="fixed">fmap f (fmap g (Just x))</code> equals <code class="fixed">fmap f (Just (g x))</code> and from the implementation we see that this equals <code class="fixed">Just (f (g x))</code>.</p>
<p>If you're a bit confused by this proof, don't worry. Be sure that you understand how <a href="higher-order-functions.html#composition">function composition</a> works. Many times, you can intuitively see how these laws hold because the types act like containers or functions. You can also just try them on a bunch of different values of a type and be able to say with some certainty that a type does indeed obey the laws.</p>
<p>Let's take a look at a pathological example of a type constructor being an instance of the <code class="fixed">Functor</code> typeclass but not really being a functor, because it doesn't satisfy the laws. Let's say that we have a type:</p>
<pre name="code" class="haskell:hs">
data CMaybe a = CNothing | CJust Int a deriving (Show)
</pre>
<p>The C here stands for <i>counter</i>. It's a data type that looks much like <code class="fixed">Maybe a</code>, only the <code class="fixed">Just</code> part holds two fields instead of one. The first field in the <code class="fixed">CJust</code> value constructor will always have a type of <code class="fixed">Int</code>, and it will be some sort of counter and the second field is of type <code class="fixed">a</code>, which comes from the type parameter and its type will, of course, depend on the concrete type that we choose for <code class="fixed">CMaybe a</code>. Let's play with our new type to get some intuition for it.</p>
<pre name="code" class="haskell:hs">
ghci&gt; CNothing
CNothing
ghci&gt; CJust 0 "haha"
CJust 0 "haha"
ghci&gt; :t CNothing
CNothing :: CMaybe a
ghci&gt; :t CJust 0 "haha"
CJust 0 "haha" :: CMaybe [Char]
ghci&gt; CJust 100 [1,2,3]
CJust 100 [1,2,3]
</pre>
<p>If we use the <code class="fixed">CNothing</code> constructor, there are no fields, and if we use the <code class="fixed">CJust</code> constructor, the first field is an integer and the second field can be any type. Let's make this an instance of <code class="fixed">Functor</code> so that everytime we use <code class="fixed">fmap</code>, the function gets applied to the second field, whereas the first field gets increased by 1.</p>
<pre name="code" class="haskell:hs">
instance Functor CMaybe where
    fmap f CNothing = CNothing
    fmap f (CJust counter x) = CJust (counter+1) (f x)
</pre>
<p>This is kind of like the instance implementation for <code class="fixed">Maybe</code>, except that when we do <code class="fixed">fmap</code> over a value that doesn't represent an empty box (a <code class="fixed">CJust</code> value), we don't just apply the function to the contents, we also increase the counter by 1. Everything seems cool so far, we can even play with this a bit:</p>
<pre name="code" class="haskell:hs">
ghci&gt; fmap (++"ha") (CJust 0 "ho")
CJust 1 "hoha"
ghci&gt; fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))
CJust 2 "hohahe"
ghci&gt; fmap (++"blah") CNothing
CNothing
</pre>
<p>Does this obey the functor laws? In order to see that something doesn't obey a law, it's enough to find just one counter-example.</p>
<pre name="code" class="haskell:hs">
ghci&gt; fmap id (CJust 0 "haha")
CJust 1 "haha"
ghci&gt; id (CJust 0 "haha")
CJust 0 "haha"
</pre>
<p>Ah! We know that the first functor law states that if we map <code class="fixed">id</code> over a functor, it should be the same as just calling <code class="fixed">id</code> with the same functor, but as we've seen from this example, this is not true for our <code class="fixed">CMaybe</code> functor. Even though it's part of the <code class="fixed">Functor</code> typeclass, it doesn't obey the functor laws and is therefore not a functor. If someone used our <code class="fixed">CMaybe</code> type as a functor, they would expect it to obey the functor laws like a good functor. But <code class="fixed">CMaybe</code> fails at being a functor even though it pretends to be one, so using it as a functor might lead to some faulty code. When we use a functor, it shouldn't matter if we first compose a few functions and then map them over the functor or if we just map each function over a functor in succession. But with <code class="fixed">CMaybe</code>, it matters, because it keeps track of how many times it's been mapped over. Not cool! If we wanted <code class="fixed">CMaybe</code> to obey the functor laws, we'd have to make it so that the <code class="fixed">Int</code> field stays the same when we use <code class="fixed">fmap</code>.</p>
<p>At first, the functor laws might seem a bit confusing and unnecessary, but then we see that if we know that a type obeys both laws, we can make certain assumptions about how it will act. If a type obeys the functor laws, we know that calling <code class="fixed">fmap</code> on a value of that type will only map the function over it, nothing more. This leads to code that is more abstract and extensible, because we can use laws to reason about behaviors that any functor should have and make functions that operate reliably on any functor.</p>
<p>All the <code class="fixed">Functor</code> instances in the standard library obey these laws, but you can check for yourself if you don't believe me. And the next time you make a type an instance of <code class="fixed">Functor</code>, take a minute to make sure that it obeys the functor laws. Once you've dealt with enough functors, you kind of intuitively see the properties and behaviors that they have in common and it's not hard to intuitively see if a type obeys the functor laws. But even without the intuition, you can always just go over the implementation line by line and see if the laws hold or try to find a counter-example.</p>
<p>We can also look at functors as things that output values in a context. For instance, <code class="fixed">Just 3</code> outputs the value <code class="fixed">3</code> in the context that it might or not output any values at all. <code class="fixed">[1,2,3]</code> outputs three values&mdash;<code class="fixed">1</code>, <code class="fixed">2</code>, and <code class="fixed">3</code>, the context is that there may be multiple values or no values. The function <code class="fixed">(+3)</code> will output a value, depending on which parameter it is given.</p>
<p>If you think of functors as things that output values, you can think of mapping over functors as attaching a transformation to the output of the functor that changes the value. When we do <code class="fixed">fmap (+3) [1,2,3]</code>, we attach the transformation <code class="fixed">(+3)</code> to the output of <code class="fixed">[1,2,3]</code>, so whenever we look at a number that the list outputs, <code class="fixed">(+3)</code> will be applied to it. Another example is mapping over functions. When we do <code class="fixed">fmap (+3) (*3)</code>, we attach the transformation <code class="fixed">(+3)</code> to the eventual output of <code class="fixed">(*3)</code>. Looking at it this way gives us some intuition as to why using <code class="fixed">fmap</code> on functions is just composition (<code class="fixed">fmap (+3) (*3)</code> equals <code class="fixed">(+3) . (*3)</code>, which equals <code class="fixed">\x -&gt; ((x*3)+3)</code>), because we take a function like <code class="fixed">(*3)</code> then we attach the transformation <code class="fixed">(+3)</code> to its output. The result is still a function, only when we give it a number, it will be multiplied by three and then it will go through the attached transformation where it will be added to three. This is what happens with composition.</p>
<a name="applicative-functors"></a><h2>Applicative functors</h2>
<img src="lyah/present.png" class="right" width="302" height="284" alt="disregard this analogy">
<p>In this section, we'll take a look at applicative functors, which are beefed up functors, represented in Haskell by the <code class="fixed">Applicative</code> typeclass, found in the <code class="fixed">Control.Applicative</code> module.</p>
<p>As you know, functions in Haskell are curried by default, which means that a function that seems to take several parameters actually takes just one parameter and returns a function that takes the next parameter and so on. If a function is of type <code class="fixed">a -&gt; b -&gt; c</code>, we usually say that it takes two parameters and returns a <code class="fixed">c</code>, but actually it takes an <code class="fixed">a</code> and returns a function <code class="fixed">b -&gt; c</code>. That's why we can call a function as <code class="fixed">f x y</code> or as <code class="fixed">(f x) y</code>. This mechanism is what enables us to partially apply functions by just calling them with too few parameters, which results in functions that we can then pass on to other functions.</p>
<p>So far, when we were mapping functions over functors, we usually mapped functions that take only one parameter. But what happens when we map a function like <code class="fixed">*</code>, which takes two parameters, over a functor? Let's take a look at a couple of concrete examples of this. If we have <code class="fixed">Just 3</code> and we do <code class="fixed">fmap (*) (Just 3)</code>, what do we get? From the instance implementation of <code class="fixed">Maybe</code> for <code class="fixed">Functor</code>, we know that if it's a <code class="fixed">Just <i>something</i></code> value, it will apply the function to the <code class="fixed"><i>something</i></code> inside the <code class="fixed">Just</code>. Therefore, doing <code class="fixed">fmap (*) (Just 3)</code> results in <code class="fixed">Just ((*) 3)</code>, which can also be written as <code class="fixed">Just (* 3)</code> if we use sections. Interesting! We get a function wrapped in a <code class="fixed">Just</code>!</p> 
<pre name="code" class="haskell:hs">
ghci&gt; :t fmap (++) (Just "hey")
fmap (++) (Just "hey") :: Maybe ([Char] -&gt; [Char])
ghci&gt; :t fmap compare (Just 'a')
fmap compare (Just 'a') :: Maybe (Char -&gt; Ordering)
ghci&gt; :t fmap compare "A LIST OF CHARS"
fmap compare "A LIST OF CHARS" :: [Char -&gt; Ordering]
ghci&gt; :t fmap (\x y z -&gt; x + y / z) [3,4,5,6]
fmap (\x y z -&gt; x + y / z) [3,4,5,6] :: (Fractional a) =&gt; [a -&gt; a -&gt; a]
</pre>
<p>If we map <code class="fixed">compare</code>, which has a type of <code class="fixed">(Ord a) =&gt; a -&gt; a -&gt; Ordering</code> over a list of characters, we get a list of functions of type <code class="fixed">Char -&gt; Ordering</code>, because the function <code class="fixed">compare</code> gets partially applied with the characters in the list. It's not a list of <code class="fixed">(Ord a) =&gt; a -&gt; Ordering</code> function, because the first <code class="fixed">a</code> that got applied was a <code class="fixed">Char</code> and so the second <code class="fixed">a</code> has to decide to be of type <code class="fixed">Char</code>.</p>
<p>We see how by mapping "multi-parameter" functions over functors, we get functors that contain functions inside them. So now what can we do with them? Well for one, we can map functions that take these functions as parameters over them, because whatever is inside a functor will be given to the function that we're mapping over it as a parameter.</p>
<pre name="code" class="haskell:hs">
ghci&gt; let a = fmap (*) [1,2,3,4]
ghci&gt; :t a
a :: [Integer -&gt; Integer]
ghci&gt; fmap (\f -&gt; f 9) a
[9,18,27,36]
</pre>
<p>But what if we have a functor value of <code class="fixed">Just (3 *)</code> and a functor value of <code class="fixed">Just 5</code> and we want to take out the function from <code class="fixed">Just (3 *)</code> and map it over <code class="fixed">Just 5</code>? With normal functors, we're out of luck, because all they support is just mapping normal functions over existing functors. Even when we mapped <code class="fixed">\f -&gt; f 9</code> over a functor that contained functions inside it, we were just mapping a normal function over it. But we can't map a function that's inside a functor over another functor with what <code class="fixed">fmap</code> offers us. We could pattern-match against the <code class="fixed">Just</code> constructor to get the function out of it and then map it over <code class="fixed">Just 5</code>, but we're looking for a more general and abstract way of doing that, which works across functors.</p>
<p>Meet the <code class="fixed">Applicative</code> typeclass. It lies in the <code class="fixed">Control.Applicative</code> module and it defines two methods, <code class="fixed">pure</code> and <code class="fixed">&lt;*&gt;</code>. It doesn't provide a default implementation for any of them, so we have to define them both if we want something to be an applicative functor. The class is defined like so:</p>
<pre name="code" class="haskell:hs">
class (Functor f) =&gt; Applicative f where
    pure :: a -&gt; f a
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</pre>
<p>This simple three line class definition tells us a lot! Let's start at the first line. It starts the definition of the <code class="fixed">Applicative</code> class and it also introduces a class constraint. It says that if we want to make a type constructor part of the <code class="fixed">Applicative</code> typeclass, it has to be in <code class="fixed">Functor</code> first. That's why if we know that if a type constructor is part of the <code class="fixed">Applicative</code> typeclass, it's also in <code class="fixed">Functor</code>, so we can use <code class="fixed">fmap</code> on it.</p>
<p>The first method it defines is called <code class="fixed">pure</code>. Its type declaration is <code class="fixed">pure :: a -&gt; f a</code>. <code class="fixed">f</code> plays the role of our applicative functor instance here. Because Haskell has a very good type system and because everything a function can do is take some parameters and return some value, we can tell a lot from a type declaration and this is no exception. <code class="fixed">pure</code> should take a value of any type and return an applicative functor with that value inside it. When we say <i>inside it</i>, we're using the box analogy again, even though we've seen that it doesn't always stand up to scrutiny. But the <code class="fixed">a -&gt; f a</code> type declaration is still pretty descriptive. We take a value and we wrap it in an applicative functor that has that value as the result inside it.</p>
<p>A better way of thinking about <code class="fixed">pure</code> would be to say that it takes a value and puts it in some sort of default (or pure) context&mdash;a minimal context that still yields that value.</p>
<p>The <code class="fixed">&lt;*&gt;</code> function is really interesting. It has a type declaration of <code class="fixed">f (a -&gt; b) -&gt; f a -&gt; f b</code>. Does this remind you of anything? Of course, <code class="fixed">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. It's a sort of a beefed up <code class="fixed">fmap</code>. Whereas <code class="fixed">fmap</code> takes a function and a functor and applies the function inside the functor, <code class="fixed">&lt;*&gt;</code> takes a functor that has a function in it and another functor and sort of extracts that function from the first functor and then maps it over the second one. When I say <i>extract</i>, I actually sort of mean <i>run</i> and then extract, maybe even <i>sequence</i>. We'll see why soon. 
<p>Let's take a look at the <code class="fixed">Applicative</code> instance implementation for <code class="fixed">Maybe</code>.</p>
<pre name="code" class="haskell:hs">
instance Applicative Maybe where
    pure = Just
    Nothing &lt;*&gt; _ = Nothing
    (Just f) &lt;*&gt; something = fmap f something
</pre>
<p>Again, from the class definition we see that the <code class="fixed">f</code> that plays the role of the applicative functor should take one concrete type as a parameter, so we write <code class="fixed">instance Applicative Maybe where</code> instead of writing <code class="fixed">instance Applicative (Maybe a) where</code>.</p>
<p>First off, <code class="fixed">pure</code>. We said earlier that it's supposed to take something and wrap it in an applicative functor. We wrote <code class="fixed">pure = Just</code>, because value constructors like <code class="fixed">Just</code> are normal functions. We could have also written <code class="fixed">pure x = Just x</code>.</p>
<p>Next up, we have the definition for <code class="fixed">&lt;*&gt;</code>. We can't extract a function out of a <code class="fixed">Nothing</code>, because it has no function inside it. So we say that if we try to extract a function from a <code class="fixed">Nothing</code>, the result is a <code class="fixed">Nothing</code>. If you look at the class definition for <code class="fixed">Applicative</code>, you'll see that there's a <code class="fixed">Functor</code> class constraint, which means that we can assume that both of <code class="fixed">&lt;*&gt;</code>'s parameters are functors. If the first parameter is not a <code class="fixed">Nothing</code>, but a <code class="fixed">Just</code> with some function inside it, we say that we then want to map that function over the second parameter. This also takes care of the case where the second parameter is <code class="fixed">Nothing</code>, because doing <code class="fixed">fmap</code> with any function over a <code class="fixed">Nothing</code> will return a <code class="fixed">Nothing</code>.</p>
<p>So for <code class="fixed">Maybe</code>, <code class="fixed">&lt;*&gt;</code> extracts the function from the left value if it's a <code class="fixed">Just</code> and maps it over the right value. If any of the parameters is <code class="fixed">Nothing</code>, <code class="fixed">Nothing</code> is the result.</p>
<p>OK cool great. Let's give this a whirl.</p>
<pre name="code" class="haskell:hs">
ghci&gt; Just (+3) &lt;*&gt; Just 9
Just 12
ghci&gt; pure (+3) &lt;*&gt; Just 10
Just 13
ghci&gt; pure (+3) &lt;*&gt; Just 9
Just 12
ghci&gt; Just (++"hahah") &lt;*&gt; Nothing
Nothing
ghci&gt; Nothing &lt;*&gt; Just "woot"
Nothing
</pre>
<p>We see how doing <code class="fixed">pure (+3)</code> and <code class="fixed">Just (+3)</code> is the same in this case. Use <code class="fixed">pure</code> if you're dealing with <code class="fixed">Maybe</code> values in an applicative context (i.e. using them with <code class="fixed">&lt;*&gt;</code>), otherwise stick to <code class="fixed">Just</code>. The first four input lines demonstrate how the function is extracted and then mapped, but in this case, they could have been achieved by just mapping unwrapped functions over functors. The last line is interesting, because we try to extract a function from a <code class="fixed">Nothing</code> and then map it over something, which of course results in a <code class="fixed">Nothing</code>.</p>
<p>With normal functors, you can just map a function over a functor and then you can't get the result out in any general way, even if the result is a partially applied function. Applicative functors, on the other hand, allow you to operate on several functors with a single function. Check out this piece of code:</p>
<pre name="code" class="haskell:hs">
ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5
Just 8
ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Nothing
Nothing
ghci&gt; pure (+) &lt;*&gt; Nothing &lt;*&gt; Just 5
Nothing
</pre>
<img src="lyah/whale.png" alt="whaale" class="right" width="214" height="177">
<p>What's going on here? Let's take a look, step by step. <code class="fixed">&lt;*&gt;</code> is left-associative, which means that <code class="fixed">pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5</code> is the same as <code class="fixed">(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 5</code>. First, the <code class="fixed">+</code> function is put in a functor, which is in this case a <code class="fixed">Maybe</code> value that contains the function. So at first, we have <code class="fixed">pure (+)</code>, which is <code class="fixed">Just (+)</code>. Next, <code class="fixed">Just (+) &lt;*&gt; Just 3</code> happens. The result of this is <code class="fixed">Just (3+)</code>. This is because of partial application. Only applying <code class="fixed">3</code> to the <code class="fixed">+</code> function results in a function that takes one parameter and adds 3 to it. Finally, <code class="fixed">Just (3+) &lt;*&gt; Just 5</code> is carried out, which results in a <code class="fixed">Just 8</code>. </p>
<p>Isn't this awesome?! Applicative functors and the applicative style of doing <code class="fixed">pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code> allow us to take a function that expects parameters that aren't necessarily wrapped in functors and use that function to operate on several values that are in functor contexts. The function can take as many parameters as we want, because it's always partially applied step by step between occurences of <code class="fixed">&lt;*&gt;</code>.</p>
<p>This becomes even more handy and apparent if we consider the fact that <code class="fixed">pure f &lt;*&gt; x</code> equals <code class="fixed">fmap f x</code>. This is one of the applicative laws. We'll take a closer look at them later, but for now, we can sort of intuitively see that this is so. Think about it, it makes sense. Like we said before, <code class="fixed">pure</code> puts a value in a default context. If we just put a function in a default context and then extract and apply it to a value inside another applicative functor, we did the same as just mapping that function over that applicative functor. Instead of writing <code class="fixed">pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code>, we can write <code class="fixed">fmap f x &lt;*&gt; y &lt;*&gt; ...</code>. This is why <code class="fixed">Control.Applicative</code> exports a function called <code class="fixed">&lt;$&gt;</code>, which is just <code class="fixed">fmap</code> as an infix operator. Here's how it's defined:</p>
<pre name="code" class="haskell:hs">
(&lt;$&gt;) :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b
f &lt;$&gt; x = fmap f x
</pre>
<div class="hintbox"><em>Yo!</em> Quick reminder: type variables are independent of parameter names or other value names. The <code class="fixed">f</code> in the function declaration here is a type variable with a class constraint saying that any type constructor that replaces <code class="fixed">f</code> should be in the <code class="fixed">Functor</code> typeclass. The <code class="fixed">f</code> in the function body denotes a function that we map over <code class="fixed">x</code>. The fact that we used <code class="fixed">f</code> to represent both of those doesn't mean that they somehow represent the same thing.</div>
<p>By using <code class="fixed">&lt;$&gt;</code>, the applicative style really shines, because now if we want to apply a function <code class="fixed">f</code> between three applicative functors, we can write <code class="fixed">f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z</code>. If the parameters weren't applicative functors but normal values, we'd write <code class="fixed">f x y z</code>.</p>
<p>Let's take a closer look at how this works. We have a value of <code class="fixed">Just "johntra"</code> and a value of <code class="fixed">Just "volta"</code> and we want to join them into one <code class="fixed">String</code> inside a <code class="fixed">Maybe</code> functor. We do this:</p>
<pre name="code" class="haskell:hs">
ghci&gt; (++) &lt;$&gt; Just "johntra" &lt;*&gt; Just "volta"
Just "johntravolta"
</pre>
<p>Before we see how this happens, compare the above line with this:</p>
<pre name="code" class="haskell:hs">
ghci&gt; (++) "johntra" "volta"
"johntravolta"
</pre>
<p>Awesome! To use a normal function on applicative functors, just sprinkle some <code class="fixed">&lt;$&gt;</code> and <code class="fixed">&lt;*&gt;</code> about and the function will operate on applicatives and return an applicative. How cool is that?</p>
<p>Anyway, when we do <code class="fixed">(++) &lt;$&gt; Just "johntra" &lt;*&gt; Just "volta"</code>, first <code class="fixed">(++)</code>, which has a type of <code class="fixed">(++) :: [a] -&gt; [a] -&gt; [a]</code> gets mapped over <code class="fixed">Just "johntra"</code>, resulting in a value that's the same as <code class="fixed">Just ("johntra"++)</code> and has a type of <code class="fixed">Maybe ([Char] -&gt; [Char])</code>. Notice how the first parameter of <code class="fixed">(++)</code> got eaten up and how the <code class="fixed">a</code>s turned into <code class="fixed">Char</code>s. And now <code class="fixed">Just ("johntra"++) &lt;*&gt; Just "volta"</code> happens, which takes the function out of the <code class="fixed">Just</code> and maps it over <code class="fixed">Just "volta"</code>, resulting in <code class="fixed">Just "johntravolta"</code>. Had any of the two values been <code class="fixed">Nothing</code>, the result would have also been <code class="fixed">Nothing</code>.</p>
<p>So far, we've only used <code class="fixed">Maybe</code> in our examples and you might be thinking that applicative functors are all about <code class="fixed">Maybe</code>. There are loads of other instances of <code class="fixed">Applicative</code>, so let's go and meet them!</p>
<p>Lists (actually the list type constructor, <code class="fixed">[]</code>) are applicative functors. What a suprise! Here's how <code class="fixed">[]</code> is an instance of <code class="fixed">Applicative</code>:</p>
<pre name="code" class="haskell:hs">
instance Applicative [] where
    pure x = [x]
    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]
</pre>
<p>Earlier, we said that <code class="fixed">pure</code> takes a value and puts it in a default context. Or in other words, a minimal context that still yields that value. The minimal context for lists would be the empty list, <code class="fixed">[]</code>, but the empty list represents the lack of a value, so it can't hold in itself the value that we used <code class="fixed">pure</code> on. That's why <code class="fixed">pure</code> takes a value and puts it in a singleton list. Similarly, the minimal context for the <code class="fixed">Maybe</code> applicative functor would be a <code class="fixed">Nothing</code>, but it represents the lack of a value instead of a value, so <code class="fixed">pure</code> is implemented as <code class="fixed">Just</code> in the instance implementation for <code class="fixed">Maybe</code>.</p>
<pre name="code" class="haskell:hs">
ghci&gt; pure "Hey" :: [String]
["Hey"]
ghci&gt; pure "Hey" :: Maybe String
Just "Hey"
</pre>
<p>What about <code class="fixed">&lt;*&gt;</code>? If we look at what <code class="fixed">&lt;*&gt;</code>'s type would be if it were limited only to lists, we get <code class="fixed">(&lt;*&gt;) :: [a -&gt; b] -&gt; [a] -&gt; [b]</code>. It's implemented with a <a href="starting-out.html#im-a-list-comprehension">list comprehension</a>. <code class="fixed">&lt;*&gt;</code> has to somehow extract the function out of its left parameter and then map it over the right parameter. But the thing here is that the left list can have zero functions, one function, or several functions inside it. The right list can also hold several values. That's why we use a list comprehension to draw from both lists. We apply every possible function from the left list to every possible value from the right list. The resulting list has every possible combination of applying a function from the left list to a value in the right one.</p>
<pre name="code" class="haskell:hs">
ghci&gt; [(*0),(+100),(^2)] &lt;*&gt; [1,2,3]
[0,0,0,101,102,103,1,4,9]
</pre>
<p>The left list has three functions and the right list has three values, so the resulting list will have nine elements. Every function in the left list is applied to every function in the right one. If we have a list of functions that take two parameters, we can apply those functions between two lists.</p>
<pre name="code" class="haskell:hs">
ghci&gt; [(+),(*)] &lt;*&gt; [1,2] &lt;*&gt; [3,4]
[4,5,5,6,3,4,6,8]
</pre>
<p>Because <code class="fixed">&lt;*&gt;</code> is left-associative, <code class="fixed">[(+),(*)] &lt;*&gt; [1,2]</code> happens first, resulting in a list that's the same as <code class="fixed">[(1+),(2+),(1*),(2*)]</code>, because every function on the left gets applied to every value on the right. Then, <code class="fixed">[(1+),(2+),(1*),(2*)] &lt;*&gt; [3,4]</code> happens, which produces the final result.</p>
<p>Using the applicative style with lists is fun! Watch:</p>
<pre name="code" class="haskell:hs">
ghci&gt; (++) &lt;$&gt; ["ha","heh","hmm"] &lt;*&gt; ["?","!","."]
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]
</pre>
<p>Again, see how we used a normal function that takes two strings between two applicative functors of strings just by inserting the appropriate applicative operators.</p>
<p>You can view lists as non-deterministic computations. A value like <code class="fixed">100</code> or <code class="fixed">"what"</code> can be viewed as a deterministic computation that has only one result, whereas a list like <code class="fixed">[1,2,3]</code> can be viewed as a computation that can't decide on which result it wants to have, so it presents us with all of the possible results. So when you do something like <code class="fixed">(+) &lt;$&gt; [1,2,3] &lt;*&gt; [4,5,6]</code>, you can think of it as adding together two non-deterministic computations with <code class="fixed">+</code>, only to produce another non-deterministic computation that's even less sure about its result.</p>
<p>Using the applicative style on lists is often a good replacement for list comprehensions. In the second chapter, we wanted to see all the possible products of <code class="fixed">[2,5,10]</code> and <code class="fixed">[8,10,11]</code>, so we did this:</p>
<pre name="code" class="haskell:hs">
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]   
[16,20,22,40,50,55,80,100,110]   
</pre>
<p>We're just drawing from two lists and applying a function between every combination of elements. This can be done in the applicative style as well:</p>
<pre name="code" class="haskell:hs">
ghci&gt; (*) &lt;$&gt; [2,5,10] &lt;*&gt; [8,10,11]
[16,20,22,40,50,55,80,100,110]
</pre>
<p>This seems clearer to me, because it's easier to see that we're just calling <code class="fixed">*</code> between two non-deterministic computations. If we wanted all possible products of those two lists that are more than 50, we'd just do:</p>
<pre name="code" class="haskell:hs">
ghci&gt; filter (&gt;50) $ (*) &lt;$&gt; [2,5,10] &lt;*&gt; [8,10,11]
[55,80,100,110]
</pre>
<p>It's easy to see how <code class="fixed">pure f &lt;*&gt; xs</code> equals <code class="fixed">fmap f xs</code> with lists. <code class="fixed">pure f</code> is just <code class="fixed">[f]</code> and <code class="fixed">[f] &lt;*&gt; xs</code> will apply every function in the left list to every value in the right one, but there's just one function in the left list, so it's like mapping.</p>
<p>Another instance of <code class="fixed">Applicative</code> that we've already encountered is <code class="fixed">IO</code>. This is how the instance is implemented:</p>
<pre name="code" class="haskell:hs">
instance Applicative IO where
    pure = return
    a &lt;*&gt; b = do
        f &lt;- a
        x &lt;- b
        return (f x)
</pre>
<img src="lyah/knight.png" alt="ahahahah!" class="left" width="195" height="458">
<p>Since <code class="fixed">pure</code> is all about putting a value in a minimal context that still holds it as its result, it makes sense that <code class="fixed">pure</code> is just <code class="fixed">return</code>, because <code class="fixed">return</code> does exactly that; it makes an I/O action that doesn't do anything, it just yields some value as its result, but it doesn't really do any I/O operations like printing to the terminal or reading from a file.</p>
<p>If <code class="fixed">&lt;*&gt;</code> were specialized for <code class="fixed">IO</code> it would have a type of <code class="fixed">(&lt;*&gt;) :: IO (a -&gt; b) -&gt; IO a -&gt; IO b</code>. It would take an I/O action that yields a function as its result and another I/O action and create a new I/O action from those two that, when performed, first performs the first one to get the function and then performs the second one to get the value and then it would yield that function applied to the value as its result. We used <i>do</i> syntax to implement it here. Remember, <i>do</i> syntax is about taking several I/O actions and gluing them into one, which is exactly what we do here.</p>
<p>With <code class="fixed">Maybe</code> and <code class="fixed">[]</code>, we could think of <code class="fixed">&lt;*&gt;</code> as simply extracting a function from its left parameter and then sort of applying it over the right one. With <code class="fixed">IO</code>, extracting is still in the game, but now we also have a notion of <i>sequencing</i>, because we're taking two I/O actions and we're sequencing, or gluing, them into one. We have to extract the function from the first I/O action, but to extract a result from an I/O action, it has to be performed.</p>
<p>Consider this:</p>
<pre name="code" class="haskell:hs">
myAction :: IO String
myAction = do
    a &lt;- getLine
    b &lt;- getLine
    return $ a ++ b
</pre>
<p>This is an I/O action that will prompt the user for two lines and yield as its result those two lines concatenated. We achieved it by gluing together two <code class="fixed">getLine</code> I/O actions and a <code class="fixed">return</code>, because we wanted our new glued I/O action to hold the result of <code class="fixed">a ++ b</code>. Another way of writing this would be to use the applicative style.</p>
<pre name="code" class="haskell:hs">
myAction :: IO String
myAction = (++) &lt;$&gt; getLine &lt;*&gt; getLine
</pre>
<p>What we were doing before was making an I/O action that applied a function between the results of two other I/O actions, and this is the same thing. Remember, <code class="fixed">getLine</code> is an I/O action with the type <code class="fixed">getLine :: IO String</code>. When we use <code class="fixed">&lt;*&gt;</code> between two applicative functors, the result is an applicative functor, so this all makes sense.</p>
<p>If we regress to the box analogy, we can imagine <code class="fixed">getLine</code> as a box that will go out into the real world and fetch us a string. Doing <code class="fixed">(++) &lt;$&gt; getLine &lt;*&gt; getLine</code> makes a new, bigger box that sends those two boxes out to fetch lines from the terminal and then presents the concatenation of those two lines as its result.</p>
<p>The type of the expression <code class="fixed">(++) &lt;$&gt; getLine &lt;*&gt; getLine</code> is <code class="fixed">IO String</code>, which means that this expression is a completely normal I/O action like any other, which also holds a result value inside it, just like other I/O actions. That's why we can do stuff like:</p>
<pre name="code" class="haskell:hs">
main = do
    a &lt;- (++) &lt;$&gt; getLine &lt;*&gt; getLine
    putStrLn $ "The two lines concatenated turn out to be: " ++ a
</pre>
<p>If you ever find yourself binding some I/O actions to names and then calling some function on them and presenting that as the result by using <code class="fixed">return</code>, consider using the applicative style because it's arguably a bit more concise and terse.</p>
<p>Another instance of <code class="fixed">Applicative</code> is <code class="fixed">(-&gt;) r</code>, so functions. They are rarely used with the applicative style outside of code golf, but they're still interesting as applicatives, so let's take a look at how the function instance is implemented.</p>
<div class="hintbox">If you're confused about what <code class="fixed">(-&gt;) r</code> means, check out the previous section where we explain how <code class="fixed">(-&gt;) r</code> is a functor.</div>
<pre name="code" class="haskell:hs">
instance Applicative ((-&gt;) r) where
    pure x = (\_ -&gt; x)
    f &lt;*&gt; g = \x -&gt; f x (g x)
</pre>
<p>When we wrap a value into an applicative functor with <code class="fixed">pure</code>, the result it yields always has to be that value. A minimal default context that still yields that value as a result. That's why in the function instance implementation, <code class="fixed">pure</code> takes a value and creates a function that ignores its parameter and always returns that value. If we look at the type for <code class="fixed">pure</code>, but specialized for the <code class="fixed">(-&gt;) r</code> instance, it's <code class="fixed">pure :: a -&gt; (r -&gt; a)</code>.</p>
<pre name="code" class="haskell:hs">
ghci&gt; (pure 3) "blah"
3
</pre>
<p>Because of currying, function application is left-associative, so we can omit the parentheses.</p>
<pre name="code" class="haskell:hs">
ghci&gt; pure 3 "blah"
3
</pre>
<p>The instance implementation for <code class="fixed">&lt;*&gt;</code> is a bit cryptic, so it's best if we just take a look at how to use functions as applicative functors in the applicative style.</p>
<pre name="code" class="haskell:hs">
ghci&gt; :t (+) &lt;$&gt; (+3) &lt;*&gt; (*100)
(+) &lt;$&gt; (+3) &lt;*&gt; (*100) :: (Num a) =&gt; a -&gt; a
ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5
508
</pre>
<p>Calling <code class="fixed">&lt;*&gt;</code> with two applicative functors results in an applicative functor, so if we use it on two functions, we get back a function. So what goes on here? When we do <code class="fixed">(+) &lt;$&gt; (+3) &lt;*&gt; (*100)</code>, we're making a function that will use <code class="fixed">+</code> on the results of <code class="fixed">(+3)</code> and <code class="fixed">(*100)</code> and return that. To demonstrate on a real example, when we did <code class="fixed">(+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5</code>, the <code class="fixed">5</code> first got applied to <code class="fixed">(+3)</code> and <code class="fixed">(*100)</code>, resulting in <code class="fixed">8</code> and <code class="fixed">500</code>. Then, <code class="fixed">+</code> gets called with <code class="fixed">8</code> and <code class="fixed">500</code>, resulting in <code class="fixed">508</code>.</p>
<pre name="code" class="haskell:hs">
ghci&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5
[8.0,10.0,2.5]
</pre>
<img src="lyah/jazzb.png" alt="SLAP" class="right" width="400px" height="230px">
<p>Same here. We create a function that will call the function <code class="fixed">\x y z -&gt; [x,y,z]</code> with the eventual results from <code class="fixed">(+3)</code>, <code class="fixed">(*2)</code> and <code class="fixed">(/2)</code>. The <code class="fixed">5</code> gets fed to each of the three functions and then <code class="fixed">\x y z -&gt; [x, y, z]</code> gets called with those results.</p>
<p>You can think of functions as boxes that contain their eventual results, so doing <code class="fixed">k &lt;$&gt; f &lt;*&gt; g</code> creates a function that will call <code class="fixed">k</code> with the eventual results from <code class="fixed">f</code> and <code class="fixed">g</code>. When we do something like <code class="fixed">(+) &lt;$&gt; Just 3 &lt;*&gt; Just 5</code>, we're using <code class="fixed">+</code> on values that might or might not be there, which also results in a value that might or might not be there. When we do <code class="fixed">(+) &lt;$&gt; (+10) &lt;*&gt; (+5)</code>, we're using <code class="fixed">+</code> on the future return values of <code class="fixed">(+10)</code> and <code class="fixed">(+5)</code> and the result is also something that will produce a value only when called with a parameter.</p>
<p>We don't often use functions as applicatives, but this is still really interesting. It's not very important that you get how the <code class="fixed">(-&gt;) r</code> instance for <code class="fixed">Applicative</code> works, so don't despair if you're not getting this right now. Try playing with the applicative style and functions to build up an intuition for functions as applicatives.</p>
<p>An instance of <code class="fixed">Applicative</code> that we haven't encountered yet is <code class="fixed">ZipList</code>, and it lives in <code class="fixed">Control.Applicative</code>. </p>
<p>It turns out there are actually more ways for lists to be applicative functors. One way is the one we already covered, which says that calling <code class="fixed">&lt;*&gt;</code> with a list of functions and a list of values results in a list which has all the possible combinations of applying functions from the left list to the values in the right list. If we do <code class="fixed">[(+3),(*2)] &lt;*&gt; [1,2]</code>, <code class="fixed">(+3)</code> will be applied to both <code class="fixed">1</code> and <code class="fixed">2</code> and <code class="fixed">(*2)</code> will also be applied to both <code class="fixed">1</code> and <code class="fixed">2</code>, resulting in a list that has four elements, namely <code class="fixed">[4,5,2,4]</code>.</p>
<p>However, <code class="fixed">[(+3),(*2)] &lt;*&gt; [1,2]</code> could also work in such a way that the first function in the left list gets applied to the first value in the right one, the second function gets applied to the second value, and so on. That would result in a list with two values, namely <code class="fixed">[4,4]</code>. You could look at it as <code class="fixed">[1 + 3, 2 * 2]</code>.</p>
<p>Because one type can't have two instances for the same typeclass, the <code class="fixed">ZipList a</code> type was introduced, which has one constructor <code class="fixed">ZipList</code> that has just one field, and that field is a list. Here's the instance:</p>
<pre name="code" class="haskell:hs">
instance Applicative ZipList where
        pure x = ZipList (repeat x)
        ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith (\f x -&gt; f x) fs xs)
</pre>
<p><code class="fixed">&lt;*&gt;</code> does just what we said. It applies the first function to the first value, the second function to the second value, etc. This is done with <code class="fixed">zipWith (\f x -&gt; f x) fs xs</code>. Because of how <code class="fixed">zipWith</code> works, the resulting list will be as long as the shorter of the two lists.</p>
<p><code class="fixed">pure</code> is also interesting here. It takes a value and puts it in a list that just has that value repeating indefinitely. <code class="fixed">pure "haha"</code> results in <code class="fixed">ZipList (["haha","haha","haha"...</code>. This might be a bit confusing since we said that <code class="fixed">pure</code> should put a value in a minimal context that still yields that value. And you might be thinking that an infinite list of something is hardly minimal. But it makes sense with zip lists, because it has to produce the value on every position. This also satisfies the law that <code class="fixed">pure f &lt;*&gt; xs</code> should equal <code class="fixed">fmap f xs</code>. If <code class="fixed">pure 3</code> just returned <code class="fixed">ZipList [3]</code>, <code class="fixed">pure (*2) &lt;*&gt; ZipList [1,5,10]</code> would result in <code class="fixed">ZipList [2]</code>, because the resulting list of two zipped lists has the length of the shorter of the two. If we zip a finite list with an infinite list, the length of the resulting list will always be equal to the length of the finite list.</p>
<p>So how do zip lists work in an applicative style? Let's see. Oh, the <code class="fixed">ZipList a</code> type doesn't have a <code class="fixed">Show</code> instance, so we have to use the <code class="label function">getZipList</code> function to extract a raw list out of a zip list.</p>
<pre name="code" class="haskell:hs">
ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100,100]
[101,102,103]
ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..]
[101,102,103]
ghci&gt; getZipList $ max &lt;$&gt; ZipList [1,2,3,4,5,3] &lt;*&gt; ZipList [5,3,1,2]
[5,3,3,4]
ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList "dog" &lt;*&gt; ZipList "cat" &lt;*&gt; ZipList "rat"
[('d','c','r'),('o','a','a'),('g','t','t')]
</pre>
<div class="hintbox">The <code class="fixed">(,,)</code> function is the same as <code class="fixed">\x y z -&gt; (x,y,z)</code>. Also, the <code class="fixed">(,)</code> function is the same as <code class="fixed">\x y -&gt; (x,y)</code>.</div>
<p>Aside from <code class="fixed">zipWith</code>, the standard library has functions such as <code class="fixed">zipWith3</code>, <code class="fixed">zipWith4</code>, all the way up to 7. <code class="fixed">zipWith</code> takes a function that takes two parameters and zips two lists with it. <code class="fixed">zipWith3</code> takes a function that takes three parameters and zips three lists with it, and so on. By using zip lists with an applicative style, we don't have to have a separate zip function for each number of lists that we want to zip together. We just use the applicative style to zip together an arbitrary amount of lists with a function, and that's pretty cool.</p>
<p><code class="fixed">Control.Applicative</code> defines a function that's called <code class="label function">liftA2</code>, which has a type of <code class="fixed">liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</code> . It's defined like this:</p>
<pre name="code" class="haskell:hs">
liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
liftA2 f a b = f &lt;$&gt; a &lt;*&gt; b
</pre>
<p>Nothing special, it just applies a function between two applicatives, hiding the applicative style that we've become familiar with. The reason we're looking at it is because it clearly showcases why applicative functors are more powerful than just ordinary functors. With ordinary functors, we can just map functions over one functor. But with applicative functors, we can apply a function between several functors. It's also interesting to look at this function's type as <code class="fixed">(a -&gt; b -&gt; c) -&gt; (f a -&gt; f b -&gt; f c)</code>. When we look at it like this, we can say that <code class="fixed">liftA2</code> takes a normal binary function and promotes it to a function that operates on two functors.</p>
<p>Here's an interesting concept: we can take two applicative functors and combine them into one applicative functor that has inside it the results of those two applicative functors in a list. For instance, we have <code class="fixed">Just 3</code> and <code class="fixed">Just 4</code>. Let's assume that the second one has a singleton list inside it, because that's really easy to achieve:</p>
<pre name="code" class="haskell:hs">
ghci&gt; fmap (\x -&gt; [x]) (Just 4)
Just [4]
</pre>
<p>OK, so let's say we have <code class="fixed">Just 3</code> and <code class="fixed">Just [4]</code>. How do we get <code class="fixed">Just [3,4]</code>? Easy.</p>
<pre name="code" class="haskell:hs">
ghci&gt; liftA2 (:) (Just 3) (Just [4])
Just [3,4]
ghci&gt; (:) &lt;$&gt; Just 3 &lt;*&gt; Just [4]
Just [3,4]
</pre>
<p>Remember, <code class="fixed">:</code> is a function that takes an element and a list and returns a new list with that element at the beginning. Now that we have <code class="fixed">Just [3,4]</code>, could we combine that with <code class="fixed">Just 2</code> to produce <code class="fixed">Just [2,3,4]</code>? Of course we could. It seems that we can combine any amount of applicatives into one applicative that has a list of the results of those applicatives inside it. Let's try implementing a function that takes a list of applicatives and returns an applicative that has a list as its result value. We'll call it <code class="fixed">sequenceA</code>.</p>
<pre name="code" class="haskell:hs">
sequenceA :: (Applicative f) =&gt; [f a] -&gt; f [a]
sequenceA [] = pure []
sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs
</pre>
<p>Ah, recursion! First, we look at the type. It will transform a list of applicatives into an applicative with a list. From that, we can lay some groundwork for an edge condition. If we want to turn an empty list into an applicative with a list of results, well, we just put an empty list in a default context. Now comes the recursion. If we have a list with a head and a tail (remember, <code class="fixed">x</code> is an applicative and <code class="fixed">xs</code> is a list of them), we call <code class="fixed">sequenceA</code> on the tail, which results in an applicative with a list. Then, we just prepend the value inside the applicative <code class="fixed">x</code> into that applicative with a list, and that's it!</p>
<p>So if we do <code class="fixed">sequenceA [Just 1, Just 2]</code>, that's <code class="fixed">(:) &lt;$&gt; Just 1 &lt;*&gt; sequenceA [Just 2] </code>. That equals <code class="fixed">(:) &lt;$&gt; Just 1 &lt;*&gt; ((:) &lt;$&gt; Just 2 &lt;*&gt; sequenceA [])</code>. Ah! We know that <code class="fixed">sequenceA []</code> ends up as being <code class="fixed">Just []</code>, so this expression is now <code class="fixed">(:) &lt;$&gt; Just 1 &lt;*&gt; ((:) &lt;$&gt; Just 2 &lt;*&gt; Just [])</code>, which is <code class="fixed">(:) &lt;$&gt; Just 1 &lt;*&gt; Just [2]</code>, which is <code class="fixed">Just [1,2]</code>!</p>
<p>Another way to implement <code class="fixed">sequenceA</code> is with a fold. Remember, pretty much any function where we go over a list element by element and accumulate a result along the way can be implemented with a fold.</p>
<pre name="code" class="haskell:hs">
sequenceA :: (Applicative f) =&gt; [f a] -&gt; f [a]
sequenceA = foldr (liftA2 (:)) (pure [])
</pre>
<p>We approach the list from the right and start off with an accumulator value of <code class="fixed">pure []</code>. We do <code class="fixed">liftA2 (:)</code> between the accumulator and the last element of the list, which results in an applicative that has a singleton in it. Then we do <code class="fixed">liftA2 (:)</code> with the now last element and the current accumulator and so on, until we're left with just the accumulator, which holds a list of the results of all the applicatives.</p>
<p>Let's give our function a whirl on some applicatives.</p>
<pre name="code" class="haskell:hs">
ghci&gt; sequenceA [Just 3, Just 2, Just 1]
Just [3,2,1]
ghci&gt; sequenceA [Just 3, Nothing, Just 1]
Nothing
ghci&gt; sequenceA [(+3),(+2),(+1)] 3
[6,5,4]
ghci&gt; sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]
[]
</pre>
<p>Ah! Pretty cool. When used on <code class="fixed">Maybe</code> values, <code class="fixed">sequenceA</code> creates a <code class="fixed">Maybe</code> value with all the results inside it as a list. If one of the values was <code class="fixed">Nothing</code>, then the result is also a <code class="fixed">Nothing</code>. This is cool when you have a list of <code class="fixed">Maybe</code> values and you're interested in the values only if none of them is a <code class="fixed">Nothing</code>.</p>
<p>When used with functions, <code class="fixed">sequenceA</code> takes a list of functions and returns a function that returns a list. In our example, we made a function that took a number as a parameter and applied it to each function in the list and then returned a list of results. <code class="fixed">sequenceA [(+3),(+2),(+1)] 3</code> will call <code class="fixed">(+3)</code> with <code class="fixed">3</code>, <code class="fixed">(+2)</code> with <code class="fixed">3</code> and <code class="fixed">(+1)</code> with <code class="fixed">3</code> and present all those results as a list.</p>
<p>Doing <code class="fixed">(+) &lt;$&gt; (+3) &lt;*&gt; (*2)</code> will create a function that takes a parameter, feeds it to both <code class="fixed">(+3)</code> and <code class="fixed">(*2)</code> and then calls <code class="fixed">+</code> with those two results. In the same vein, it makes sense that <code class="fixed">sequenceA [(+3),(*2)]</code> makes a function that takes a parameter and feeds it to all of the functions in the list. Instead of calling <code class="fixed">+</code> with the results of the functions, a combination of <code class="fixed">:</code> and <code class="fixed">pure []</code> is used to gather those results in a list, which is the result of that function.</p>
<p>Using <code class="fixed">sequenceA</code> is cool when we have a list of functions and we want to feed the same input to all of them and then view the list of results. For instance, we have a number and we're wondering whether it satisfies all of the predicates in a list. One way to do that would be like so:</p>
<pre name="code" class="haskell:hs">
ghci&gt; map (\f -&gt; f 7) [(&gt;4),(&lt;10),odd]
[True,True,True]
ghci&gt; and $ map (\f -&gt; f 7) [(&gt;4),(&lt;10),odd]
True
</pre>
<p>Remember, <code class="fixed">and</code> takes a list of booleans and returns <code class="fixed">True</code> if they're all <code class="fixed">True</code>. Another way to achieve the same thing would be with <code class="fixed">sequenceA</code>:</p>
<pre name="code" class="haskell:hs">
ghci&gt; sequenceA [(&gt;4),(&lt;10),odd] 7
[True,True,True]
ghci&gt; and $ sequenceA [(&gt;4),(&lt;10),odd] 7
True
</pre>
<p><code class="fixed">sequenceA [(&gt;4),(&lt;10),odd]</code> creates a function that will take a number and feed it to all of the predicates in <code class="fixed">[(&gt;4),(&lt;10),odd]</code> and return a list of booleans. It turns a list with the type <code class="fixed">(Num a) =&gt; [a -&gt; Bool]</code> into a function with the type <code class="fixed">(Num a) =&gt; a -&gt; [Bool]</code>. Pretty neat, huh?</p>
<p>Because lists are homogenous, all the functions in the list have to be functions of the same type, of course. You can't have a list like <code class="fixed">[ord, (+3)]</code>, because <code class="fixed">ord</code> takes a character and returns a number, whereas <code class="fixed">(+3)</code> takes a number and returns a number.</p>
<p>When used with <code class="fixed">[]</code>, <code class="fixed">sequenceA</code> takes a list of lists and returns a list of lists. Hmm, interesting. It actually creates lists that have all possible combinations of their elements. For illustration, here's the above done with <code class="fixed">sequenceA</code> and then done with a list comprehension:</p>
<pre name="code" class="haskell:hs">
ghci&gt; sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; [[x,y] | x &lt;- [1,2,3], y &lt;- [4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; sequenceA [[1,2],[3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci&gt; [[x,y] | x &lt;- [1,2], y &lt;- [3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci&gt; sequenceA [[1,2],[3,4],[5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
ghci&gt; [[x,y,z] | x &lt;- [1,2], y &lt;- [3,4], z &lt;- [5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
</pre>
<p>This might be a bit hard to grasp, but if you play with it for a while, you'll see how it works. Let's say that we're doing <code class="fixed">sequenceA [[1,2],[3,4]]</code>. To see how this happens, let's use the <code class="fixed">sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs</code> definition of <code class="fixed">sequenceA</code> and the edge condition <code class="fixed">sequenceA [] = pure []</code>. You don't have to follow this evaluation, but it might help you if have trouble imagining how <code class="fixed">sequenceA</code> works on lists of lists, because it can be a bit mind-bending. </p>
<ul>
    <li>We start off with <code class="fixed">sequenceA [[1,2],[3,4]]</code></li>
    <li>That evaluates to <code class="fixed">(:) &lt;$&gt; [1,2] &lt;*&gt; sequenceA [[3,4]]</code></li>
    <li>Evaluating the inner <code class="fixed">sequenceA</code> further, we get <code class="fixed">(:) &lt;$&gt; [1,2] &lt;*&gt; ((:) &lt;$&gt; [3,4] &lt;*&gt; sequenceA [])</code></li>
    <li>We've reached the edge condition, so this is now <code class="fixed">(:) &lt;$&gt; [1,2] &lt;*&gt; ((:) &lt;$&gt; [3,4] &lt;*&gt; [[]])</code></li>
    <li>Now, we evaluate the <code class="fixed">(:) &lt;$&gt; [3,4] &lt;*&gt; [[]]</code> part, which will use <code class="fixed">:</code> with every possible value in the left list (possible values are <code class="fixed">3</code> and <code class="fixed">4</code>) with every possible value on the right list (only possible value is <code class="fixed">[]</code>), which results in <code class="fixed">[3:[], 4:[]]</code>, which is <code class="fixed">[[3],[4]]</code>. So now we have <code class="fixed">(:) &lt;$&gt; [1,2] &lt;*&gt; [[3],[4]]</code></li>
    <li>Now, <code class="fixed">:</code> is used with every possible value from the left list (<code class="fixed">1</code> and <code class="fixed">2</code>) with every possible value in the right list (<code class="fixed">[3]</code> and <code class="fixed">[4]</code>), which results in <code class="fixed">[1:[3], 1:[4], 2:[3], 2:[4]]</code>, which is <code class="fixed">[[1,3],[1,4],[2,3],[2,4]</code></li>
</ul>
<p>Doing <code class="fixed">(+) &lt;$&gt; [1,2] &lt;*&gt; [4,5,6]</code>results in a non-deterministic computation <code class="fixed">x + y</code> where <code class="fixed">x</code> takes on every value from <code class="fixed">[1,2]</code> and <code class="fixed">y</code> takes on every value from <code class="fixed">[4,5,6]</code>. We represent that as a list which holds all of the possible results. Similarly, when we do <code class="fixed">sequence [[1,2],[3,4],[5,6],[7,8]]</code>, the result is a non-deterministic computation <code class="fixed">[x,y,z,w]</code>, where <code class="fixed">x</code> takes on every value from <code class="fixed">[1,2]</code>, <code class="fixed">y</code> takes on every value from <code class="fixed">[3,4]</code> and so on. To represent the result of that non-deterministic computation, we use a list, where each element in the list is one possible list. That's why the result is a list of lists.</p>
<p>When used with I/O actions, <code class="fixed">sequenceA</code> is the same thing as <code class="fixed">sequence</code>! It takes a list of I/O actions and returns an I/O action that will perform each of those actions and have as its result a list of the results of those I/O actions. That's because to turn an <code class="fixed">[IO a]</code> value into an <code class="fixed">IO [a]</code> value, to make an I/O action that yields a list of results when performed, all those I/O actions have to be sequenced so that they're then performed one after the other when evaluation is forced. You can't get the result of an I/O action without performing it.</p>
<pre name="code" class="haskell:hs">
ghci&gt; sequenceA [getLine, getLine, getLine]
heyh
ho
woo
["heyh","ho","woo"]
</pre>
<p>Like normal functors, applicative functors come with a few laws. The most important one is the one that we already mentioned, namely that <code class="label law">pure f &lt;*&gt; x = fmap f x</code> holds. As an exercise, you can prove this law for some of the applicative functors that we've met in this chapter.The other functor laws are:</p>
<ul>
    <li><code class="label law">pure id &lt;*&gt; v = v</code></li>
    <li><code class="label law">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></li>
    <li><code class="label law">pure f &lt;*&gt; pure x = pure (f x)</code></li>
    <li><code class="label law">u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code></li>
</ul>
<p>We won't go over them in detail right now because that would take up a lot of pages and it would probably be kind of boring, but if you're up to the task, you can take a closer look at them and see if they hold for some of the instances.</p>
<p>In conclusion, applicative functors aren't just interesting, they're also useful, because they allow us to combine different computations, such as I/O computations, non-deterministic computations, computations that might have failed, etc. by using the applicative style. Just by using <code class="fixed">&lt;$&gt;</code> and <code class="fixed">&lt;*&gt;</code> we can use normal functions to uniformly operate on any number of applicative functors and take advantage of the semantics of each one.</p>
<a name="the-newtype-keyword"></a><h2>The newtype keyword</h2>

<img src="lyah/maoi.png" alt="why_ so serious?" class="left" width="107" height="202">

<p>
So far, we've learned how to make our own algebraic data types by using the 
<em>data</em> keyword.  We've also learned how to give existing types
synonyms with the <em>type</em> keyword. In this section, we'll be taking a look 
at how to make new types out of existing data types by using the 
<em>newtype</em> keyword and why we'd want to do that in the first place.
</p>

<p>
In the previous section, we saw that there are actually more ways for the list 
type to be an applicative functor. One way is to have <code class="fixed">&lt;*&gt;</code>
take every function out of the list that is its left parameter and apply it to 
every value in the list that is on the right, resulting in every possible 
combination of applying a function from the left list to a value in the right 
list. 
</p>

<pre name="code" class="haskell:hs">
ghci&gt; [(+1),(*100),(*5)] <*> [1,2,3]
[2,3,4,100,200,300,5,10,15]
</pre>

<p>
The second way is to take the first function on the left side of 
<code class="fixed">&lt;*&gt;</code> and apply it to the first value on the 
right, then take the second function from the list on the left side and apply it  
to the second value on the right, and so on. Ultimately, it's kind of like 
zipping the two lists together. But lists are already an instance of 
<code class="fixed">Applicative</code>, so how did we also make lists an instance 
of <code class="fixed">Applicative</code> in this second way? If you remember,
we said that the <code class="fixed">ZipList a</code> type was introduced for 
this reason, which has one value constructor, <code class="fixed">ZipList</code>, 
that has just one field. We put the list that we're wrapping in that field. 
Then, <code class="fixed">ZipList</code> was made an instance of <code class="fixed">Applicative</code>,
so that when we want to use lists as applicatives in the zipping manner, we just 
wrap them with the <code class="fixed">ZipList</code> constructor and then once 
we're done, unwrap them with <code class="fixed">getZipList</code>:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getZipList $ ZipList [(+1),(*100),(*5)] <*> ZipList [1,2,3]
[2,200,15]
</pre>

<p>
So, what does this have to do with this <i>newtype</i> keyword? Well, think 
about how we might write the data declaration for our <span 
class="fixed">ZipList a</span> type. One way would be to do it like so:
</p>

<pre name="code" class="haskell:hs">
data ZipList a = ZipList [a]
</pre>

<p>
A type that has just one value constructor and that value constructor has 
just one field that is a list of things. We might also want to use record syntax 
so that we automatically get a function that extracts a list from a <code class="fixed">ZipList</code>:
</p>

<pre name="code" class="haskell:hs">
data ZipList a = ZipList { getZipList :: [a] }
</pre>

<p>
This looks fine and would actually work pretty well. We had two ways of making 
an existing type an instance of a type class, so we used the <i>data</i>
keyword to just wrap that type into another type and made the other type an 
instance in the second way.
</p>

<p>
The <i>newtype</i> keyword in Haskell is made exactly for 
these cases when we want to just take one type and wrap it in something to 
present it as another type. In the actual libraries, <span class="fixed">ZipList 
a</span> is defined like this:
</p>

<pre name="code" class="haskell:hs">
newtype ZipList a = ZipList { getZipList :: [a] }
</pre>

<p>
Instead of the <i>data</i> keyword, the <i>newtype</i> keyword is used. Now why is that? Well for one, 
<i>newtype</i> is faster. If you use the <i>data</i> keyword
to wrap a type, there's some overhead to all that wrapping and unwrapping when 
your program is running. But if you use <i>newtype</i>, Haskell knows that 
you're just using it to wrap an existing type into a new type (hence the name), 
because you want it to be the same internally but have a different type. With 
that in mind, Haskell can get rid of the wrapping and unwrapping once it 
resolves which value is of what type.
</p>

<p>
So why not just use <i>newtype</i> all the time instead of <i>data</i> then? 
Well, when you make a new type from an existing type by using the 
<i>newtype</i> keyword, you can only have one value constructor and that value 
constructor can only have one field. But with <i>data</i>, you can make data 
types that have several value constructors and each constructor can have zero or 
more fields:
</p>

<pre name="code" class="haskell:hs">
data Profession = Fighter | Archer | Accountant

data Race = Human | Elf | Orc | Goblin

data PlayerCharacter = PlayerCharacter Race Profession
</pre>

<p>
When using <i>newtype</i>, you're restricted to just one constructor with one 
field.
</p>

<p>
We can also use the <i>deriving</i> keyword with <i>newtype</i> just like we 
would with <i>data</i>. We can derive instances for 
<code class="fixed">Eq</code>,
<code class="fixed">Ord</code>,
<code class="fixed">Enum</code>,
<code class="fixed">Bounded</code>,
<code class="fixed">Show</code> and
<code class="fixed">Read</code>.
If we derive the instance for a type class, the type that we're wrapping 
has to be in that type class to begin with. It makes sense, because 
<i>newtype</i> just wraps an existing type. So now if we do the following, we 
can print and equate values of our new type:
</p>

<pre name="code" class="haskell:hs">
newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)
</pre>

<p>
Let's give that a go:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; CharList "this will be shown!"
CharList {getCharList = "this will be shown!"}
ghci&gt; CharList "benny" == CharList "benny"
True
ghci&gt; CharList "benny" == CharList "oisters"
False
</pre>

<p>
In this particular <i>newtype</i>, the value constructor has the following type:
</p>

<pre name="code" class="haskell:hs">
CharList :: [Char] -&gt; CharList
</pre>

<p>
It takes a <code class="fixed">[Char]</code> value, such as <span 
class="fixed">"my sharona"</span>
and returns a <span 
class="fixed">CharList</span> value. From the above examples where we used 
the <code class="fixed">CharList</code> value constructor, we see that really is 
the case. Conversely, the <code class="fixed">getCharList</code> function, which 
was generated for us because we used record syntax in our <i>newtype</i>, has 
this type:
</p>

<pre name="code" class="haskell:hs">
getCharList :: CharList -&gt; [Char]
</pre>

<p>
It takes a <code class="fixed">CharList</code> value and converts it to a 
<code class="fixed">[Char]</code> value. You can think of this as wrapping 
and unwrapping, but you can also think of it as converting values from one type 
to the other.
</p>

<h3>Using newtype to make type class instances</h3>

<p>
Many times, we want to make our types instances of certain type classes, but the 
type parameters just don't match up for what we want to do. It's easy to make
<code class="fixed">Maybe</code> an instance of <code class="fixed">Functor</code>, because
the <code class="fixed">Functor</code> type class is defined like this:
</p>

<pre name="code" class="haskell:hs">
class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</pre>

<p>So we just start out with:</p>

<pre name="code" class="haskell:hs">
instance Functor Maybe where 
</pre>

<p>
And then implement <code class="fixed">fmap</code>. All the type parameters add 
up because the <code class="fixed">Maybe</code> takes the place of <code class="fixed">f</code>
in the definition of the <code class="fixed">Functor</code> type class and so if  
we look at <code class="fixed">fmap</code> like it only worked on 
<code class="fixed">Maybe</code>, it ends up behaving like:
</p>

<pre name="code" class="haskell:hs">
fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
</pre>

<img src="lyah/krakatoa.png" alt="wow, very evil" class="right" width="322px" height="280px">

<p>
Isn't that just peachy? Now what if we wanted to make the tuple an instance of
<code class="fixed">Functor</code> in such a way that when we <code class="fixed">fmap</code>
a function over a tuple, it gets applied to the first component of the tuple? 
That way, doing <code class="fixed">fmap (+3) (1,1)</code> would result in <code class="fixed">(4,1)</code>.
It turns out that writing the instance for that is kind of hard. With <span 
class="fixed">Maybe</span>, we just say <span class="fixed">instance Functor 
Maybe where</span> because only type constructors that take exactly one  
parameter can be made an instance of <code class="fixed">Functor</code>. But it 
seems like there's
no way to do something like that with <code class="fixed">(a,b)</code> so that 
the type parameter <code class="fixed">a</code> ends up being the one that 
changes when we use <code class="fixed">fmap</code>. To get  around this, we 
can <i>newtype</i> our tuple in such a way that the second type parameter 
represents the type of the first component in the tuple:
</p>

<pre name="code" class="haskell:hs">
newtype Pair b a = Pair { getPair :: (a,b) }
</pre>

<p>
And now, we can make it an instance of <code class="fixed">Functor</code> so 
that the function is mapped over the first component:
</p>

<pre name="code" class="haskell:hs">
instance Functor (Pair c) where
    fmap f (Pair (x,y)) = Pair (f x, y)
</pre>

<p>
As you can see, we can pattern match on types defined with <i>newtype</i>. We 
pattern match to get the underlying tuple, then we apply the function <code class="fixed">f</code>
to the first component in the tuple and then we use the <code class="fixed">Pair</code>
value constructor to convert the tuple back to our <code class="fixed">Pair b a</code>.
If we imagine what the type <code class="fixed">fmap</code> would be if it only 
worked on our new pairs, it would be:
</p>

<pre name="code" class="haskell:hs">
fmap :: (a -&gt; b) -&gt; Pair c a -&gt; Pair c b
</pre>

<p>
Again, we said <code class="fixed">instance Functor (Pair c) where</code> and so
<code class="fixed">Pair c</code> took the place of the <code class="fixed">f</code>
in the type class definition for <code class="fixed">Functor</code>:
</p>

<pre name="code" class="haskell:hs">
class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</pre>

<p>
So now, if we convert a tuple into a <code class="fixed">Pair b a</code>, we can 
use <code class="fixed">fmap</code> over it and the function will be mapped over 
the first component:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getPair $ fmap (*100) (Pair (2,3))
(200,3)
ghci&gt; getPair $ fmap reverse (Pair ("london calling", 3))
("gnillac nodnol",3)
</pre>

<h3>On newtype laziness</h3>

<p>
We mentioned that <i>newtype</i> is usually faster than <i>data</i>. The 
only thing that can be done with <i>newtype</i> is turning an existing type 
into a new type, so internally, Haskell can represent the values of types 
defined with <i>newtype</i> just like the original ones, only it has to keep in 
mind that the their types are now distinct. This fact means that not only is 
<i>newtype</i> faster, it's also lazier. Let's take a look at what this means.
</p>

<p>
Like we've said before, Haskell is lazy by default, which means that only 
when we try to actually print the results of our functions will any computation 
take place. Furthemore, only those computations that are necessary for our 
function to tell us the result will get carried out. The <code class="fixed">undefined</code>
value in Haskell represents an erronous computation. If we try to evaluate it 
(that is, force Haskell to actually compute it) by printing it to 
the terminal, Haskell will throw a hissy fit (technically referred to as an 
exception):
</p>

<pre name="code" class="haskell:hs">
ghci&gt; undefined
*** Exception: Prelude.undefined
</pre>

<p>
However, if we make a list that has some <code class="fixed">undefined</code> 
values in it but request only the head of the list, which is not <code class="fixed">undefined</code>,
everything will go smoothly because Haskell doesn't really need to evaluate any 
other elements in a list if we only want to see what the first element is:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; head [3,4,5,undefined,2,undefined]
3
</pre>

<p>
Now consider the following type:
</p>

<pre name="code" class="haskell:hs">
data CoolBool = CoolBool { getCoolBool :: Bool }
</pre>

<p>
It's your run-of-the-mill algebraic data type that was defined with the 
<i>data</i> keyword. It has one value constructor, which has one field whose 
type is <code class="fixed">Bool</code>. Let's make a function that pattern 
matches on a <code class="fixed">CoolBool</code> and returns the value 
<code class="fixed">"hello"</code> regardless of whether the <code class="fixed">Bool</code> inside
the <code class="fixed">CoolBool</code> was <code class="fixed">True</code> or
<code class="fixed">False</code>:
</p>

<pre name="code" class="haskell:hs">
helloMe :: CoolBool -&gt; String
helloMe (CoolBool _) = "hello"
</pre>

<p>
Instead of applying this function to a normal <code class="fixed">CoolBool</code>,
let's throw it a curveball and apply it to <code class="fixed">undefined</code>!
</p>

<pre name="code" class="haskell:hs">
ghci&gt; helloMe undefined
"*** Exception: Prelude.undefined
</pre>

<p>
Yikes! An exception! Now why did this exception happen? Types defined with 
the <i>data</i> keyword can have multiple value constructors (even though
<code class="fixed">CoolBool</code> only has one). So in order to see if the 
value given to our function conforms to the <code class="fixed">(CoolBool _)</code> 
pattern, Haskell has to evaluate the value just enough to see which value 
constructor was used when we made the value. And when we try to evaluate an 
<code class="fixed">undefined</code> value, even a little, an exception is 
thrown.
</p>

<p>
Instead of using the <i>data</i> keyword for <code class="fixed">CoolBool</code>,
let's try using <i>newtype</i>:
</p>

<pre name="code" class="haskell:hs">
newtype CoolBool = CoolBool { getCoolBool :: Bool }
</pre>

<p>
We don't have to change our <code class="fixed">helloMe</code> function, because 
the pattern matching syntax is the same if you use <i>newtype</i> or 
<i>data</i> to define your type. Let's do the same thing here and apply
<code class="fixed">helloMe</code> to an <code class="fixed">undefined</code> 
value:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; helloMe undefined
"hello"
</pre>

<img src="lyah/shamrock.png" alt="top of the mornin to ya!!!" class="right" width="184" height="230">

<p>
It worked! Hmmm, why is that? Well, like we've said, when we use <i>newtype</i>, 
Haskell can internally represent the values of the new type in the same way as the original 
values. It doesn't have to add another box around them, it just has to be aware 
of the values being of different types. And because Haskell knows that types 
made with the <i>newtype</i> keyword can only have one constructor, it doesn't 
have to evaluate the value passed to the function to make sure that it conforms 
to the <code class="fixed">(CoolBool _)</code> pattern because <i>newtype</i> 
types can only have one possible value constructor and one field!
</p>

<p>
This difference in behavior may seem trivial, but it's actually pretty 
important because it helps us realize that even though types defined with 
<i>data</i> and <i>newtype</i> behave similarly from the programmer's point of 
view because they both have value constructors and fields, they are actually two 
different mechanisms. Whereas <i>data</i> can be used to make your own types 
from scratch, <i>newtype</i> is for making a completely new type out of an 
existing type. Pattern matching on <i>newtype</i> values isn't like taking 
something out of a box (like it is with <i>data</i>), it's more about making a 
direct conversion from one type to another.
</p>

<h3><code class="fixed">type</code> vs. <code class="fixed">newtype</code> vs. <code class="fixed">data</code></h3>

<p>
At this point, you may be a bit confused about what exactly the difference
between <i>type</i>, <i>data</i> and <i>newtype</i> is, so let's refresh our 
memory a bit.
</p>

<p>
The <em>type</em> keyword is for making type synonyms. What that means is that 
we just give another name to an already existing type so that the type is easier 
to refer to. Say we did the following:
</p>

<pre name="code" class="haskell:hs">
type IntList = [Int]
</pre>

<p>
All this does is to allow us to refer to the <code class="fixed">[Int]</code> 
type as <code class="fixed">IntList</code>. They can be used interchangeably. 
We don't get an <code class="fixed">IntList</code> value constructor or anything like that.
Because <code class="fixed">[Int]</code> and <code class="fixed">IntList</code> 
are only two ways to refer to the same type, it doesn't matter which name we use
in our type annotations:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; ([1,2,3] :: IntList) ++ ([1,2,3] :: [Int])
[1,2,3,1,2,3]
</pre>

<p>
We use type synonyms when we want to make our type signatures more 
descriptive by giving types names that tell us something about their purpose in 
the context of the functions where they're being used. For instance, when we 
used an association list of type <code class="fixed">[(String,String)]</code> to 
represent a phone book, we gave it the type synonym of 
<code class="fixed">PhoneBook</code> so that the type signatures of our 
functions were easier to read.
</p>

<p>
The <em>newtype</em> keyword is for taking existing types and wrapping them in 
new types, mostly so that it's easier to make them instances of certain type 
classes. When we use <i>newtype</i> to wrap an existing type, the type that we 
get is separate from the original type. If we make the following <i>newtype</i>:
</p>

<pre name="code" class="haskell:hs">
newtype CharList = CharList { getCharList :: [Char] }
</pre>

<p>
We can't use <code class="fixed">++</code> to put together a 
<code class="fixed">CharList</code> and a list of type 
<code class="fixed">[Char]</code>. We can't even use 
<code class="fixed">++</code> to put together two <code class="fixed">CharList</code>s,
because <code class="fixed">++</code> works only on lists and the 
<code class="fixed">CharList</code> type isn't a list, even though it could be 
said that it contains one. We can, however, convert two <code class="fixed">CharList</code>s to
lists, <code class="fixed">++</code> them and then convert that back to a <code class="fixed">CharList</code>.
</p>

<p>
When we use record syntax in our <i>newtype</i> declarations, we get functions 
for converting between the new type and the original type: namely the value 
constructor of our <i>newtype</i> and the function for extracting the value 
in its field. The new type also isn't automatically made an instance of the 
type classes that the original type belongs to, so we have to derive or 
manually write them.
</p>

<p>
In practice, you can think of <i>newtype</i> declarations as <i>data</i> declarations 
that can only have one constructor and one field. If you catch yourself writing 
such a <i>data</i> declaration, consider using <i>newtype</i>.
</p>

<p>
The <em>data</em> keyword is for making your own data types and with them, you 
can go hog wild. They can have as many constructors and fields as you wish and 
can be used to implement any algebraic data type by yourself. Everything from 
lists and <code class="fixed">Maybe</code>-like types to trees.
</p>

<p>
If you just want your type signatures to look cleaner and be more 
descriptive, you probably want type synonyms. If you want to take an existing 
type and wrap it in a new type in order to make it an instance of a type class, 
chances are you're looking for a <i>newtype</i>. And if you want to make 
something completely new, odds are good that you're looking for the <i>data</i> 
keyword.
</p>

<a name="monoids"></a><h2>Monoids</h2>

<img src="lyah/pirateship.png" alt="wow this is pretty much the gayest pirate ship 
ever" class="right" width="460" height="417">

<p>
Type classes in Haskell are used to present an interface for types that have 
some behavior in common. We started out with simple type classes like <span 
class="fixed">Eq</span>, which is for types whose values can be equated, and 
<code class="fixed">Ord</code>, which is for things that can be put in an order 
and then moved on to more interesting ones, like <span 
class="fixed">Functor</span> and <code class="fixed">Applicative</code>. 

<p>
When we make a type, we think about which behaviors it supports, i.e. what it can 
act like and then based on that we decide which type classes to make it an 
instance of. If it makes sense for values of our type to be equated, we make it 
an instance of the <code class="fixed">Eq</code> type class. If we see that our 
type is some kind of functor, we make it an instance of 
<code class="fixed">Functor</code>, and so on.
</p>

<p>
Now consider the following: <code class="fixed">*</code> is a function that 
takes two numbers and multiplies them. If we multiply some number with a <span 
class="fixed">1</span>, the result is always equal to that number. It doesn't 
matter if we do <code class="fixed">1 * x</code> or <span class="fixed">x * 
1</span>, the result is always <code class="fixed">x</code>. Similarly, <span 
class="fixed">++</span> is
also a function which takes two things and returns a third. Only instead of 
multiplying numbers, it takes two lists and concatenates them. And much like
<code class="fixed">*</code>, it also has a certain value which doesn't change 
the other one when used with <code class="fixed">++</code>. That value is the 
empty list: <code class="fixed">[]</code>.
</p>

<pre name="code" class="haskell:hs">
ghci&gt; 4 * 1
4
ghci&gt; 1 * 9
9
ghci&gt; [1,2,3] ++ []
[1,2,3]
ghci&gt; [] ++ [0.5, 2.5]
[0.5,2.5]
</pre>

<p>
It seems that both <code class="fixed">*</code> together with <span 
class="fixed">1</span>
and <code class="fixed">++</code> along with <code class="fixed">[]</code> share 
some common properties:
</p>

<ul>
    <li>The function takes two parameters.</li>
    <li>The parameters and the returned value have the same type.</li>
    <li>There exists such a value that doesn't change other values when used 
    with the binary function.</li>
</ul>

<p>
There's another thing that these two operations have in common that may not be 
as obvious as our previous observations: when we have three or more values and 
we want to use the binary function to reduce them to a single result, the order 
in which we apply the binary function to the values doesn't matter. It doesn't 
matter if we do <code class="fixed">(3 * 4) * 5</code> or <span class="fixed">3 
* (4 * 5)</span>. Either way, the result is <code class="fixed">60</code>. The 
same goes for <code class="fixed">++</code>:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; (3 * 2) * (8 * 5)
240
ghci&gt; 3 * (2 * (8 * 5))
240
ghci&gt; "la" ++ ("di" ++ "da")
"ladida"
ghci&gt; ("la" ++ "di") ++ "da"
"ladida"
</pre>

<p>
We call this property <i>associativity</i>. <code class="fixed">*</code> is 
associative, and so is <code class="fixed">++</code>, but
<code class="fixed">-</code>, for example, is not. The expressions 
<code class="fixed">(5 - 3) - 4</code> and <code class="fixed">5 - (3 - 4)</code>
result in different numbers.
</p>

<p>
By noticing and writing down these properties, we have chanced upon 
<i>monoids</i>! A monoid
is when you have an associative binary function and a value which acts as an 
identity with respect to that function. When something acts as an identity with 
respect to a function, it means that when called with that function and some 
other value, the result is always equal to that other value. <span 
class="fixed">1</span>
is the identity with respect to <code class="fixed">*</code> and <span 
class="fixed">[]</span> is the identity with respect to <span 
class="fixed">++</span>. There are a lot of other monoids to be found in the 
world of Haskell, which is why the <code class="fixed">Monoid</code> type class 
exists. It's for types which can act like monoids. Let's see how the type class 
is defined:
</p>

<pre name="code" class="haskell:hs">
class Monoid m where
    mempty :: m
    mappend :: m -&gt; m -&gt; m
    mconcat :: [m] -&gt; m
    mconcat = foldr mappend mempty
</pre>

<img src="lyah/balloondog.png" alt="woof dee do!!!" class="right" width="260" 
height="326">

<p>
The <code class="fixed">Monoid</code> type class is defined in 
<code class="fixed">import Data.Monoid</code>. Let's take some time and get 
properly acquainted with it.
</p>

<p>
First of all, we see that only concrete types can be made instances of 
<code class="fixed">Monoid</code>, because the <code class="fixed">m</code> in 
the type class definition doesn't take any type parameters. This is different 
from <code class="fixed">Functor</code> and <code class="fixed">Applicative</code>, 
which require their instances to be type constructors which take one parameter.
</p>

<p>
The first function is <code class="fixed">mempty</code>. It's not really a 
function, since it doesn't take parameters, so it's a polymorphic constant, kind 
of like <code class="fixed">minBound</code> from <span 
class="fixed">Bounded</span>.  <code class="fixed">mempty</code> represents the 
identity value for a particular monoid.
</p>

<p>
Next up, we have <code class="fixed">mappend</code>, which, as you've probably 
guessed, is the binary function. It takes two values of the same type and 
returns a value of that type as well. It's worth noting that the decision to 
name
<code class="fixed">mappend</code> as it's named was kind of unfortunate, 
because it implies that we're appending two things in some way. While <span 
class="fixed">++</span> does take two lists and append one to the other, <span 
class="fixed">*</span> doesn't really do any appending, it just multiplies two 
numbers together. When we meet other instances of <span 
class="fixed">Monoid</span>, we'll see that most of them don't append values 
either, so avoid thinking in terms of appending and just think in terms of 
<code class="fixed">mappend</code> being a binary function that takes two monoid 
values and returns a third.
</p>

<p>
The last function in this type class definition is <code class="fixed">mconcat</code>.
It takes a list of monoid values and reduces them to a single value by doing 
<code class="fixed">mappend</code> between the list's elements. It has a default 
implementation, which just takes <code class="fixed">mempty</code> as a starting 
value and folds the list from the right with <code class="fixed">mappend</code>. 
Because the default implementation is fine for most instances, we won't concern 
ourselves with <code class="fixed">mconcat</code> too much from now on. When 
making a type an instance of <code class="fixed">Monoid</code>, it suffices to 
just implement <code class="fixed">mempty</code> and <code class="fixed">mappend</code>.
The reason <code class="fixed">mconcat</code> is there at all is because for 
some instances, there might be a more efficient way to implement
<code class="fixed">mconcat</code>, but for most instances the default 
implementation is just fine.
</p>

<p>
Before moving on to specific instances of <code class="fixed">Monoid</code>, 
let's take a brief look at the monoid laws. We mentioned that there has to be a 
value that acts as the identity with respect to the binary function and that the 
binary function has to be associative. It's possible to make instances of 
<code class="fixed">Monoid</code> that don't follow these rules, but such instances 
are of no use to anyone because when using the <code class="fixed">Monoid</code> 
type class, we rely on its instances acting like monoids. Otherwise, what's the 
point? That's why when making instances, we have to make sure they follow these 
laws:
</p>

<ul>
    <li><code class="label law">mempty `mappend` x = x</code></li>
    <li><code class="label law">x `mappend` mempty = x</code></li>
    <li><span class="label law">(x `mappend` y) `mappend` z = x `mappend` (y 
    `mappend` z)</span></li>
</ul>

<p>
The first two state that <code class="fixed">mempty</code> has to act as the 
identity with respect to <code class="fixed">mappend</code> and the third says 
that <code class="fixed">mappend</code> has to be associative i.e. that it the 
order in which we use <code class="fixed">mappend</code> to reduce several 
monoid values into one doesn't matter. Haskell doesn't enforce these laws, so we 
as the programmer have to be careful that our instances do indeed obey them.
</p>

<h3>Lists are monoids</h3>

<p>
Yes, lists are monoids! Like we've seen, the <code class="fixed">++</code> 
function and the empty list <code class="fixed">[]</code> form a monoid. The 
instance is very simple:
</p>

<pre name="code" class="haskell:hs">
instance Monoid [a] where
    mempty = []
    mappend = (++)
</pre>

<p>
Lists are an instance of the <code class="fixed">Monoid</code> type class 
regardless of the type of the elements they hold.
Notice that we wrote <code class="fixed">instance Monoid [a]</code> and not 
<code class="fixed">instance Monoid []</code>, because <span 
class="fixed">Monoid</span>
requires a concrete type for an instance. 
</p>

<p>
Giving this a test run, we encounter no surprises:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; [1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]
ghci&gt; ("one" `mappend` "two") `mappend` "tree"
"onetwotree"
ghci&gt; "one" `mappend` ("two" `mappend` "tree")
"onetwotree"
ghci&gt; "one" `mappend` "two" `mappend` "tree"
"onetwotree"
ghci&gt; "pang" `mappend` mempty
"pang"
ghci&gt; mconcat [[1,2],[3,6],[9]]
[1,2,3,6,9]
ghci&gt; mempty :: [a]
[]
</pre>

<img src="lyah/smug.png" alt="smug as hell" class="left" width="157" height="144">

<p>
Notice that in the last line, we had to write an explicit type annotation, 
because if we just did <code class="fixed">mempty</code>, GHCi wouldn't know 
which instance to use, so we had to say we want the list instance. We were able 
to use the general type of <code class="fixed">[a]</code> (as opposed to 
specifying <code class="fixed">[Int]</code> or <code class="fixed">[String]</code>)
because the empty list can act as if it contains any type.
</p>

<p>
Because <code class="fixed">mconcat</code> has a default implementation, we get 
it for free when we make something an instance of <code class="fixed">Monoid</code>. 
In the case of the list, <code class="fixed">mconcat</code> turns out to be just 
<code class="fixed">concat</code>. It takes a list of lists and flattens it, 
because that's the equivalent of doing <code class="fixed">++</code> between all 
the adjecent lists in a list.
</p>

<p>
The monoid laws do indeed hold for the list instance. When we have several lists 
and we <code class="fixed">mappend</code> (or <code class="fixed">++</code>) 
them together, it doesn't matter which ones we do first, because they're just 
joined at the ends anyway. Also, the empty list acts as the identity so all is well.
Notice that monoids don't require that <code class="fixed">a `mappend` b</code> 
be equal to <code class="fixed">b `mappend` a</code>. In the case of the list, 
they clearly aren't:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; "one" `mappend` "two"
"onetwo"
ghci&gt; "two" `mappend` "one"
"twoone"
</pre>

<p>
And that's okay. The fact that for multiplication <code class="fixed">3 * 5</code> and
<code class="fixed">5 * 3</code> are the same is just a property of 
multiplication, but it doesn't hold for all (and indeed, most) monoids.
</p>

<h3><code class="fixed">Product</code> and <code class="fixed">Sum</code></h3>

<p>
We already examined one way for numbers to be considered monoids. Just have the 
binary function be <code class="fixed">*</code> and the identity value 
<code class="fixed">1</code>. It turns out that that's not the only way for 
numbers to be monoids. Another way is to have the binary function be 
<code class="fixed">+</code> and the identity value <code class="fixed">0</code>:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; 0 + 4
4
ghci&gt; 5 + 0
5
ghci&gt; (1 + 3) + 5
9
ghci&gt; 1 + (3 + 5)
9
</pre>

<p>
The monoid laws hold, because if you add 0 to any number, the result is that 
number. And addition is also associative, so we get no problems there. So now 
that there are two equally valid ways for numbers to be monoids, which way do 
choose? Well, we don't have to. Remember, when there are several ways for some 
type to be an instance of the same type class, we can wrap that type in a 
<i>newtype</i> and then make the new type an instance of the 
type class in a different way. We can have our cake and eat it too.
</p>

<p>
The <code class="fixed">Data.Monoid</code> module exports two types for this, 
namely <code class="fixed">Product</code> and <code class="fixed">Sum</code>. 
<code class="fixed">Product</code> is defined like this:
</p>

<pre name="code" class="haskell:hs">
newtype Product a =  Product { getProduct :: a }
    deriving (Eq, Ord, Read, Show, Bounded)
</pre>

<p>
Simple, just a <i>newtype</i> wrapper with one type parameter along with some 
derived instances. Its instance for <code class="fixed">Monoid</code> goes a 
little something like this:
</p>

<pre name="code" class="haskell:hs">
instance Num a =&gt; Monoid (Product a) where
    mempty = Product 1
    Product x `mappend` Product y = Product (x * y)
</pre>

<p>
<code class="fixed">mempty</code> is just <code class="fixed">1</code> wrapped 
in a <code class="fixed">Product</code> constructor. <code class="fixed">mappend</code> 
pattern matches on the <code class="fixed">Product</code> constructor, 
multiplies the two numbers and then wraps the resulting number back. As you can 
see, there's a <code class="fixed">Num a</code> class constraint. So this means that
<code class="fixed">Product a</code> is an instance of <code class="fixed">Monoid</code> for all
<code class="fixed">a</code>'s that are already an instance of <code class="fixed">Num</code>.
To use <code class="fixed">Producta a</code> as a monoid, we have to do some 
<i>newtype</i> wrapping and unwrapping:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getProduct $ Product 3 `mappend` Product 9
27
ghci&gt; getProduct $ Product 3 `mappend` mempty
3
ghci&gt; getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2
24
ghci&gt; getProduct . mconcat . map Product $ [3,4,2]
24
</pre>

<p>
This is nice as a showcase of the <code class="fixed">Monoid</code> type class, 
but no one in their right mind would use this way of multiplying numbers instead 
of just writing <code class="fixed">3 * 9</code> and <code class="fixed">3 * 1</code>.
But a bit later, we'll see how these <code class="fixed">Monoid</code> instances 
that may seem trivial at this time can come in handy.
</p>

<p>
<code class="fixed">Sum</code> is defined like <code class="fixed">Product</code> and the
instance is similar as well. We use it in the same way:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getSum $ Sum 2 `mappend` Sum 9
11
ghci&gt; getSum $ mempty `mappend` Sum 3
3
ghci&gt; getSum . mconcat . map Sum $ [1,2,3]
6
</pre>

<h3><code class="fixed">Any</code> and <code class="fixed">All</code></h3>

<p>
Another type which can act like a monoid in two distinct but equally valid ways 
is <code class="fixed">Bool</code>. The first way is to have the <i>or</i> 
function <code class="fixed">||</code> act as the binary function along with 
<code class="fixed">False</code> as the identity value. The way <i>or</i> works 
in logic is that if any of its two parameters is <code class="fixed">True</code>,
it returns <code class="fixed">True</code>, otherwise it returns 
<code class="fixed">False</code>. So if we use <code class="fixed">False</code> 
as the identity value, it will return <code class="fixed">False</code> when 
<i>or</i>-ed with <code class="fixed">False</code> and <code class="fixed">True</code>
when <i>or</i>-ed with <code class="fixed">True</code>. The <code class="fixed">Any</code>
<i>newtype</i> constructor is an instance of <code class="fixed">Monoid</code> 
in this fashion. It's defined like this:
</p>

<pre name="code" class="haskell:hs">
newtype Any = Any { getAny :: Bool }
    deriving (Eq, Ord, Read, Show, Bounded)
</pre>

<p>
Its instance looks goes like so:
</p>

<pre name="code" class="haskell:hs">
instance Monoid Any where
        mempty = Any False
        Any x `mappend` Any y = Any (x || y)
</pre>

<p>
The reason it's called <code class="fixed">Any</code> is because
<code class="fixed">x `mappend` y</code> will be <code class="fixed">True</code>
if <i>any</i> one of those two is <code class="fixed">True</code>. Even
if three or more <code class="fixed">Any</code> wrapped <code class="fixed">Bool</code>s
are <code class="fixed">mappend</code>ed together, the result will hold
<code class="fixed">True</code> if any of them are <code class="fixed">True</code>:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getAny $ Any True `mappend` Any False
True
ghci&gt; getAny $ mempty `mappend` Any True
True
ghci&gt; getAny . mconcat . map Any $ [False, False, False, True]
True
ghci&gt; getAny $ mempty `mappend` mempty
False
</pre>

<p>
The other way for <code class="fixed">Bool</code> to be an instance of
<code class="fixed">Monoid</code> is to kind of do the opposite: have <code class="fixed">&&</code> 
be the binary function and then make <code class="fixed">True</code>
the identity value. Logical <i>and</i> will return <code class="fixed">True</code> only
if both of its parameters are <code class="fixed">True</code>. This is the <i>newtype</i>
declaration, nothing fancy:
</p>

<pre name="code" class="haskell:hs">
newtype All = All { getAll :: Bool }
        deriving (Eq, Ord, Read, Show, Bounded)
</pre>

<p>
And this is the instance:
</p>

<pre name="code" class="haskell:hs">
instance Monoid All where
        mempty = All True
        All x `mappend` All y = All (x && y)
</pre>

<p>
When we <code class="fixed">mappend</code> values of the 
<code class="fixed">All</code> type, the result will be
<code class="fixed">True</code> only if <i>all</i> the values
used in the <code class="fixed">mappend</code> operations are
<code class="fixed">True</code>:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getAll $ mempty `mappend` All True
True
ghci&gt; getAll $ mempty `mappend` All False
False
ghci&gt; getAll . mconcat . map All $ [True, True, True]
True
ghci&gt; getAll . mconcat . map All $ [True, True, False]
False
</pre>

<p>
Just like with multiplication and addition, we usually explicitly state the 
binary functions instead of wrapping them in <i>newtype</i>s and then using
<code class="fixed">mappend</code> and <code class="fixed">mempty</code>.
<code class="fixed">mconcat</code> seems useful for <code class="fixed">Any</code>
and <code class="fixed">All</code>, but usually it's easier to use the 
<code class="fixed">or</code> and <code class="fixed">and</code> functions,
which take lists of <code class="fixed">Bool</code>s and return 
<code class="fixed">True</code> if any of them are <code class="fixed">True</code> or
if all of them are <code class="fixed">True</code>, respectively.
</p>

<h3>The <code class="fixed">Ordering</code> monoid</h3>

<p>
Hey, remember the <code class="fixed">Ordering</code> type? It's used as the 
result when comparing things and it can have three values: <code class="fixed">LT</code>,
<code class="fixed">EQ</code> and <code class="fixed">GT</code>, which stand for
<i>less than</i>, <i>equal</i> and <i>greater than</i> respectively:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; 1 `compare` 2
LT
ghci&gt; 2 `compare` 2
EQ
ghci&gt; 3 `compare` 2
GT
</pre>

<p>
With lists, numbers and boolean values, finding monoids was just a matter of
looking at already existing commonly used functions and seeing if they exhibit
some sort of monoid behavior. With <code class="fixed">Ordering</code>, we have
to look a bit harder to recognize a monoid, but it turns out that its
<code class="fixed">Monoid</code> instance is just as intuitive as the ones
we've met so far and also quite useful:
</p>

<pre name="code" class="haskell:hs">
instance Monoid Ordering where
    mempty = EQ
    LT `mappend` _ = LT
    EQ `mappend` y = y
    GT `mappend` _ = GT
</pre>

<img src="lyah/bear.png" alt="did anyone ORDER pizza?!?! I can't BEAR these puns!" class="right" width="330" height="339">

<p>
The instance is set up like this: when we <code class="fixed">mappend</code> two
<code class="fixed">Ordering</code> values, the one on the left is kept, unless
the value on the left is <code class="fixed">EQ</code>, in which case the right
one is the result. The identity is <code class="fixed">EQ</code>. At first, this
may seem kind of arbitrary, but it actually resembles the way we alphabetically
compare words. We compare the first two letters and if they differ, we can
already decide which word would go first in a dictionary. However, if the first two
letters are equal, then we move on to comparing the next pair of letters and
repeat the process. 
</p>

<p>
For instance, if we were to alphabetically compare the words
<code class="fixed">"ox"</code> and <code class="fixed">"on"</code>, we'd first
compare the first two letters of each word, see that they are equal and then
move on to comparing the second letter of each word. We see that <span
class="fixed">'x'</span> is alphabetically greater than <span
class="fixed">'n'</span>, and so we know how the words compare. To gain some
intuition for <code class="fixed">EQ</code> being the identity, we can notice
that if we were to cram the same letter in the same position in both words, it
wouldn't change their alphabetical ordering. <code class="fixed">"oix"</code> is
still alphabetically greater than and <code class="fixed">"oin"</code>.
</p>

<p>
It's important to note that in the <code class="fixed">Monoid</code> instance
for <code class="fixed">Ordering</code>, <code class="fixed">x `mappend` y</code> 
doesn't equal <code class="fixed">y `mappend` x</code>. Because the first
parameter is kept unless it's <code class="fixed">EQ</code>, <span
class="fixed">LT `mappend` GT</span> will result in <span
class="fixed">LT</span>, whereas <code class="fixed">GT `mappend` LT</code> will
result in <code class="fixed">GT</code>:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; LT `mappend` GT
LT
ghci&gt; GT `mappend` LT
GT
ghci&gt; mempty `mappend` LT
LT
ghci&gt; mempty `mappend` GT
GT
</pre>

<p>
OK, so how is this monoid useful? Let's say you were writing a function that
takes two strings, compares their lengths, and returns an <span
class="fixed">Ordering</span>. But if the strings are of the same length, then
instead of returning <code class="fixed">EQ</code> right away, we want to
compare them alphabetically. One way to write this would be like so:
</p>

<pre name="code" class="haskell:hs">
lengthCompare :: String -&gt; String -&gt; Ordering
lengthCompare x y = let a = length x `compare` length y 
                        b = x `compare` y
                    in  if a == EQ then b else a
</pre>

<p>
We name the result of comparing the lengths <code class="fixed">a</code> and the
result of the alphabetical comparison <code class="fixed">b</code> and then if
it turns out that the lengths were equal, we return their alphabetical ordering.
</p>

<p>
But by employing our understanding of how <code class="fixed">Ordering</code> is
a monoid, we can rewrite this function in a much simpler manner:
</p>

<pre name="code" class="haskell:hs">
import Data.Monoid

lengthCompare :: String -&gt; String -&gt; Ordering
lengthCompare x y = (length x `compare` length y) `mappend`
                    (x `compare` y)
</pre>

<p>
We can try this out:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; lengthCompare "zen" "ants"
LT
ghci&gt; lengthCompare "zen" "ant"
GT
</pre>

<p>
Remember, when we use <code class="fixed">mappend</code>, its left parameter is
always kept unless it's <code class="fixed">EQ</code>, in which case the right
one is kept. That's why we put the comparison that we consider to be the first,
more important criterion as the first parameter. If we wanted to expand this
function to also compare for the number of vowels and set this to be the second
most important criterion for comparison, we'd just modify it like this:
</p>

<pre name="code" class="haskell:hs">
import Data.Monoid

lengthCompare :: String -&gt; String -&gt; Ordering
lengthCompare x y = (length x `compare` length y) `mappend`
                    (vowels x `compare` vowels y) `mappend`
                    (x `compare` y)
    where vowels = length . filter (`elem` "aeiou")
</pre>

<p>
We made a helper function, which takes a string and tells us how many vowels it
has by first filtering it only for letters that are in the string <span
class="fixed">"aeiou"</span> and then applying <code class="fixed">length</code>
to that.
</p>

<pre name="code" class="haskell:hs">
ghci&gt; lengthCompare "zen" "anna"
LT
ghci&gt; lengthCompare "zen" "ana"
LT
ghci&gt; lengthCompare "zen" "ann"
GT
</pre>

<p>
Very cool. Here, we see how in the first example the lengths are found to be 
different and so <code class="fixed">LT</code> is returned, because the length 
of <code class="fixed">"zen"</code> is less than the length of 
<code class="fixed">"anna"</code>. In the second example, the lengths are the 
same, but the second string has more vowels, so <code class="fixed">LT</code> is 
returned again. In the third example, they both have the same length and the 
same number of vowels, so they're compared alphabetically and
<code class="fixed">"zen"</code> wins.
</p>

<p>
The <code class="fixed">Ordering</code> monoid is very cool because it allows us 
to easily compare things by many different criteria and put those criteria in an 
order themselves, ranging from the most important to the least.
</p>

<h3><code class="fixed">Maybe</code> the monoid</h3>

<p>
Let's take a look at the various ways that <code class="fixed">Maybe a</code>
can be made an instance of <code class="fixed">Monoid</code> and what those 
instances are useful for.
</p>

<p>
One way is to treat <code class="fixed">Maybe a</code> as a monoid only if 
its type parameter <code class="fixed">a</code> is a monoid as well and then 
implement <code class="fixed">mappend</code> in such a way that it uses the
<code class="fixed">mappend</code> operation of the values that are wrapped 
with <code class="fixed">Just</code>. We use <code class="fixed">Nothing</code>
as the identity, and so if one of the two values that we're 
<code class="fixed">mappend</code>ing is <code class="fixed">Nothing</code>, we 
keep the other value. Here's the instance declaration:
</p>

<pre name="code" class="haskell:hs">
instance Monoid a =&gt; Monoid (Maybe a) where
    mempty = Nothing
    Nothing `mappend` m = m
    m `mappend` Nothing = m
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
</pre>

<p>
Notice the class constraint. It says that <code class="fixed">Maybe a</code> is 
an instance of <code class="fixed">Monoid</code> only if <span 
class="fixed">a</span> is an instance of <code class="fixed">Monoid</code>.
If we <code class="fixed">mappend</code> something with a <span 
class="fixed">Nothing</span>,
the result is that something. If we <code class="fixed">mappend</code> two <span 
class="fixed">Just</span> values, the contents of the <span 
class="fixed">Just</span>s get
<code class="fixed">mappended</code> and then wrapped back in a <span 
class="fixed">Just</span>. We can do this because the class constraint ensures 
that the type of what's inside the <code class="fixed">Just</code> is an 
instance of <code class="fixed">Monoid</code>.
</p>

<pre name="code" class="haskell:hs">
ghci&gt; Nothing `mappend` Just "andy"
Just "andy"
ghci&gt; Just LT `mappend` Nothing
Just LT
ghci&gt; Just (Sum 3) `mappend` Just (Sum 4)
Just (Sum {getSum = 7})
</pre>

<p>
This comes in use when you're dealing with monoids as results of computations 
that may have failed. Because of this instance, we don't have to check if the 
computations have failed by seeing if they're a <code class="fixed">Nothing</code> or
<code class="fixed">Just</code> value; we can just continue to treat them as 
normal monoids.
</p>

<p>
But what if the type of the contents of the <code class="fixed">Maybe</code> 
aren't an instance of <code class="fixed">Monoid</code>? Notice that in the 
previous instance declaration, the only case where we have to rely on the 
contents being monoids is when both parameters of <code class="fixed">mappend</code>
are <code class="fixed">Just</code> values. But if we don't know if the contents
are monoids, we can't use <code class="fixed">mappend</code> between them, so 
what are we to do? Well, one thing we can do is to just discard the second value 
and keep the first one. For this, the <code class="fixed">First a</code> 
type exists and this is its definition:
</p>

<pre name="code" class="haskell:hs">
newtype First a = First { getFirst :: Maybe a }
    deriving (Eq, Ord, Read, Show)
</pre>

<p>
We take a <code class="fixed">Maybe a</code> and we wrap it with a
<i>newtype</i>. The <code class="fixed">Monoid</code> instance is as follows:
</p>

<pre name="code" class="haskell:hs">
instance Monoid (First a) where
    mempty = First Nothing
    First (Just x) `mappend` _ = First (Just x)
    First Nothing `mappend` x = x
</pre>

<p>
Just like we said. <code class="fixed">mempty</code> is just a 
<code class="fixed">Nothing</code> wrapped with the <code class="fixed">First</code>
<i>newtype</i> constructor. If <code class="fixed">mappend</code>'s first 
parameter is a <code class="fixed">Just</code> value, we ignore the second one. 
If the first one is a <code class="fixed">Nothing</code>, then we present the 
second parameter as a result, regardless of whether it's a <code class="fixed">Just</code>
or a <code class="fixed">Nothing</code>:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getFirst $ First (Just 'a') `mappend` First (Just 'b')
Just 'a'
ghci&gt; getFirst $ First Nothing `mappend` First (Just 'b')
Just 'b'
ghci&gt; getFirst $ First (Just 'a') `mappend` First Nothing
Just 'a'
</pre>

<p>
<code class="fixed">First</code> is useful when we have a bunch of <span 
class="fixed">Maybe</span> values
and we just want to know if any of them is a <code class="fixed">Just</code>. 
The <code class="fixed">mconcat</code> function comes in handy:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]
Just 9
</pre>

<p>
If we want a monoid on <code class="fixed">Maybe a</code> such that the second 
parameter is kept if both parameters of <code class="fixed">mappend</code> are 
<code class="fixed">Just</code> values, <code class="fixed">Data.Monoid</code>
provides a the <code class="fixed">Last a</code> type, which works like <span 
class="fixed">First a</span>, only the last non-<span 
class="fixed">Nothing</span>
value is kept when <code class="fixed">mappend</code>ing and using <span 
class="fixed">mconcat</span>:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]
Just 10
ghci&gt; getLast $ Last (Just "one") `mappend` Last (Just "two")
Just "two"
</pre>

<h3>Using monoids to fold data structures</h3>

<p>
One of the more interesting ways to put monoids to work is to make them help us 
define folds over various data structures. So far, we've only done folds over 
lists, but lists aren't the only data structure that can be folded over. We can 
define folds over almost any data structure. Trees especially lend themselves well 
to folding.
</p>

<p>
Because there are so many data structures that work nicely with folds, the
<code class="label class">Foldable</code> type class was introduced. Much like 
<code class="fixed">Functor</code> is for things that can be mapped over,
<code class="fixed">Foldable</code> is for things that can be folded up! It can 
be found in <code class="fixed">Data.Foldable</code> and because it export 
functions whose names clash with the ones from the <code class="fixed">Prelude</code>,
it's best imported qualified (and served with basil):
</p>

<pre name="code" class="haskell:hs">
import qualified Foldable as F
</pre>

<p>
To save ourselves precious keystrokes, we've chosen to import it qualified as 
<code class="fixed">F</code>. Alright, so what are some of the functions that 
this type class defines? Well, among them are <code class="fixed">foldr</code>, 
<code class="fixed">foldl</code>, <code class="fixed">foldr1</code> and <code class="fixed">foldl1</code>.
Huh? But we already know these functions, what's so new about this? Let's 
compare the types of <code class="fixed">Foldable</code>'s <code class="fixed">foldr</code> and
the <code class="fixed">foldr</code> from the <code class="fixed">Prelude</code> 
to see how they differ:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; :t foldr
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
ghci&gt; :t F.foldr
F.foldr :: (F.Foldable t) =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</pre>

<p>
Ah! So whereas <code class="fixed">foldr</code> takes a list and folds it up, 
the <code class="fixed">foldr</code> from
<code class="fixed">Data.Foldable</code> accepts any type that can be folded up, 
not just lists! As expected, both <code class="fixed">foldr</code> functions do 
the same for lists:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; foldr (*) 1 [1,2,3]
6
ghci&gt; F.foldr (*) 1 [1,2,3]
6
</pre>

<p>
Okay then, what are some other data structures that support folds? Well, there's
the <code class="fixed">Maybe</code> we all know and love!
</p>

<pre name="code" class="haskell:hs">
ghci&gt; F.foldl (+) 2 (Just 9)
11
ghci&gt; F.foldr (||) False (Just True)
True
</pre>

<p>
But folding over a <code class="fixed">Maybe</code> value isn't terribly 
interesting, because when it comes to folding, it just acts like a list with one 
element if it's a <code class="fixed">Just</code> value and as an empty list if 
it's <code class="fixed">Nothing</code>. So let's examine a data structure 
that's a little more complex then.
</p>

<p>
Remember the tree data structure from the <a 
href="making-our-own-types-and-typeclasses.html#recursive-data-structures">Making Our 
Own Types and Typeclasses</a> chapter? We defined it like this:
</p>

<pre name="code" class="haskell:hs">
data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
</pre>

<p>
We said that a tree is either an empty tree that doesn't hold any values or it's a node that 
holds one value and also two other trees. After defining it, we made it an 
instance of <code class="fixed">Functor</code> and with that we gained the 
ability to <code class="fixed">fmap</code> functions over it. Now, we're going 
to make it an instance of <code class="fixed">Foldable</code> so that we get the 
abilty to fold it up. One way to make a type constructor an instance of 
<code class="fixed">Foldable</code> is to just directly implement <code class="fixed">foldr</code> for it. 
But another, often much easier way, is to implement the <code class="fixed">foldMap</code> function, 
which is also a part of the <code class="fixed">Foldable</code> type class. The 
<code class="fixed">foldMap</code> function has the following type:
</p>

<pre name="code" class="haskell:hs">
foldMap :: (Monoid m, Foldable t) =&gt; (a -&gt; m) -&gt; t a -&gt; m
</pre>

<p>
Its first parameter is a function that takes a value of the type that 
our foldable structure contains (denoted here with <code class="fixed">a</code>) 
and returns a monoid value. Its second parameter is a foldable structure that 
contains values of type <code class="fixed">a</code>. It maps that function over 
the foldable structure, thus producing a foldable structure that contains 
monoid values. Then, by doing <code class="fixed">mappend</code> between those 
monoid values, it joins them all into a single monoid value. This function 
may sound kind of odd at the moment, but we'll see that it's very easy to 
implement. What's also cool is that implementing this function is all it takes for 
our type to be made an instance of <code class="fixed">Foldable</code>. So if we 
just implement <code class="fixed">foldMap</code> for some type, we get 
<code class="fixed">foldr</code> and <code class="fixed">foldl</code> on that 
type for free!
</p>

<p>
This is how we make <code class="fixed">Tree</code> an instance of 
<code class="fixed">Foldable</code>:
</p>

<pre name="code" class="haskell:hs">
instance F.Foldable Tree where
    foldMap f Empty = mempty
    foldMap f (Node x l r) = F.foldMap f l `mappend`
                             f x           `mappend`
                             F.foldMap f r
</pre>

<img src="lyah/accordion.png" alt="find the visual pun or whatever" class="right" width="366" height="280">

<p>
We think like this: if we are provided with a function that takes an element of 
our tree and returns a monoid value, how do we reduce our whole tree down to one 
single monoid value? When we were doing <code class="fixed">fmap</code> over our tree,
we applied the function that we were mapping to a node and then we recursively 
mapped the function over the left sub-tree as well as the right one. Here, we're 
tasked with not only mapping a function, but with also joining up the results 
into a single monoid value by using <code class="fixed">mappend</code>. First we 
consider the case of the empty tree &mdash; a sad and lonely tree that has no 
values or sub-trees. It doesn't hold any value that we can give to our monoid-making
function, so we just say that if our tree is empty, the monoid value it becomes 
is <code class="fixed">mempty</code>.
</p>

<p>
The case of a non-empty node is a bit more interesting. It contains two 
sub-trees as well as a value. In this case, we recursively <code class="fixed">foldMap</code> the
same function <code class="fixed">f</code> over the left and the right 
sub-trees. Remember, our <code class="fixed">foldMap</code> results in a single 
monoid value. We also apply our function <code class="fixed">f</code> to the 
value in the node. Now we have three monoid values (two from our sub-trees and 
one from applying <code class="fixed">f</code> to the value in the node) and we 
just have to bang them together into a single value. For this purpose we use
<code class="fixed">mappend</code>, and naturally the left sub-tree comes first, 
then the node value and then the right sub-tree.
</p>

<p>
Notice that we didn't have to provide the function that takes a value and 
returns a monoid value. We receive that function as a parameter to <code class="fixed">foldMap</code>
and all we have to decide is where to apply that function and how to join up
the resulting monoids from it.
</p>

<p>
Now that we have a <code class="fixed">Foldable</code> instance for our tree 
type, we get <code class="fixed">foldr</code> and <code class="fixed">foldl</code> for free!
Consider this tree:
</p>

<pre name="code" class="haskell:hs">
testTree = Node 5
            (Node 3
                (Node 1 Empty Empty)
                (Node 6 Empty Empty)
            )
            (Node 9
                (Node 8 Empty Empty)
                (Node 10 Empty Empty)
            )
</pre>

<p>
It has <code class="fixed">5</code> at its root and then its left node is has 
<code class="fixed">3</code> with <code class="fixed">1</code> on the left and 
<code class="fixed">6</code> on the right. The root's right node has a <span 
class="fixed">9</span>
and then an <code class="fixed">8</code> to its left and a <span 
class="fixed">10</span> on the far right side. With a <code class="fixed">Foldable</code> instance,
we can do all of the folds that we can do on lists:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; F.foldl (+) 0 testTree
42
ghci&gt; F.foldl (*) 1 testTree
64800
</pre>

<p>
And also, <code class="fixed">foldMap</code> isn't only useful for making new instances of
<code class="fixed">Foldable</code>; it comes in handy for reducing our 
structure to a single monoid value. For instance, if we want to know if any number in our 
tree is equal to <code class="fixed">3</code>, we can do this:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getAny $ F.foldMap (\x -&gt; Any $ x == 3) testTree
True
</pre>

<p>
Here, <code class="fixed">\x -&gt; Any $ x == 3</code> is a function that takes 
a number and returns a monoid value, namely a <code class="fixed">Bool</code> 
wrapped in <code class="fixed">Any</code>. <code class="fixed">foldMap</code> 
applies this function to every element in our tree and then reduces the 
resulting monoids into a single monoid with <code class="fixed">mappend</code>.
If we do this:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getAny $ F.foldMap (\x -&gt; Any $ x &gt; 15) testTree
False
</pre>

<p>
All of the nodes in our tree would hold the value <span class="fixed">Any 
False</span> after having the function in the lambda applied to them. But to end 
up <code class="fixed">True</code>,
<code class="fixed">mappend</code> for <code class="fixed">Any</code> has to 
have at least one <code class="fixed">True</code> value as a parameter. That's 
why the final result is <code class="fixed">False</code>, which makes sense 
because no value in our tree is greater than <code class="fixed">15</code>.
</p>

<p>
We can also easily turn our tree into a list by doing a 
<code class="fixed">foldMap</code> with the <code class="fixed">\x -&gt; [x]</code>
function. By first projecting that function onto our tree, each element becomes 
a singleton list. The <code class="fixed">mappend</code> action that takes place 
between all those singleton list results in a single list that holds all of the 
elements that are in our tree:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; F.foldMap (\x -&gt; [x]) testTree
[1,3,6,5,8,9,10]
</pre>

<p>
What's cool is that all of these trick aren't limited to trees, they work on any 
instance of <code class="fixed">Foldable</code>.
</p>
                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                                        <a href="functionally-solving-problems.html" class="prevlink">Functionally Solving Problems</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters.html">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="a-fistful-of-monads.html" class="nxtlink">A Fistful of Monads</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="shBrushHaskell.js"></script>
    <script type="text/javascript" src="shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = 'sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script>
</body>

<!-- Mirrored from learnyouahaskell.com/functors-applicative-functors-and-monoids by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 19 Nov 2013 17:20:28 GMT -->
</html>
