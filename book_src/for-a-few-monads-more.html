<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!-- Mirrored from learnyouahaskell.com/for-a-few-monads-more by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 19 Nov 2013 17:20:34 GMT -->
<head>
<title>For a Few Monads More - Learn You a Haskell for Great Good!</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<base >
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="favicon.png" type="image/png">
        <link rel="prev" href="a-fistful-of-monads.html">
        <link rel="next" href="zippers.html">
<link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
<link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
</head>
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                                        <a href="a-fistful-of-monads.html" class="prevlink">A Fistful of Monads</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters.html">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="zippers.html" class="nxtlink">Zippers</a>
                                            </li>
                </ul>
            </div>
        <h1>For a Few Monads More</h1>

<img src="lyah/clint.png" alt="there are two kinds of people in the world, my friend. those who learn them a haskell and those who have the job of coding java" class="right" width="189" height="400">

<p>
We've seen how monads can be used to take values with contexts and apply them to 
functions and how using <code class="fixed">&gt;&gt;=</code> or <span 
class="fixed">do</span> notation allows us to focus on the values themselves while the
context gets handled for us. 
</p>

<p>
We've met the <code class="fixed">Maybe</code> monad and seen how it adds a 
context of possible failure to values. We've learned about the list monad and 
saw how it lets us easily introduce non-determinism into our programs. We've also 
learned how to work in the <code class="fixed">IO</code> monad, even before we 
knew what a monad was!

<p>
In this chapter, we're going to learn about a few other monads. We'll see how 
they can make our programs clearer by letting us treat all sorts of values as 
monadic ones. Exploring a few monads more will also solidify our intuition for 
monads.
</p>

<p>
The monads that we'll be exploring are all part of the <code class="fixed">mtl</code> 
package. A Haskell package is a collection of modules. The <span 
class="fixed">mtl</span> package comes with the Haskell Platform, so you 
probably already have it. To check if you do, type <span 
class="fixed">ghc-pkg list</span> in the command-line. This will show which 
Haskell packages you have installed and one of them should be <span 
class="fixed">mtl</span>, followed by a version number.
</p>

<a name="writer"></a>
<h2>Writer? I hardly know her!</h2>

<p>
We've loaded our gun with the <code class="fixed">Maybe</code> monad, the list 
monad and the <code class="fixed">IO</code> monad. Now let's put the <span 
class="fixed">Writer</span> monad in the chamber and see what happens when we 
fire it!
</p>

<p>
Whereas <code class="fixed">Maybe</code> is for values with an added context of 
failure and the list is for non-deterministic values, the <span 
class="fixed">Writer</span> monad is for values that have another value attached 
that acts as a sort of log value. <code class="fixed">Writer</code> allows us to 
do computations while making sure that all the log values are combined into one 
log value that then gets attached to the result.
</p>

<p>
For instance, we might want to equip our values with strings that explain what's 
going on, probably for debugging purposes. Consider a function that takes a 
number of bandits in a gang and tells us if that's a big gang or not. That's a 
very simple function:
</p>

<pre name="code" class="haskell:hs">
isBigGang :: Int -&gt; Bool
isBigGang x = x &gt; 9
</pre>

<p>
Now, what if instead of just giving us a <code class="fixed">True</code> or
<code class="fixed">False</code> value, we want it to also return a log string 
that says what it did? Well, we just make that string and return it along side 
our <code class="fixed">Bool</code>:
</p>

<pre name="code" class="haskell:hs">
isBigGang :: Int -&gt; (Bool, String)
isBigGang x = (x &gt; 9, "Compared gang size to 9.")
</pre>

<p>
So now instead of just returning a <code class="fixed">Bool</code>, we return a 
tuple where the first component of the tuple is the actual value and the second 
component is the string that accompanies that value. There's some added context 
to our value now. Let's give this a go:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; isBigGang 3
(False,"Compared gang size to 9.")
ghci&gt; isBigGang 30
(True,"Compared gang size to 9.")
</pre>

<img src="lyah/tuco.png" alt="when you have to poop, poop, don't talk" class="left" 
width="196" height="280">

<p>
So far so good. <code class="fixed">isBigGang</code> takes a normal value and 
returns a value with a context. As we've just seen, feeding it a normal value is 
not a problem. Now what if we already have a value that has a log string 
attached to it, such as <code class="fixed">(3, "Smallish gang.")</code>, 
and we want to feed it to <code class="fixed">isBigGang</code>? It seems like 
once again, we're faced with this question: if we have a function that takes a 
normal value and returns a value with a context, how do we take a value with a 
context and feed it to the function?
</p>

<p>
When we were exploring the <code class="fixed">Maybe</code> monad, we made a 
function <code class="fixed">applyMaybe</code>, which took a <span 
class="fixed">Maybe a</span> value and a function of type <code class="fixed">a -&gt; Maybe b</code> 
and fed that <code class="fixed">Maybe a</code> value into the function, even 
though the function takes a normal <code class="fixed">a</code> instead of a <span class="fixed">Maybe 
a</span>. It did this by minding the context that comes with <span 
class="fixed">Maybe a</span> values, which is that they are values with possible 
failure. But inside the <code class="fixed">a -&gt; Maybe b</code> function, we 
were able to treat that value as just a normal value, because <span 
class="fixed">applyMaybe</span> (which later became <code class="fixed">&gt;&gt;=</code>) 
took care of checking if it was a <code class="fixed">Nothing</code> or a <span 
class="fixed">Just</span> value.
</p>

<p>
In the same vein, let's make a function that takes a value with an attached log, 
that is, an <code class="fixed">(a,String)</code> value and a function of type 
<code class="fixed">a -&gt; (b,String)</code> and feeds that value into the 
function. We'll call it <code class="fixed">applyLog</code>. But because an 
<code class="fixed">(a,String)</code> value doesn't carry with it a context of 
possible failure, but rather a context of an additional log value, <span 
class="fixed">applyLog</span> is going to make sure that the log of the original 
value isn't lost, but is joined together with the log of the value that results 
from the function. Here's the implementation of <code class="fixed">applyLog</code>:
</p>

<pre name="code" class="haskell:hs">
applyLog :: (a,String) -&gt; (a -&gt; (b,String)) -&gt; (b,String)
applyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog)
</pre>

<p>
When we have a value with a context and we want to feed it to a function, we 
usually try to separate the actual value from the context and then try to apply 
the function to the value and then see that the context is taken care of. In the 
<code class="fixed">Maybe</code> monad, we checked if the value was a <span 
class="fixed">Just x</span> and if it was, we took that <span 
class="fixed">x</span> and applied the function to it. In this case, 
it's very easy to find the actual value, because we're dealing with a pair where 
one component is the value and the other a log. So first we just take the value, 
which is <code class="fixed">x</code> and we apply the function <span 
class="fixed">f</span> to it. We get a pair of <code class="fixed">(y,newLog)</code>, where
<code class="fixed">y</code> is the new result and <code class="fixed">newLog</code> 
the new log. But if we returned that as the result, the old log value wouldn't 
be included in the result, so we return a pair of <span class="fixed">(y,log ++ 
newLog)</span>. We use <code class="fixed">++</code> to append the new log to 
the old one.
</p>

<p>
Here's <code class="fixed">applyLog</code> in action:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; (3, "Smallish gang.") `applyLog` isBigGang
(False,"Smallish gang.Compared gang size to 9")
ghci&gt; (30, "A freaking platoon.") `applyLog` isBigGang
(True,"A freaking platoon.Compared gang size to 9")
</pre>

<p>
The results are similar to before, only now the number of people in the gang had 
its accompanying log and it got included in the result log. Here are a few more 
examples of using <code class="fixed">applyLog</code>:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; ("Tobin","Got outlaw name.") `applyLog` (\x -&gt; (length x, "Applied length."))
(5,"Got outlaw name.Applied length.")
ghci&gt; ("Bathcat","Got outlaw name.") `applyLog` (\x -&gt; (length x, "Applied length"))
(7,"Got outlaw name.Applied length")
</pre>

<p>
See how inside the lambda, <code class="fixed">x</code> is just a normal string 
and not a tuple and how <code class="fixed">applyLog</code> takes care of 
appending the logs.
</p>

<h3>Monoids to the rescue</h3>

<div class="hintbox">
Be sure you know what <a href="functors-applicative-functors-and-monoids.html#monoids">monoids</a> are at this point! Cheers.
</div>

<p>
Right now, <code class="fixed">applyLog</code> takes values of type <span 
class="fixed">(a,String)</span>, but is there a reason that the log has to be a 
<code class="fixed">String</code>? It uses <code class="fixed">++</code> to append 
the logs, so wouldn't this work on any kind of list, not just a list of 
characters? Sure it would. We can go ahead and change its type to this:
</p>

<pre name="code" class="haskell:hs">
applyLog :: (a,[c]) -&gt; (a -&gt; (b,[c])) -&gt; (b,[c])
</pre>

<p>
Now, the log is a list. The type of values contained in the list has to be the 
same for the original list as well as for the list that the function returns, 
otherwise we wouldn't be able to use <code class="fixed">++</code> to stick them 
together.
</p>

<p>
Would this work for bytestrings? There's no reason it shouldn't. However, the 
type we have now only works for lists. It seems like we'd have to make a 
separate <code class="fixed">applyLog</code> for bytestrings. But wait! Both 
lists and bytestrings are monoids. As such, they are both instances of the
<code class="fixed">Monoid</code> type class, which means that they implement 
the <code class="fixed">mappend</code> function. And for both lists and 
bytestrings, <code class="fixed">mappend</code> is for appending. Watch:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; [1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]
ghci&gt; B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]
Chunk "chi" (Chunk "huahua" Empty)
</pre>

<p>
Cool! Now our <code class="fixed">applyLog</code> can work for any monoid. We 
have to change the type to reflect this, as well as the implementation, because 
we have to change <code class="fixed">++</code> to <code class="fixed">mappend</code>:
</p>

<pre name="code" class="haskell:hs">
applyLog :: (Monoid m) =&gt; (a,m) -&gt; (a -&gt; (b,m)) -&gt; (b,m)
applyLog (x,log) f = let (y,newLog) = f x in (y,log `mappend` newLog)
</pre>

<p>
Because the accompanying value can now be any monoid value, we no longer have to 
think of the tuple as a value and a log, but now we can think of it as a value 
with an accompanying monoid value. For instance, we can have a tuple that has an 
item name and an item price as the monoid value. We just use the <span 
class="fixed">Sum</span> newtype to make sure that the prices get added as we 
operate with the items. Here's a function that adds drink to some cowboy food:
</p>

<pre name="code" class="haskell:hs">
import Data.Monoid

type Food = String
type Price = Sum Int

addDrink :: Food -&gt; (Food,Price)
addDrink "beans" = ("milk", Sum 25)
addDrink "jerky" = ("whiskey", Sum 99)
addDrink _ = ("beer", Sum 30)
</pre>

<p>
We use strings to represent foods and an <code class="fixed">Int</code>
in a <code class="fixed">Sum</code> <code class="fixed">newtype</code> wrapper to keep 
track of how many cents something costs. Just a reminder, doing <span 
class="fixed">mappend</span> with <code class="fixed">Sum</code> results in the 
wrapped values getting added together:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; Sum 3 `mappend` Sum 9
Sum {getSum = 12}
</pre>

<p>
The <code class="fixed">addDrink</code> function is pretty simple. If we're 
eating beans, it returns <code class="fixed">"milk"</code> along with <span 
class="fixed">Sum 25</span>, so 25 cents wrapped in <span 
class="fixed">Sum</span>. If we're eating jerky we drink whiskey and if we're 
eating anything else we drink beer. Just normally applying this function to a 
food wouldn't be terribly interesting right now, but using <span 
class="fixed">applyLog</span> to feed a food that comes with a price itself into 
this function is interesting:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; ("beans", Sum 10) `applyLog` addDrink
("milk",Sum {getSum = 35})
ghci&gt; ("jerky", Sum 25) `applyLog` addDrink
("whiskey",Sum {getSum = 124})
ghci&gt; ("dogmeat", Sum 5) `applyLog` addDrink
("beer",Sum {getSum = 35})
</pre>

<p>
Milk costs <code class="fixed">25</code> cents, but if we eat 
it with beans that cost <code class="fixed">10</code> cents, we'll end up paying 
<code class="fixed">35</code> cents. Now it's clear how the attached value 
doesn't always have to be a log, it can be any monoid value and how two such 
values are combined into one depends on the monoid. When we were doing logs, 
they got appended, but now, the numbers are being added up.
</p>

<p>
Because the value that <code class="fixed">addDrink</code> returns is a tuple of 
type <code class="fixed">(Food,Price)</code>, we can feed that result to <span 
class="fixed">addDrink</span> again, so that it tells us what we should drink 
along with our drink and how much that will cost us. Let's give it a shot:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; ("dogmeat", Sum 5) `applyLog` addDrink `applyLog` addDrink
("beer",Sum {getSum = 65})
</pre>

<p>
Adding a drink to some dog meat results in a beer and an additional 
<code class="fixed">30</code> cents, so <code class="fixed">("beer", Sum 35)</code>.
And if we use <code class="fixed">applyLog</code> to feed that to <span 
class="fixed">addDrink</span>, we get another beer and the result is
<code class="fixed">("beer", Sum 65)</code>.
</p>

<h3>The Writer type</h3>

<p>
Now that we've seen that a value with an attached monoid acts like a monadic 
value, let's examine the <code class="fixed">Monad</code> instance for types of 
such values.  The <code class="fixed">Control.Monad.Writer</code> module exports 
the <code class="fixed">Writer w a</code> type along with its <span 
class="fixed">Monad</span> instance and some useful functions for dealing with 
values of this type.
</p>

<p>
First, let's examine the type itself. To attach a monoid to a value, we just 
need to put them together in a tuple. The <code class="fixed">Writer w a</code> 
type is just a <code class="fixed">newtype</code> wrapper for this. Its 
definition is very simple:
</p>

<pre name="code" class="haskell:hs">
newtype Writer w a = Writer { runWriter :: (a, w) }
</pre>

<p>
It's wrapped in a <code class="fixed">newtype</code> so that it can be made an 
instance of <code class="fixed">Monad</code> and that its type is separate from 
a normal tuple. The <code class="fixed">a</code> type parameter represents the type 
of the value and the <code class="fixed">w</code> type parameter the type of the 
attached monoid value.
</p>

<p>
Its <code class="fixed">Monad</code> instance is defined like so:
</p>

<pre name="code" class="haskell:hs">
instance (Monoid w) =&gt; Monad (Writer w) where
    return x = Writer (x, mempty)
    (Writer (x,v)) &gt;&gt;= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')
</pre>


<img src="lyah/angeleyes.png" alt="when you have to poop, poop, don't talk" class="right" width="383" height="248">
<p>
First off, let's examine <code class="fixed">&gt;&gt;=</code>. Its 
implementation is essentially the same as <code class="fixed">applyLog</code>, 
only now that our tuple is wrapped in the <code class="fixed">Writer</code> 
<code class="fixed">newtype</code>, we have to unwrap it when pattern matching.
We take the value <code class="fixed">x</code> and apply the function <span 
class="fixed">f</span> to it. This gives us a <span 
class="fixed">Writer w a</span> value and we use a <span 
class="fixed">let</span> expression to pattern match on it. We present 
<code class="fixed">y</code> as the new result and use <span 
class="fixed">mappend</span> to combine the old monoid value with the new one. 
We pack that up with the result value in a tuple and then wrap that with the 
<code class="fixed">Writer</code> constructor so that our result is a <span 
class="fixed">Writer</span> value instead of just an unwrapped tuple.
</p>

<p>
So, what about <code class="fixed">return</code>? It has to take a value and put 
it in a default minimal context that still presents that value as the result. So 
what would such a context be for <code class="fixed">Writer</code> values? If we 
want the accompanying monoid value to affect other monoid values as little as 
possible, it makes sense to use <code class="fixed">mempty</code>. <span 
class="fixed">mempty</span> is used to present identity monoid values, such as 
<code class="fixed">""</code> and <code class="fixed">Sum 0</code> and empty 
bytestrings. Whenever we use <code class="fixed">mappend</code> between <span 
class="fixed">mempty</span> and some other monoid value, the result is that 
other monoid value. So if we use <code class="fixed">return</code> to make a 
<code class="fixed">Writer</code> value and then use <code class="fixed">&gt;&gt;=</code> 
to feed that value to a function, the resulting monoid value will be only what 
the function returns. Let's use <code class="fixed">return</code> on the number
<code class="fixed">3</code> a bunch of times, only we'll pair it with a 
different monoid every time:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; runWriter (return 3 :: Writer String Int)
(3,"")
ghci&gt; runWriter (return 3 :: Writer (Sum Int) Int)
(3,Sum {getSum = 0})
ghci&gt; runWriter (return 3 :: Writer (Product Int) Int)
(3,Product {getProduct = 1})
</pre>

<p>
Because <code class="fixed">Writer</code> doesn't have a <span 
class="fixed">Show</span> instance, we had to use <span 
class="fixed">runWriter</span> to convert our <code class="fixed">Writer</code> 
values to normal tuples that can be shown. For <span 
class="fixed">String</span>, the monoid value is the empty string. With <span 
class="fixed">Sum</span>, it's <code class="fixed">0</code>, because if we add 0 
to something, that something stays the same. For <code class="fixed">Product</code>, 
the identity is <code class="fixed">1</code>.
</p>

<p>
The <code class="fixed">Writer</code> instance doesn't feature an implementation 
for <code class="fixed">fail</code>, so if a pattern match fails in <span 
class="fixed">do</span> notation, <code class="fixed">error</code> is called. 
</p>

<h3>Using do notation with Writer</h3>

<p>
Now that we have a <code class="fixed">Monad</code> instance, we're free to use 
<code class="fixed">do</code> notation for <code class="fixed">Writer</code> 
values. It's handy for when we have a several <code class="fixed">Writer</code> 
values and we want to do stuff with them. Like with other monads, we can treat 
them as normal values and the context gets taken for us. In this case, 
all the monoid values that come attached get <code class="fixed">mappend</code>ed 
and so are reflected in the final result. Here's a simple example of using  
<code class="fixed">do</code> notation with <code class="fixed">Writer</code> to 
multiply two numbers:
</p>

<pre name="code" class="haskell:hs">
import Control.Monad.Writer

logNumber :: Int -&gt; Writer [String] Int
logNumber x = Writer (x, ["Got number: " ++ show x])

multWithLog :: Writer [String] Int
multWithLog = do
    a &lt;- logNumber 3
    b &lt;- logNumber 5
    return (a*b)
</pre>

<p>
<code class="fixed">logNumber</code> takes a number and makes a <span 
class="fixed">Writer</span> value out of it. For the monoid, we use a list of 
strings and we equip the number with a singleton list that just says that we 
have that number. <code class="fixed">multWithLog</code> is a <span 
class="fixed">Writer</span> value which multiplies <code class="fixed">3</code>
and <code class="fixed">5</code> and makes sure that their attached logs get 
included in the final log. We use <code class="fixed">return</code> to present 
<code class="fixed">a*b</code> as the result. Because <span 
class="fixed">return</span> just takes something and puts it in a minimal 
context, we can be sure that it won't add anything to the log. Here's what we 
see if we run this:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; runWriter multWithLog
(15,["Got number: 3","Got number: 5"])
</pre>

<p>
Sometimes we just want some monoid value to be included at some particular 
point. For this, the
<code class="fixed">tell</code> function is useful. It's part of the
<code class="fixed">MonadWriter</code> type class and in the case of
<code class="fixed">Writer</code> it takes a monoid value, like <span 
class="fixed">["This is going on"]</span> and creates a <span 
class="fixed">Writer</span> value that presents the dummy value <span 
class="fixed">()</span> as its result but has our desired monoid value attached.
When we have a monadic value that has <code class="fixed">()</code> as its 
result, we don't bind it to a variable. Here's <code class="fixed">multWithLog</code>
but with some extra reporting included:
</p>

<pre name="code" class="haskell:hs">
multWithLog :: Writer [String] Int
multWithLog = do
    a &lt;- logNumber 3
    b &lt;- logNumber 5
    tell ["Gonna multiply these two"]
    return (a*b)
</pre>

<p>
It's important that <code class="fixed">return (a*b)</code> is the last line, 
because the result of the last line in a <code class="fixed">do</code> expression
is the result of the whole <code class="fixed">do</code> expression. Had we 
put <code class="fixed">tell</code> as the last line, <span 
class="fixed">()</span> would have been the result of this <span 
class="fixed">do</span> expression. We'd lose the result of the multiplication. 
However, the log would be the same. Here is this in action:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; runWriter multWithLog
(15,["Got number: 3","Got number: 5","Gonna multiply these two"])
</pre>

<h3>Adding logging to programs</h3>

<p>
Euclid's algorithm is an algorithm that takes two numbers and computes their 
greatest common divisor. That is, the biggest number that still divides both of 
them. Haskell already features the <code class="fixed">gcd</code> 
function, which does exactly this, but let's implement our own and then equip it 
with logging capabilities. Here's the normal algorithm:
</p>



<pre name="code" class="haskell:hs">
gcd' :: Int -&gt; Int -&gt; Int
gcd' a b 
    | b == 0    = a
    | otherwise = gcd' b (a `mod` b)
</pre>

<p>
The algorithm is very simple. First, it checks if the second number is 0. If it 
is, then the result is the first number. If it isn't, then the result is the 
greatest common divisor of the second number and the remainder of dividing the 
first number with the second one. For instance, if we want to know what the 
greatest common divisor of 8 and 3 is, we just follow the algorithm outlined. 
Because 3 isn't 0, we have to find the greatest common divisor of 3 and 2 
(if we divide 8 by 3, the remainder is 2). Next, we find the greatest 
common divisor of 3 and 2. 2 still isn't 0, so now we have have 2 and 1. The 
second number isn't 0, so we run the algorithm again for 1 and 0, as 
dividing 2 by 1 gives us a remainder of 0. And finally, because the second number 
is now 0, the final result is 1. Let's see if our code agrees:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; gcd' 8 3
1
</pre>

<p>
It does. Very good! Now, we want to equip our result with a context, and the 
context will be a monoid value that acts as a log. Like before, we'll use a list 
of strings as our monoid. So the type of our new <code class="fixed">gcd'</code> 
function should be:
</p>

<pre name="code" class="haskell:hs">
gcd' :: Int -&gt; Int -&gt; Writer [String] Int
</pre>

<p>
All that's left now is to equip our function with log values. Here's the code:
</p>

<pre name="code" class="haskell:hs">
import Control.Monad.Writer

gcd' :: Int -&gt; Int -&gt; Writer [String] Int
gcd' a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        gcd' b (a `mod` b)
</pre>

<p>
This function takes two normal <code class="fixed">Int</code> values and returns 
a <code class="fixed">Writer [String] Int</code>, that is, an <span 
class="fixed">Int</span> that has a log context. In the case where <span 
class="fixed">b</span> is <code class="fixed">0</code>, instead of just giving
<code class="fixed">a</code> as the result, we use a <code class="fixed">do</code> expression
to put together a <code class="fixed">Writer</code> value as a result. First we 
use <code class="fixed">tell</code> to report that we're finished and then we 
use <code class="fixed">return</code> to present <code class="fixed">a</code> as 
the result of the <code class="fixed">do</code> expression. Instead of this 
<code class="fixed">do</code> expression, we could have also written this:
</p>

<pre name="code" class="haskell:hs">
Writer (a, ["Finished with " ++ show a])
</pre>

<p>
However, I think the <code class="fixed">do</code> expression is easier to read. Next, 
we have the case when <code class="fixed">b</code> isn't <code class="fixed">0</code>. In this case,
we log that we're using <code class="fixed">mod</code> to figure out the 
remainder of dividing <code class="fixed">a</code> and <span 
class="fixed">b</span>. Then, the second line of the <code class="fixed">do</code> expression
just recursively calls <code class="fixed">gcd'</code>. Remember, <span 
class="fixed">gcd'</span> now ultimately returns a <code class="fixed">Writer</code> value,
so it's perfectly valid that <code class="fixed">gcd' b (a `mod` b)</code> is a 
line in a <code class="fixed">do</code> expression.
</p>

<p>
While it may be kind of useful to trace the execution of this new <span 
class="fixed">gcd'</span> by hand to see how the logs get appended, I think it's 
more insightful to just look at the big picture and view these as values with a 
context and from that gain insight as to what the final result will be.
</p>

<p>
Let's try our new <code class="fixed">gcd'</code> out. Its result is a
<code class="fixed">Writer [String] Int</code> value and if we unwrap that from 
its <code class="fixed">newtype</code>, we get a tuple. The first part of the 
tuple is the result. Let's see if it's okay:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; fst $ runWriter (gcd' 8 3)
1
</pre>

<p>
Good! Now what about the log? Because the log is a list of strings, let's use
<code class="fixed">mapM_ putStrLn</code> to print those strings to the screen:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcd' 8 3)
8 mod 3 = 2
3 mod 2 = 1
2 mod 1 = 0
Finished with 1
</pre>

<p>
I think it's awesome how we were able to change our ordinary algorithm to one 
that reports what it does as it goes along just by changing normal values to 
monadic values and letting the implementation of <code class="fixed">&gt;&gt;=</code>
for <code class="fixed">Writer</code> take care of the logs for us. We can add a 
logging mechanism to pretty much any function. We just replace normal values 
with <code class="fixed">Writer</code> values where we want and change normal function
application to <code class="fixed">&gt;&gt;=</code> (or <span 
class="fixed">do</span> expressions if it increases readability).
</p>

<h3>Inefficient list construction</h3>

<p>
When using the <code class="fixed">Writer</code> monad, you have to be careful
which monoid to use, because using lists can sometimes turn out to be very
slow. That's because lists use <code class="fixed">++</code> for <code class="fixed">mappend</code>
and using <code class="fixed">++</code> to add something to the end of a list is
slow if that list is really long.
</p>

<p>
In our <code class="fixed">gcd'</code> function, the logging is fast because the list
appending ends up looking like this:
</p>

<pre name="code" class="haskell:hs">
a ++ (b ++ (c ++ (d ++ (e ++ f))))
</pre>

<p>
Lists are a data structure that's constructed from left to right, and this is
efficient because we first fully construct the left part of a list and only
then add a longer list on the right. But if we're not careful, using the
<code class="fixed">Writer</code> monad can produce list appending that looks like this:
</p>

<pre name="code" class="haskell:hs">
((((a ++ b) ++ c) ++ d) ++ e) ++ f
</pre>

<p>
This associates to the left instead of to the right. This is inefficient
because every time it wants to add the right part to the left part, it has
to construct the left part all the way from the beginning! 
</p>

<p>
The following function works like <code class="fixed">gcd'</code>, only it logs stuff in
reverse. First it produces the log for the rest of the procedure and then adds
the current step to the end of the log. 
</p>

<pre name="code" class="haskell:hs">
import Control.Monad.Writer

gcdReverse :: Int -&gt; Int -&gt; Writer [String] Int
gcdReverse a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        result &lt;- gcdReverse b (a `mod` b)
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        return result
</pre>

<p>
It does the recursion first, and binds its result value to <code class="fixed">result</code>.
Then it adds the current step to the log, but the current step goes at the end
of the log that was produced by the recursion. Finally, it presents the
result of the recursion as the final result. Here it is in action:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcdReverse 8 3)
Finished with 1
2 mod 1 = 0
3 mod 2 = 1
8 mod 3 = 2
</pre>

<p>
It's inefficient because it ends up associating the use of <span 
class="fixed">++</span> to
the left instead of to the right.
</p>

<h3>Difference lists</h3>

<img src="lyah/cactus.png" alt="cactuses" class="left" width="147" height="300">

<p>
Because lists can sometimes be inefficient when repeatedly appended in this
manner, it's best to use a data structure that always supports efficient
appending. One such data structure is the difference list.  A difference list
is similar to a list, only instead of being a normal list, it's a function that
takes a list and prepends another list to it. The difference list equivalent of
a list like <code class="fixed">[1,2,3]</code> would be the function <code class="fixed">\xs -&gt; [1,2,3] ++ xs</code>. 
A normal empty list is <code class="fixed">[]</code>, whereas an empty difference list
is the function <code class="fixed">\xs -&gt; [] ++ xs</code>.
</p>

<p>
The cool thing about difference lists is that they support efficient appending. 
When we append two normal lists with <code class="fixed">++</code>, it has to 
walk all the way to the end of the list on the left of <span 
class="fixed">++</span> and then stick the other one there. But what if 
we take the difference list approach and represent our lists as functions? Well 
then, appending two difference lists can be done like so:
</p>

<pre name="code" class="haskell:hs">
f `append` g = \xs -&gt; f (g xs)
</pre>

<p>
Remember, <code class="fixed">f</code> and <code class="fixed">g</code> are 
functions that take lists and prepend something to them. So, for instance, if 
<code class="fixed">f</code> is the function <code class="fixed">("dog"++)</code> (just another
way of writing <code class="fixed">\xs -&gt; "dog" ++ xs</code>) and <span 
class="fixed">g</span> the function <code class="fixed">("meat"++)</code>, then
<code class="fixed">f `append` g</code> makes a new function that's equivalent 
to the following:
</p>

<pre name="code" class="haskell:hs">
\xs -&gt; "dog" ++ ("meat" ++ xs)
</pre>

<p>
We've appended two difference lists just by making a new function that first 
applies one difference list some list and then the other.
</p>

<p>
Let's make a <code class="fixed">newtype</code> wrapper for difference lists so 
that we can easily give them monoid instances:
</p>

<pre name="code" class="haskell:hs">
newtype DiffList a = DiffList { getDiffList :: [a] -&gt; [a] }
</pre>

<p>
The type that we wrap is <code class="fixed">[a] -&gt; [a]</code> because a 
difference list is just a function that takes a list and returns another. 
Converting normal lists to difference lists and vice versa is easy:
</p>

<pre name="code" class="haskell:hs">
toDiffList :: [a] -&gt; DiffList a
toDiffList xs = DiffList (xs++)

fromDiffList :: DiffList a -&gt; [a]
fromDiffList (DiffList f) = f []
</pre>

<p>
To make a normal list into a difference list we just do what we did before and 
make it a function that prepends it to another list. Because a difference list 
is a function that prepends something to another list, if we just want that 
something, we apply the function to an empty list!
</p>

<p>
Here's the <code class="fixed">Monoid</code> instance:
</p>

<pre name="code" class="haskell:hs">
instance Monoid (DiffList a) where
    mempty = DiffList (\xs -&gt; [] ++ xs)
    (DiffList f) `mappend` (DiffList g) = DiffList (\xs -&gt; f (g xs))
</pre>

<p>
Notice how for lists, <code class="fixed">mempty</code> is just the
<code class="fixed">id</code> function and <code class="fixed">mappend</code> is 
actually just function composition. Let's see if this works:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
[1,2,3,4,1,2,3]
</pre>

<p>
Tip top! Now we can increase the efficiency of our <span 
class="fixed">gcdReverse</span> function by making it use difference lists instead of normal 
lists:
</p>


<pre name="code" class="haskell:hs">
import Control.Monad.Writer

gcd' :: Int -&gt; Int -&gt; Writer (DiffList String) Int
gcd' a b
    | b == 0 = do
        tell (toDiffList ["Finished with " ++ show a])
        return a
    | otherwise = do
        result &lt;- gcd' b (a `mod` b)
        tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
        return result
</pre>

<p>
We only had to change the type of the monoid from <code class="fixed">[String]</code>
to <code class="fixed">DiffList String</code> and then when using 
<code class="fixed">tell</code>, convert our normal lists into difference lists 
with <code class="fixed">toDiffList</code>. Let's see if the log gets assembled 
properly:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; mapM_ putStrLn . fromDiffList . snd . runWriter $ gcdReverse 110 34
Finished with 2
8 mod 2 = 0
34 mod 8 = 2
110 mod 34 = 8
</pre>

<p>
We do <code class="fixed">gcdReverse 110 34</code>, then use <code class="fixed">runWriter</code>
to unwrap it from the <code class="fixed">newtype</code>, then apply <span 
class="fixed">snd</span> to that to just get the log, then apply <span 
class="fixed">fromDiffList</span> to convert it to a normal list and then 
finally print its entries to the screen.
</p>

<h3>Comparing Performance</h3>

<p>
To get a feel for just how much difference lists may improve your performance,
consider this function that just counts down from some number to zero, but
produces its log in reverse, like <code class="fixed">gcdReverse</code>, so that the numbers
in the log will actually be counted up:
</p>

<pre name="code" class="haskell:hs">
finalCountDown :: Int -&gt; Writer (DiffList String) ()
finalCountDown 0 = do
    tell (toDiffList ["0"])
finalCountDown x = do
    finalCountDown (x-1)
    tell (toDiffList [show x])
</pre>

<p>
If we give it <code class="fixed">0</code>, it just logs it. For any other number, it
first counts down its predecessor to <code class="fixed">0</code> and then appends
that number to the log. So if we apply <code class="fixed">finalCountDown</code> to
<code class="fixed">100</code>, the string <code class="fixed">"100"</code> will come last in the
log.
</p>

<p>
Anyway, if you load this function in GHCi and apply it to a big number,
like <code class="fixed">500000</code>, you'll see that it quickly starts counting from
<code class="fixed">0</code> onwards:

<pre name="code" class="haskell:hs">
ghci&gt; mapM_ putStrLn . fromDiffList . snd . runWriter $ finalCountDown 500000
0
1
2
...
</pre>

<p>
However, if we change it to use normal lists instead of difference lists, like so:
</p>

<pre name="code" class="haskell:hs">
finalCountDown :: Int -&gt; Writer [String] ()
finalCountDown 0 = do
    tell ["0"]
finalCountDown x = do
    finalCountDown (x-1)
    tell [show x]
</pre>

<p>
And then tell GHCi to start counting:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; mapM_ putStrLn . snd . runWriter $ finalCountDown 500000
</pre>

<p>
We'll see that the counting is really slow.
</p>

<p>
Of course, this is not the proper and scientific way to test how fast our
programs are, but we were able to see that in this case, using difference lists
starts producing results right away whereas normal lists take forever.
</p>

<p>
Oh, by the way, the song Final Countdown by Europe is now stuck in your head.
Enjoy!
</p>

<a name="reader"></a>
<h2>Reader? Ugh, not this joke again.</h2>

<img src="lyah/revolver.png" alt="bang youre dead" class="left" width="280" 
height="106">

<p>
In the <a href="functors-applicative-functors-and-monoids.html">chapter about 
applicatives</a>, we saw 
that the function type, <code class="fixed">(-&gt;) r</code> is an instance of 
<code class="fixed">Functor</code>. Mapping a function <span 
class="fixed">f</span> over a function <code class="fixed">g</code> will make a 
function that takes the same thing as <code class="fixed">g</code>, applies 
<code class="fixed">g</code> to it and then applies <code class="fixed">f</code> 
to that result. So basically, we're making a new function that's like <span 
class="fixed">g</span>, only before returning its result, <span 
class="fixed">f</span> gets applied to that result as well. For instance:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; let f = (*5)
ghci&gt; let g = (+3)
ghci&gt; (fmap f g) 8
55
</pre>

<p>
We've also seen that functions are applicative functors. They allow us to 
operate on the eventual results of functions as if we already had their results. 
Here's an example: 
</p>

<pre name="code" class="haskell:hs">
ghci&gt; let f = (+) &lt;$&gt; (*2) &lt;*&gt; (+10)
ghci&gt; f 3
19
</pre>

<p>
The expression <code class="fixed">(+) &lt;$&gt; (*2) &lt;*&gt; (+10)</code> 
makes a function that takes a number, gives that number to <span 
class="fixed">(*2)</span> and <code class="fixed">(+10)</code> and then adds 
together the results. For instance, if we apply this function to <span 
class="fixed">3</span>, it applies both <code class="fixed">(*2)</code> and 
<code class="fixed">(+10)</code> to <code class="fixed">3</code>, giving 
<code class="fixed">6</code> and <code class="fixed">13</code>. Then, it calls
<code class="fixed">(+)</code> with <code class="fixed">6</code> and 
<code class="fixed">13</code> and the result is <code class="fixed">19</code>.
</p>

<p>
Not only is the function type <code class="fixed">(-&gt;) r</code> a functor 
and an applicative functor, but it's also a monad. Just like other monadic 
values that we've met so far, a function can also be considered a value with 
a context. The context for functions is that that value is not present yet and 
that we have to apply that function to something in order to get its result 
value.
</p>

<p>
Because we're already acquainted with how functions work as functors and 
applicative functors, let's dive right in and see what their 
<code class="fixed">Monad</code> instance looks like. It's located in
<code class="fixed">Control.Monad.Instances</code> and it goes a little 
something like this:
</p>

<pre name="code" class="haskell:hs">
instance Monad ((-&gt;) r) where
    return x = \_ -&gt; x
    h &gt;&gt;= f = \w -&gt; f (h w) w
</pre>

<p>
We've already seen how <code class="fixed">pure</code> is implemented for 
functions, and <code class="fixed">return</code> is pretty much the same thing 
as <code class="fixed">pure</code>. It takes a value and puts it in a minimal 
context that always has that value as its result. And the only way to make a 
function that always has a certain value as its result is to make it completely 
ignore its parameter.
</p>

<p>
The implementation for <code class="fixed">&gt;&gt;=</code> seems a bit cryptic, 
but it's really not all that. When we use <code class="fixed">&gt;&gt;=</code> 
to feed a monadic value to a function, the result is always a monadic value. So 
in this case, when we feed a function to another function, the result is a 
function as well. That's why the result starts off as a lambda. All of the 
implementations of <code class="fixed">&gt;&gt;=</code> so far always somehow 
isolated the result from the monadic value and then applied the function
<code class="fixed">f</code> to that result. The same thing happens here. To get 
the result from a function, we have to apply it to something, which is why we do
<code class="fixed">(h w)</code> here to get the result from the function and 
then we apply <code class="fixed">f</code> to that. <code class="fixed">f</code> 
returns a monadic value, which is a function in our case, so we apply it to 
<code class="fixed">w</code> as well.
</p>

<p>
If don't get how <code class="fixed">&gt;&gt;=</code> works at this point, don't 
worry, because with examples we'll see how this is a really simple monad. Here's 
a <code class="fixed">do</code> expression that utilizes this monad:
</p>

<pre name="code" class="haskell:hs">
import Control.Monad.Instances

addStuff :: Int -&gt; Int
addStuff = do
    a &lt;- (*2)
    b &lt;- (+10)
    return (a+b)
</pre>

<p>
This is the same thing as the applicative expression that we wrote earlier, only 
now it relies on functions being monads. A <code class="fixed">do</code> 
expression always results in a monadic value and this one is no different. The 
result of this monadic value is a function. What happens here is that it takes a 
number and then <code class="fixed">(*2)</code> gets applied to that number and 
the result becomes <code class="fixed">a</code>. <code class="fixed">(+10)</code> is applied to the same number that
<code class="fixed">(*2)</code> got applied to and the result becomes <span 
class="fixed">b</span>. <code class="fixed">return</code>, like in other monads, 
doesn't have any other effect but to make a monadic value that presents some 
result. This presents <code class="fixed">a+b</code> as the result of this 
function. If we test it out, we get the same result as before:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; addStuff 3
19
</pre>

<p>
Both <code class="fixed">(*2)</code> and <code class="fixed">(+10)</code> get 
applied to the number <code class="fixed">3</code> in this case. <span 
class="fixed">return (a+b)</span> does as well, but it ignores it and always 
presents <code class="fixed">a+b</code> as the result. For this reason, the 
function monad is also called the reader monad. All the functions read from a 
common source. To illustrate this even better, we can rewrite 
<code class="fixed">addStuff</code> like so:
</p>

<pre name="code" class="haskell:hs">
addStuff :: Int -&gt; Int
addStuff x = let
    a = (*2) x
    b = (+10) x
    in a+b
</pre>

<p>
We see that the reader monad allows us to treat functions as values with a 
context. We can act as if we already know what the functions will return. It 
does this by gluing functions together into one function and then giving that 
function's parameter to all of the functions that it was glued from. So if we 
have a lot of functions that are all just missing one parameter and they'd 
eventually be applied to the same thing, we can use the reader monad to sort of 
extract their future results and the <code class="fixed">&gt;&gt;=</code> 
implementation will make sure that it all works out.
</p>

<a name="state"></a>
<h2>Tasteful stateful computations</h2>
<img src="lyah/texas.png" alt="don't jest with texas" class="left" width="244" 
height="230">

<p>
Haskell is a pure language and because of that, our programs are made of 
functions that can't change any global state or variables,
they can only do some computations and return them results. This restriction
actually makes it easier to think about our programs, as it frees us from 
worrying what every variable's value is at some point in time. However, some 
problems are inherently stateful in that they rely on some state that changes 
over time. While such problems aren't a problem for Haskell, they can be a bit 
tedious to model sometimes. That's why Haskell features a thing called the state 
monad, which makes dealing with stateful problems a breeze while still keeping 
everything nice and pure.
</p>

<p>
<a href="input-and-output.html#randomness">When we were dealing with random numbers</a>, we dealt with functions that took a 
random generator as a parameter and returned a random number and a new random 
generator. If we wanted to generate several random numbers, we always had to use 
the random generator that a previous function returned along with its result. 
When making a function that takes a <code class="fixed">StdGen</code> and tosses 
a coin three times based on that generator, we had to do this:
</p>

<pre name="code" class="haskell:hs">
threeCoins :: StdGen -&gt; (Bool, Bool, Bool)
threeCoins gen = 
    let (firstCoin, newGen) = random gen
        (secondCoin, newGen') = random newGen
        (thirdCoin, newGen'') = random newGen'
    in  (firstCoin, secondCoin, thirdCoin)
</pre>

<p>
It took a generator <code class="fixed">gen</code> and then <span 
class="fixed">random gen</span> returned a <code class="fixed">Bool</code> value 
along with a new generator. To throw the second coin, we used the new generator, 
and so on. In most other languages, we wouldn't have to return a new generator 
along with a random number. We could just modify the existing one! But since 
Haskell is pure, we can't do that, so we had to take some state, make a result 
from it and a new state and then use that new state to generate new results.
</p>

<p>
You'd think that to avoid manually dealing with stateful computations in this 
way, we'd have to give up the purity of Haskell. Well, we don't have to, since 
there exist a special little monad called the state monad which handles all this 
state business for us and without giving up any of the purity that makes Haskell 
programming so cool.
</p>

<p>
So, to help us understand this concept of stateful computations better, let's go 
ahead and give them a type. We'll say that a stateful computation is a function 
that takes some state and returns a value along with some new state. That 
function would have the following type:
</p>

<pre name="code" class="haskell:hs">
s -&gt; (a,s)
</pre>

<p>
<code class="fixed">s</code> is the type of the state and <span 
class="fixed">a</span> the result of the stateful computations.
</p>

<div class="hintbox">
Assignment in most other languages could be thought of as a stateful 
computation. For instance, when we do <code class="fixed">x = 5</code> in an 
imperative language, it will usually assign the value <span 
class="fixed">5</span> to the variable <code class="fixed">x</code> and it will 
also have the value <code class="fixed">5</code> as an expression. If you look 
at that functionally, you could look at it as a function that takes a state 
(that is, all the variables that have been assigned previously) and returns a 
result (in this case <code class="fixed">5</code>) and a new state, which would 
be all the previous variable mappings plus the newly assigned variable.
</div>

<p>
This stateful computation, a function that takes a state 
and returns a result and a new state, can be thought of as a value with a 
context as well. The actual value is the result, whereas the context is that we 
have to provide some initial state to actually get that result and that apart 
from getting a result we also get a new state.
</p>

<h3>Stacks and stones</h3>

<p>
Say we want to model operating a stack. You have a stack of things one on top 
of another and you can either push stuff on top of that stack or you can take stuff 
off the top of the stack. When you're putting an item on top of the stack we say 
that you're pushing it to the stack and when you're taking stuff off the 
top we say that you're popping it. If you want to something that's at the bottom 
of the stack, you have to pop everything that's above it.
</p>

<p>
We'll use a list to represent our stack and the head of the list will be the top 
of the stack. To help us with our task, we'll make two functions: <span 
class="fixed">pop</span> and <code class="fixed">push</code>. <span 
class="fixed">pop</span> will take a stack, pop one item and return that item as 
the result and also return a new stack, without that item. <span 
class="fixed">push</span> will take an item and a stack and then push that item 
onto the stack. It will return <code class="fixed">()</code> as its result, 
along with a new stack. Here goes:
</p>

<pre name="code" class="haskell:hs">
type Stack = [Int]

pop :: Stack -&gt; (Int,Stack)
pop (x:xs) = (x,xs)

push :: Int -&gt; Stack -&gt; ((),Stack)
push a xs = ((),a:xs)
</pre>

<p>
We used <code class="fixed">()</code> as the result when pushing to the stack 
because pushing an item onto the stack doesn't have any important result value, 
its main job is to change the stack. Notice how we just apply the first parameter of <code class="fixed">push</code>, we get a stateful 
computation. <code class="fixed">pop</code> is already a stateful computation 
because of its type.
</p>

<p>
Let's write a small piece of code to simulate a stack using these functions. 
We'll take a stack, push <code class="fixed">3</code> to it and then pop two 
items, just for kicks. Here it is:
</p>

<pre name="code" class="haskell:hs">
stackManip :: Stack -&gt; (Int, Stack)
stackManip stack = let
    ((),newStack1) = push 3 stack
    (a ,newStack2) = pop newStack1
    in pop newStack2
</pre>

<p>
We take a <code class="fixed">stack</code> and then we do <span 
class="fixed">push 3 stack</span>, which results in a tuple. The first part of 
the tuple is a <code class="fixed">()</code> and the second is a new stack and 
we call it <code class="fixed">newStack1</code>. 
Then, we pop a number from <code class="fixed">newStack1</code>, which results 
in a number <code class="fixed">a</code> (which is the <span 
class="fixed">3</span>) that we pushed and a new stack which we call
<code class="fixed">newStack2</code>. Then, we pop a number off 
<code class="fixed">newStack2</code> and we get a number that's <span 
class="fixed">b</span> and a <code class="fixed">newStack3</code>. We return a 
tuple with that number and that stack. Let's try it out:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; stackManip [5,8,2,1]
(5,[8,2,1])
</pre>

<p>
Cool, the result is <code class="fixed">5</code> and the new stack is 
<code class="fixed">[8,2,1]</code>. Notice how <code class="fixed">stackManip</code> 
is itself a stateful computation. We've taken a bunch of stateful computations 
and we've sort of glued them together. Hmm, sounds familiar. 
</p>
<p>
The above code for 
<code class="fixed">stackManip</code> is kind of tedious since we're manually 
giving the state to every stateful computation and storing it and then giving it 
to the next one. Wouldn't it be cooler if, instead of giving the stack manually 
to each function, we could write something like this:
</p>

<pre name="code" class="haskell:hs">
stackManip = do
    push 3
    a &lt;- pop
    pop
</pre>

<p>
Well, using the state monad will allow us to do exactly this. With it, we will 
be able to take stateful computations like these and use them without having to manage 
the state manually.
</p>

<h3>The State monad</h3>

<p>
The <code class="fixed">Control.Monad.State</code> module provides a <span 
class="fixed">newtype</span> that wraps stateful computations. Here's its definition:
</p>

<pre name="code" class="haskell:hs">
newtype State s a = State { runState :: s -&gt; (a,s) }
</pre>

<p>
A <code class="fixed">State s a</code> is a stateful computation that 
manipulates a state of type <code class="fixed">s</code> and has a result of 
type <code class="fixed">a</code>.
</p>

<p>
Now that we've seen what stateful computations are about and how they can even be 
thought of as values with contexts, let's check out their <span 
class="fixed">Monad</span> instance:
</p>

<pre name="code" class="haskell:hs">
instance Monad (State s) where
    return x = State $ \s -&gt; (x,s)
    (State h) &gt;&gt;= f = State $ \s -&gt; let (a, newState) = h s
                                        (State g) = f a
                                    in  g newState
</pre>

<p>
Let's take a gander at <code class="fixed">return</code> first. Our aim 
with <code class="fixed">return</code> is to take a value and make a stateful 
computation that always has that value as its result. That's why we just make a 
lambda <code class="fixed">\s -&gt; (x,s)</code>. We always present <span 
class="fixed">x</span> as the 
result of the stateful computation and the state is kept unchanged, because 
<code class="fixed">return</code> has to put a value in a minimal context. So
<code class="fixed">return</code> will make a stateful computation that presents 
a certain value as the result and keeps the state unchanged.
</p>

<img src="lyah/badge.png" alt="im a cop" class="right" width="182" height="160">

<p>
What about <code class="fixed">&gt;&gt;=</code>? Well, the result of feeding a 
stateful computation to a function with <code class="fixed">&gt;&gt;=</code> has to be a 
stateful computation, right? So we start off with the <code class="fixed">State</code>
<code class="fixed">newtype</code> wrapper and then we type out a lambda. This 
lambda will be our new stateful computation. But what goes on in it? Well, we 
somehow have to extract the result value from the first stateful computation. 
Because we're in a stateful computation right now, we can give the stateful 
computation <code class="fixed">h</code> our current state <span 
class="fixed">s</span>, which results in a pair of result and a new state: 
<code class="fixed">(a, newState)</code>. Every time so far when we were 
implementing <code class="fixed">&gt;&gt;=</code>, once we had the extracted 
the result from the monadic value, we applied the function 
<code class="fixed">f</code> to it to get the new monadic value. In
<code class="fixed">Writer</code>, after doing that and getting the new monadic 
value, we still had to make sure that the context was taken care of by 
<code class="fixed">mappend</code>ing the old monoid value with the new one. 
Here, we do <code class="fixed">f a</code> and we get a new stateful computation
<code class="fixed">g</code>. Now that we have a new stateful computation and a 
new state (goes by the name of <code class="fixed">newState</code>) we just 
apply that stateful computation <code class="fixed">g</code> to the <span 
class="fixed">newState</span>. The result is a tuple of final result and final 
state!
</p>

<p>
So with <code class="fixed">&gt;&gt;=</code>, we kind of glue two stateful 
computations together, only the second one is hidden inside a function that 
takes the previous one's result. Because <code class="fixed">pop</code> and
<code class="fixed">push</code> are already stateful computations, it's easy to 
wrap them into a <code class="fixed">State</code> wrapper. Watch:
</p>

<pre name="code" class="haskell:hs">
import Control.Monad.State

pop :: State Stack Int
pop = State $ \(x:xs) -&gt; (x,xs)

push :: Int -&gt; State Stack ()
push a = State $ \xs -&gt; ((),a:xs)
</pre>

<p>
<code class="fixed">pop</code> is already a stateful computation and
<code class="fixed">push</code> takes an <code class="fixed">Int</code> and 
returns a stateful computation. Now we can rewrite our previous example of 
pushing <code class="fixed">3</code> onto the stack and then popping two numbers 
off like this:
</p>

<pre name="code" class="haskell:hs">
import Control.Monad.State

stackManip :: State Stack Int
stackManip = do
    push 3
    a &lt;- pop
    pop
</pre>

<p>
See how we've glued a push and two pops into one stateful computation? When we 
unwrap it from its <code class="fixed">newtype</code> wrapper we get a function 
to which we can provide some initial state:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; runState stackManip [5,8,2,1]
(5,[8,2,1])
</pre>

<p>
We didn't have to bind the second <code class="fixed">pop</code> to <span 
class="fixed">a</span> because we didn't use that <code class="fixed">a</code> 
at all. So we could have written it like this:
</p>

<pre name="code" class="haskell:hs">
stackManip :: State Stack Int
stackManip = do
    push 3
    pop
    pop
</pre>

<p>
Pretty cool. But what if we want to do this: pop one number off the stack and 
then if that number is <code class="fixed">5</code> we just put it back onto the 
stack and stop but if it isn't <code class="fixed">5</code>, we push <span 
class="fixed">3</span> and <code class="fixed">8</code> back on? Well, here's 
the code:
</p>

<pre name="code" class="haskell:hs">
stackStuff :: State Stack ()
stackStuff = do
    a &lt;- pop
    if a == 5
        then push 5
        else do
            push 3
            push 8
</pre>

<p>
This is quite straightforward. Let's run it with an initial stack.
</p>

<pre name="code" class="haskell:hs">
ghci&gt; runState stackStuff [9,0,2,1,0]
((),[8,3,0,2,1,0])
</pre>

<p>
Remember, <code class="fixed">do</code> expressions result in monadic values and 
with the <code class="fixed">State</code> monad, a single <span 
class="fixed">do</span> expression is also a stateful function. Because
<code class="fixed">stackManip</code> and <code class="fixed">stackStuff</code>
are ordinary stateful computations, we can glue them together to produce further 
stateful computations.
</p>

<pre name="code" class="haskell:hs">
moreStack :: State Stack ()
moreStack = do
    a &lt;- stackManip
    if a == 100
        then stackStuff
        else return ()
</pre>

<p>
If the result of <code class="fixed">stackManip</code> on the current stack
is <code class="fixed">100</code>, we run <code class="fixed">stackStuff</code>, 
otherwise we do nothing. <code class="fixed">return ()</code> just keeps the 
state as it is and does nothing.
</p>

<p>
The <code class="fixed">Control.Monad.State</code> module provides a type class 
that's called <code class="fixed">MonadState</code> and it features two pretty 
useful functions, namely <code class="fixed">get</code> and <span 
class="fixed">put</span>. For <code class="fixed">State</code>, the <span 
class="fixed">get</span> function is implemented like this:
</p>

<pre name="code" class="haskell:hs">
get = State $ \s -&gt; (s,s)
</pre>

<p>
So it just takes the current state and presents it as the result. The
<code class="fixed">put</code> function takes some state and makes a stateful 
function that replaces the current state with it:
</p>

<pre name="code" class="haskell:hs">
put newState = State $ \s -&gt; ((),newState)
</pre>

<p>
So with these, we can see what the current stack is or we can replace it with a 
whole other stack. Like so:
</p>

<pre name="code" class="haskell:hs">
stackyStack :: State Stack ()
stackyStack = do
    stackNow &lt;- get
    if stackNow == [1,2,3]
        then put [8,3,1]
        else put [9,2,1]
</pre>

<p>
It's worth examining what the type of <code class="fixed">&gt;&gt;=</code> would 
be if it only worked for <code class="fixed">State</code> values:
</p>

<pre name="code" class="haskell:hs">
(&gt;&gt;=) :: State s a -&gt; (a -&gt; State s b) -&gt; State s b
</pre>

<p>
See how the type of the state <code class="fixed">s</code> stays the same but 
the type of the result can change from <code class="fixed">a</code> to 
<code class="fixed">b</code>? This means that we can glue together several 
stateful computations whose results are of different types but the type of the 
state has to stay the same. Now why is that? Well, for instance, for <span 
class="fixed">Maybe</span>, <code class="fixed">&gt;&gt;=</code> has this type:
</p>

<pre name="code" class="haskell:hs">
(&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
</pre>

<p>
It makes sense that the monad itself, <code class="fixed">Maybe</code>, doesn't 
change. It wouldn't make sense to use <code class="fixed">&gt;&gt;=</code> 
between two different monads. Well, for the state monad, the monad is actually <span 
class="fixed">State s</span>, so if that <code class="fixed">s</code> was 
different, we'd be using <code class="fixed">&gt;&gt;=</code> between two 
different monads.
</p>

<h3>Randomness and the state monad</h3>

<p>
At the beginning of this section, we saw how generating numbers can sometimes be 
awkward because every random function takes a generator and returns a random 
number along with a new generator, which must then be used instead of the old 
one if we want to generate another random number. The state monad makes dealing 
with this a lot easier.
</p>

<p>
The <code class="fixed">random</code> function from <code class="fixed">System.Random</code> 
has the following type:
</p>

<pre name="code" class="haskell:hs">
random :: (RandomGen g, Random a) =&gt; g -&gt; (a, g)
</pre>

<p>
Meaning it takes a random generator and produces a random number along with a 
new generator. We can see that it's a stateful computation, so we can wrap it in 
the <code class="fixed">State</code> <code class="fixed">newtype</code> 
constructor and then use it as a monadic value so that passing of the state gets 
handled for us:
</p>

<pre name="code" class="haskell:hs">
import System.Random
import Control.Monad.State

randomSt :: (RandomGen g, Random a) =&gt; State g a
randomSt = State random
</pre>

<p>
So now if we want to throw three coins (<code class="fixed">True</code> is 
tails, <code class="fixed">False</code> is heads) we just do the following:
</p>

<pre name="code" class="haskell:hs">
import System.Random
import Control.Monad.State

threeCoins :: State StdGen (Bool,Bool,Bool)
threeCoins = do
    a &lt;- randomSt
    b &lt;- randomSt
    c &lt;- randomSt
    return (a,b,c)
</pre>

<p>
<code class="fixed">threeCoins</code> is now a stateful computations and after 
taking an initial random generator, it passes it to the first <span 
class="fixed">randomSt</span>, which produces a number and a new generator, 
which gets passed to the next one and so on. We use <span class="fixed">return 
(a,b,c)</span> to present <code class="fixed">(a,b,c)</code> as the result 
without changing the most recent generator. Let's give this a go:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; runState threeCoins (mkStdGen 33)
((True,False,True),680029187 2103410263)
</pre>

<p>
Nice. Doing these sort of things that require some state to be kept in between 
steps just became much less of a hassle!
</p>

<a name="error"></a>
<h2>Error error on the wall</h2>

<p>
We know by now that <code class="fixed">Maybe</code> is used to add a 
context of possible failure to values. A value can be a 
<code class="fixed">Just something</code> or a <code class="fixed">Nothing</code>. 
However useful it may be, when we have a <code class="fixed">Nothing</code>, all 
we know is that there was some sort of failure, but there's no way to cram 
some more info in there telling us what kind of failure it was or why it failed.
</p>

<p>
The <code class="fixed">Either e a</code> type on the other hand, allows us to 
incorporate a context of possible failure to our values while also being able to 
attach values to the failure, so that they can describe what went wrong or 
provide some other useful info regarding the failure. An <span 
class="fixed">Either e a</span> value can either be a <span 
class="fixed">Right</span> value, signifying the right answer and a success, or 
it can be a <code class="fixed">Left</code> value, signifying failure. For 
instance:
</p>


<pre name="code" class="haskell:hs">
ghci&gt; :t Right 4
Right 4 :: (Num t) =&gt; Either a t
ghci&gt; :t Left "out of cheese error"
Left "out of cheese error" :: Either [Char] b
</pre>

<p>
This is pretty much just an enhanced <code class="fixed">Maybe</code>, 
so it makes sense for it to be a monad, because it can also be viewed as a value 
with an added context of possible failure, only now there's a value attached 
when there's an error as well.
</p>

<p>
Its <code class="fixed">Monad</code> instance is similar to that of <span 
class="fixed">Maybe</span> and it can be found in <code class="fixed">Control.Monad.Error</code>:
</p>

<pre name="code" class="haskell:hs">
instance (Error e) =&gt; Monad (Either e) where
    return x = Right x 
    Right x &gt;&gt;= f = f x
    Left err &gt;&gt;= f = Left err
    fail msg = Left (strMsg msg)
</pre>

<p>
<code class="fixed">return</code>, as always, takes a value and puts it in a 
default minimal context. It wraps our value in the <code class="fixed">Right</code>
constructor because we're using <code class="fixed">Right</code> to represent a 
successful computation where a result is present. This is a lot like <span 
class="fixed">return</span> for <code class="fixed">Maybe</code>.
</p>

<p>
The <code class="fixed">&gt;&gt;=</code> examines two possible cases: a 
<code class="fixed">Left</code> and a <code class="fixed">Right</code>. In the 
case of a <code class="fixed">Right</code>, the function <span 
class="fixed">f</span> is applied to the value inside it, similar to how in the 
case of a <code class="fixed">Just</code>, the function is just applied to its 
contents. In the case of an error, the <code class="fixed">Left</code> value is 
kept, along with its contents, which describe the failure.
</p>

<p>
The <code class="fixed">Monad</code> instance for <span class="fixed">Either 
e</span> makes an
additional requirement, and that is that the type of the value contained in a 
<code class="fixed">Left</code>, the one that's indexed by the <code class="fixed">e</code> 
type parameter, has to be an instance of the <code class="fixed">Error</code> 
type class. The <code class="fixed">Error</code> type class is for types whose 
values can act like error messages. It defines the <code class="fixed">strMsg</code> function, which takes
an error in the form of a string and returns such a value. A good example of an
<code class="fixed">Error</code> instance is, well, the <span 
class="fixed">String</span> type! In the case of <code class="fixed">String</code>, the <code class="fixed">strMsg</code>
function just returns the string that it got:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; :t strMsg
strMsg :: (Error a) =&gt; String -&gt; a
ghci&gt; strMsg "boom!" :: String
"boom!"
</pre>

<p>
But since we usually use <code class="fixed">String</code> to describe the error 
when using <code class="fixed">Either</code>, we don't have to worry about this 
too much. When a pattern match fails in <code class="fixed">do</code> notation,
a <code class="fixed">Left</code> value is used to signify this failure.
</p>

<p>
Anyway, here are a few examples of usage:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; Left "boom" &gt;&gt;= \x -&gt; return (x+1)
Left "boom"
ghci&gt; Right 100 &gt;&gt;= \x -&gt; Left "no way!"
Left "no way!"
</pre>

<p>
When we use <code class="fixed">&gt;&gt;=</code> to feed a <span 
class="fixed">Left</span> value to a function,
the function is ignored and an identical <code class="fixed">Left</code> value
is returned. When we feed a <code class="fixed">Right</code> value to a function,
the function gets applied to what's on the inside, but in this case that 
function produced a <code class="fixed">Left</code> value anyway!
</p>

<p>
When we try to feed a <code class="fixed">Right</code> value to a function that 
also succeeds, we're tripped up by a peculiar type error! Hmmm.
</p>

<pre name="code" class="haskell:hs">
ghci&gt; Right 3 &gt;&gt;= \x -&gt; return (x + 100)

&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraints:
      `Error a' arising from a use of `it' at &lt;interactive&gt;:1:0-33
      `Show a' arising from a use of `print' at &lt;interactive&gt;:1:0-33
    Probable fix: add a type signature that fixes these type variable(s)
</pre>

<p>
Haskell says that it doesn't know which type to choose for the 
<code class="fixed">e</code> part of our <code class="fixed">Either e a</code>
typed value, even though we're just printing the <code class="fixed">Right</code> part.
This is due to the <code class="fixed">Error e</code> constraint on the
<code class="fixed">Monad</code> instance. So if you get type errors like this 
one when using <code class="fixed">Either</code> as a monad, just add an 
explicit type signature:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; Right 3 &gt;&gt;= \x -&gt; return (x + 100) :: Either String Int
Right 103
</pre>

<p>
Alright, now it works!
</p>

<p>
Other than this little hangup, using this monad is very similar to using
<code class="fixed">Maybe</code> as a monad. In the previous chapter, we used
the monadic aspects of <code class="fixed">Maybe</code> to simulate birds 
landing on the balancing pole of a tightrope walker. As an exercise, you can 
rewrite that with the error monad so that when the 
tightrope walker slips and falls, we remember how many birds were on each side of 
the pole when he fell.
</p>

<a name="useful-monadic-functions"></a>
<h2>Some useful monadic functions</h2>


<p>
In this section, we're going to explore a few functions that either operate on 
monadic values or return monadic values as their results (or both!). Such 
functions are usually referred to as monadic functions. While some of them will 
be brand new, others will be monadic counterparts of functions that we already 
know, like <code class="fixed">filter</code> and <code class="fixed">foldl</code>.
Let's see what they are then!
</p>

<h3>liftM and friends</h3>

<img src="lyah/wolf.png" alt="im a cop too" class="right" width="394" height="222">

<p>
When we started our journey to the top of Monad Mountain, we first looked 
at functors, which are for things that can be mapped over. Then, we learned 
about improved functors called applicative functors, which allowed us to apply 
normal functions between several applicative values as well as to take a normal 
value and put it in some default context. Finally, we introduced 
monads as improved applicative functors, which added the ability for these 
values with context to somehow be fed into normal functions.
</p>

<p>
So every monad is an applicative functor and every applicative functor is a 
functor. The <code class="fixed">Applicative</code> type class has a class 
constraint such that our type has to be an instance of <span 
class="fixed">Functor</span> before we can make it an instance of <span 
class="fixed">Applicative</span>. But even though <code class="fixed">Monad</code> should have the same
constraint for <code class="fixed">Applicative</code>, as every monad is an 
applicative functor, it doesn't, because the <code class="fixed">Monad</code> 
type class was introduced to Haskell way before <code class="fixed">Applicative</code>.
</p>

<p>
But even though every monad is a functor, we don't have to rely on it having a
<code class="fixed">Functor</code> instance because of the <span 
class="fixed">liftM</span> function. <code class="fixed">liftM</code> takes a 
function and a monadic value and maps it over the monadic value. So it's pretty 
much the same thing as <code class="fixed">fmap</code>! This is
<code class="fixed">liftM</code>'s type:
</p>

<pre name="code" class="haskell:hs">
liftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b
</pre>

<p>
And this is the type of <code class="fixed">fmap</code>:
</p>

<pre name="code" class="haskell:hs">
fmap :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</pre>

<p>
If the <code class="fixed">Functor</code> and <code class="fixed">Monad</code> 
instances for a type obey the functor and monad laws, these two amount to the 
same thing (and all the monads that we've met so far obey both). This is kind of 
like <code class="fixed">pure</code> and <code class="fixed">return</code> do 
the same thing, only one has an <code class="fixed">Applicative</code> class 
constraint whereas the other has a <code class="fixed">Monad</code> one. Let's 
try <code class="fixed">liftM</code> out:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; liftM (*3) (Just 8)
Just 24
ghci&gt; fmap (*3) (Just 8)
Just 24
ghci&gt; runWriter $ liftM not $ Writer (True, "chickpeas")
(False,"chickpeas")
ghci&gt; runWriter $ fmap not $ Writer (True, "chickpeas")
(False,"chickpeas")
ghci&gt; runState (liftM (+100) pop) [1,2,3,4]
(101,[2,3,4])
ghci&gt; runState (fmap (+100) pop) [1,2,3,4]
(101,[2,3,4])
</pre>

<p>
We already know quite well how <code class="fixed">fmap</code> works with <span 
class="fixed">Maybe</span> values. And <code class="fixed">liftM</code> does the 
same thing. For <code class="fixed">Writer</code> values, the function is mapped 
over the first component of the tuple, which is the result. Doing <span 
class="fixed">fmap</span> or <code class="fixed">liftM</code> over a stateful 
computation results in another stateful computation, only its eventual result is modified 
by the supplied function. Had we not mapped <code class="fixed">(+100)</code> over 
<code class="fixed">pop</code> in this case before running it, it would have 
returned <code class="fixed">(1,[2,3,4])</code>.
</p>

<p>
This is how <code class="fixed">liftM</code> is implemented:
</p>

<pre name="code" class="haskell:hs">
liftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b
liftM f m = m &gt;&gt;= (\x -&gt; return (f x))
</pre>

<p>
Or with <code class="fixed">do</code> notation:
</p>

<pre name="code" class="haskell:hs">
liftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b
liftM f m = do
    x &lt;- m
    return (f x)
</pre>

<p>
We feed the monadic value <code class="fixed">m</code> into the function and 
then we apply the function <code class="fixed">f</code> to its result before 
putting it back into a default context. Because of the monad laws, this is 
guaranteed not to change the context, only the result that the monadic value 
presents. We see that <code class="fixed">liftM</code> is implemented without 
referencing the <code class="fixed">Functor</code> type class at all. This means 
that we can implement <code class="fixed">fmap</code> (or <span 
class="fixed">liftM</span>, whatever you want to call it) just by using the 
goodies that monads offer us. Because of this, we can conclude that monads are 
stronger than just regular old functors.
</p>

<p>
The <code class="fixed">Applicative</code> type class allows us to apply 
functions between values with contexts as if they were normal values. Like this:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Just 5
Just 8
ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Nothing
Nothing
</pre>

<p>
Using this applicative style makes things pretty easy. <span 
class="fixed">&lt;$&gt;</span> is just <code class="fixed">fmap</code> and
<code class="fixed">&lt;*&gt;</code> is a function from the
<code class="fixed">Applicative</code> type class that has the following type:
</p>

<pre name="code" class="haskell:hs">
(&lt;*&gt;) :: (Applicative f) =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</pre>

<p>
So it's kind of like <code class="fixed">fmap</code>, only the function itself 
is in a context. We have to somehow extract it from the context and map it over
the <code class="fixed">f a</code> value and then assemble the context back 
together. Because all functions are curried in Haskell by default, we can use 
the combination of <code class="fixed">&lt;$&gt;</code> and <span 
class="fixed">&lt;*&gt;</span> to apply functions that take several parameters 
between applicative values.
</p>

<p>
Anyway, it turns out that just like <code class="fixed">fmap</code>, <span 
class="fixed">&lt;*&gt;</span> can also be implemented by using only what the
<code class="fixed">Monad</code> type class give us. The <span 
class="fixed">ap</span> function is basically <code class="fixed">&lt;*&gt;</code>, only it has a
<code class="fixed">Monad</code> constraint instead of an <span 
class="fixed">Applicative</span> one. Here's its definition:
</p>

<pre name="code" class="haskell:hs">
ap :: (Monad m) =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
ap mf m = do
    f &lt;- mf
    x &lt;- m
    return (f x)
</pre>

<p>
<code class="fixed">mf</code> is a monadic value whose result is a function. 
Because the function is in a context as well as the value, we get the function 
from the context and call it <code class="fixed">f</code>, then get the value 
and call that <code class="fixed">x</code> and then finally apply the function 
to the value and present that as a result. Here's a quick demonstration:
</p>


<pre name="code" class="haskell:hs">
ghci&gt; Just (+3) &lt;*&gt; Just 4
Just 7
ghci&gt; Just (+3) `ap` Just 4
Just 7
ghci&gt; [(+1),(+2),(+3)] &lt;*&gt; [10,11]
[11,12,12,13,13,14]
ghci&gt; [(+1),(+2),(+3)] `ap` [10,11]
[11,12,12,13,13,14]
</pre>

<p>
Now we see that monads are stronger than applicatives as well, because we can 
use the functions from <code class="fixed">Monad</code> to implement the ones 
for <code class="fixed">Applicative</code>. In fact, many times when a type is 
found to be a monad, people first write up a <code class="fixed">Monad</code> 
instance and then make an <code class="fixed">Applicative</code> instance by just
saying that <code class="fixed">pure</code> is <code class="fixed">return</code> 
and <code class="fixed">&lt;*&gt;</code> is <code class="fixed">ap</code>. 
Similarly, if you already have a <code class="fixed">Monad</code> instance for 
something, you can give it a <code class="fixed">Functor</code> instance just 
saying that <code class="fixed">fmap</code> is <code class="fixed">liftM</code>.
</p>

<p>
The <code class="fixed">liftA2</code> function is a convenience function for 
applying a function between two applicative values. It's defined simply like 
so:
</p>

<pre name="code" class="haskell:hs">
liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
liftA2 f x y = f &lt;$&gt; x &lt;*&gt; y
</pre>

<p>
The <code class="fixed">liftM2</code> function does the same thing, only it has 
a <code class="fixed">Monad</code> constraint. There also exist <span 
class="fixed">liftM3</span> and <code class="fixed">liftM4</code> and
<code class="fixed">liftM5</code>.
</p>

<p>
We saw how monads are stronger than applicatives and functors and how even 
though all monads are functors and applicative functors, they don't necessarily 
have <code class="fixed">Functor</code> and <code class="fixed">Applicative</code> 
instances, so we examined the monadic equivalents of the functions that functors 
and applicative functors use.
</p>

<h3>The join function</h3>

<p>
Here's some food for thought: if the result of one monadic value is another 
monadic value i.e. if one monadic value is nested inside the other, can you 
flatten them to just a single normal monadic value? Like, if we have
<code class="fixed">Just (Just 9)</code>, can we make that into <span 
class="fixed">Just 9</span>? It turns out that any nested monadic value can be 
flattened and that this is actually a property unique to monads. For this, the
<code class="fixed">join</code> function exists. Its type is this:
</p>

<pre name="code" class="haskell:hs">
join :: (Monad m) =&gt; m (m a) -&gt; m a
</pre>

<p>
So it takes a monadic value within a monadic value and gives us just a monadic 
value, so it sort of flattens it. Here it is with some <span 
class="fixed">Maybe</span> values:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; join (Just (Just 9))
Just 9
ghci&gt; join (Just Nothing)
Nothing
ghci&gt; join Nothing
Nothing
</pre>

<p>
The first line has a successful computation as a result of a successful 
computation, so they're both just joined into one big successful computation. 
The second line features a <code class="fixed">Nothing</code> as a result of a 
<code class="fixed">Just</code> value. Whenever we were dealing with <span 
class="fixed">Maybe</span> values before and we wanted to combine several of 
them into one, be it with <code class="fixed">&lt;*&gt;</code> or <span 
class="fixed">&gt;&gt;=</span>, they all had to be <code class="fixed">Just</code> values
for the result to be a <code class="fixed">Just</code> value. If there was any 
failure along the way, the result was a failure and the same thing happens here. 
In the third line, we try to flatten what is from the onset a failure, so the 
result is a failure as well.
</p>


<p>
Flattening lists is pretty intuitive:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; join [[1,2,3],[4,5,6]]
[1,2,3,4,5,6]
</pre>

<p>
As you can see, for lists, <code class="fixed">join</code> is just 
<code class="fixed">concat</code>. To flatten a <code class="fixed">Writer</code> value
whose result is a <code class="fixed">Writer</code> value itself, we have to 
<code class="fixed">mappend</code> the monoid value.
</p> 

<pre name="code" class="haskell:hs">
ghci&gt; runWriter $ join (Writer (Writer (1,"aaa"),"bbb"))
(1,"bbbaaa")
</pre>

<p>
The outer monoid value
<code class="fixed">"bbb"</code> comes first and then to it <span 
class="fixed">"aaa"</span> is appended. Intuitively speaking, when you want to 
examine what the result of a <code class="fixed">Writer</code> value is, you 
have to write its monoid value to the log first and only then can you examine 
what it has inside.
</p>

<p>
Flattening <code class="fixed">Either</code> values is very similar to 
flattening <code class="fixed">Maybe</code> values:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; join (Right (Right 9)) :: Either String Int
Right 9
ghci&gt; join (Right (Left "error")) :: Either String Int
Left "error"
ghci&gt; join (Left "error") :: Either String Int
Left "error"
</pre>


<p>
If we apply <code class="fixed">join</code> to a stateful computation whose 
result is a stateful computation, the result is a stateful computation that 
first runs the outer stateful computation and then the resulting one. Watch:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; runState (join (State $ \s -&gt; (push 10,1:2:s))) [0,0,0]
((),[10,1,2,0,0,0])
</pre>

<p>
The lambda here takes a state and puts <code class="fixed">2</code> and
<code class="fixed">1</code> onto the stack and presents <span 
class="fixed">push 10</span> as its result. So when this whole thing is 
flattened with <code class="fixed">join</code> and then run, it first puts
<code class="fixed">2</code> and <code class="fixed">1</code> onto the stack and 
then <code class="fixed">push 10</code> gets carried out, pushing a <span 
class="fixed">10</span> on to the top.
</p>

<p>
The implementation for <code class="fixed">join</code> is as follows:
</p>

<pre name="code" class="haskell:hs">
join :: (Monad m) =&gt; m (m a) -&gt; m a
join mm = do
    m &lt;- mm
    m
</pre>

<p>
Because the result of <code class="fixed">mm</code> is a monadic value, we 
get that result and then just put it on a line of its own because it's a monadic 
value. The trick here is that when we do <code class="fixed">m &lt;- mm</code>, 
the context of the monad in which we 
are in gets taken care of. That's why, for instance, <span 
class="fixed">Maybe</span> values result in <code class="fixed">Just</code> 
values only if the outer and inner values are both <code class="fixed">Just</code> values. Here's what this would look like if the <code class="fixed">mm</code> value was set in advance to <code class="fixed">Just (Just 8)</code>:
</p>

<pre name="code" class="haskell:hs">
joinedMaybes :: Maybe Int
joinedMaybes = do
    m &lt;- Just (Just 8)
    m
</pre>

<img src="lyah/tipi.png" alt="im a cop too as well also" class="right" width="253" 
height="379">

<p>
Perhaps the most interesting thing about <code class="fixed">join</code> is 
that for every monad, feeding a monadic value to a function with <span 
class="fixed">&gt;&gt;=</span> is the same thing as just mapping that function 
over the value and then using <code class="fixed">join</code> to flatten the 
resulting nested monadic value! In other words, <span class="fixed">m &gt;&gt;= 
f</span> is always the same thing as <code class="fixed">join (fmap f m)</code>! 
It makes sense when you think about it. With <code class="fixed">&gt;&gt;=</code>, we're always thinking about
how to feed a monadic value to a function that takes a normal value but returns 
a monadic value. If we just map that function over the monadic value, we have a 
monadic value inside a monadic value. For instance, say we have <span 
class="fixed">Just 9</span> and the function <span class="fixed">\x -&gt; Just 
(x+1)</span>. If we map this function over <code class="fixed">Just 9</code>, 
we're left with <code class="fixed">Just (Just 10)</code>.
</p>

<p>
The fact that <code class="fixed">m &gt;&gt;= f</code> always equals 
<code class="fixed">join (fmap f m)</code> is very useful if we're making our 
own <code class="fixed">Monad</code> instance for some type because it's often 
easier to figure out how we would flatten a nested monadic value than figuring 
out how to implement <code class="fixed">&gt;&gt;=</code>.
</p>

<h3>filterM</h3>

<p>
The <code class="fixed">filter</code> function is pretty much the bread of 
Haskell programming (<code class="fixed">map</code> being the butter). It takes 
a predicate and a list to filter out and then returns a new list where only the 
elements that satisfy the predicate are kept. Its type is this:
</p>

<pre name="code" class="haskell:hs">
filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
</pre>

<p>
The predicate takes an element of the list and returns a <span 
class="fixed">Bool</span> value. Now, what if the <code class="fixed">Bool</code> value that it returned
was actually a monadic value? Whoa! That is, what if it came with a context? 
Could that work? For instance, what if every <span 
class="fixed">True</span> or a <code class="fixed">False</code> value that the 
predicate produced also had an accompanying monoid value, like <span 
class="fixed">["Accepted the number 5"]</span> or <span class="fixed">["3 is too 
small"]</span>? That sounds like it could work. If that were the case, we'd 
expect the resulting list to also come with a log of all the log values that 
were produced along the way. So if the <code class="fixed">Bool</code> that the 
predicate returned came with a context, we'd expect the final resulting list to have 
some context attached as well, otherwise the context that each <span 
class="fixed">Bool</span> came with would be lost.
</p>

<p>
The <code class="fixed">filterM</code> function from <code class="fixed">Control.Monad</code> 
does just what we want! Its type is this:
</p>

<pre name="code" class="haskell:hs">
filterM :: (Monad m) =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]
</pre>

<p>
The predicate returns a monadic value whose result is a <span 
class="fixed">Bool</span>, but because it's a monadic value, its context can be 
anything from a possible failure to non-determinism and more! To ensure that the 
context is reflected in the final result, the result is also a monadic value.
</p>

<p>
Let's take a list and only keep those values that are smaller than 4. To 
start, we'll just use the regular <code class="fixed">filter</code> function:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; filter (\x -&gt; x &lt; 4) [9,1,5,2,10,3]
[1,2,3]
</pre>

<p>
That's pretty easy. Now, let's make a predicate that, aside from presenting a 
<code class="fixed">True</code> or <code class="fixed">False</code> result, also 
provides a log of what it did. Of course, we'll be using the <span 
class="fixed">Writer</span> monad for this:
</p>

<pre name="code" class="haskell:hs">
keepSmall :: Int -&gt; Writer [String] Bool
keepSmall x
    | x &lt; 4 = do
        tell ["Keeping " ++ show x]
        return True
    | otherwise = do
        tell [show x ++ " is too large, throwing it away"]
        return False
</pre>

<p>
Instead of just and returning a <code class="fixed">Bool</code>, this function 
returns a <code class="fixed">Writer [String] Bool</code>. It's a monadic 
predicate. Sounds fancy, doesn't it? If the number is smaller than <span 
class="fixed">4</span> we report that we're keeping it and then <span 
class="fixed">return True</span>.
</p>

<p>
Now, let's give it to <code class="fixed">filterM</code> along with a list. 
Because the predicate returns a 
<code class="fixed">Writer</code> value, the resulting list will also 
be a <code class="fixed">Writer</code> value.
</p>

<pre name="code" class="haskell:hs">
ghci&gt; fst $ runWriter $ filterM keepSmall [9,1,5,2,10,3]
[1,2,3]
</pre>

<p>
Examining the result of the resulting <code class="fixed">Writer</code> value, 
we see that everything is in order. Now, let's print the log and see what we 
got:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; mapM_ putStrLn $ snd $ runWriter $ filterM keepSmall [9,1,5,2,10,3]
9 is too large, throwing it away
Keeping 1
5 is too large, throwing it away
Keeping 2
10 is too large, throwing it away
Keeping 3
</pre>

<p>
Awesome. So just by providing a monadic predicate to <code class="fixed">filterM</code>, 
we were able to filter a list while taking advantage of the monadic context that 
we used.
</p>

<p>
A very cool Haskell trick is using <code class="fixed">filterM</code> to get the 
powerset of a list (if we think of them as sets for now). The powerset of some 
set is a set of all subsets of that set. So if we have a set like <span 
class="fixed">[1,2,3]</span>, its powerset would include the following sets:
</p>

<pre name="code" class="haskell:hs">
[1,2,3]
[1,2]
[1,3]
[1]
[2,3]
[2]
[3]
[]
</pre>

<p>
In other words, getting a powerset is like getting all the combinations of 
keeping and throwing out elements from a set. <code class="fixed">[2,3]</code> 
is like the original set, only we excluded the number <span 
class="fixed">1</span>.
</p>

<p>
To make a function that returns a powerset of some list, we're going to rely on 
non-determinism. We take the list <code class="fixed">[1,2,3]</code> and then 
look at the first element, which is <code class="fixed">1</code> and we ask 
ourselves: should we keep it or drop it? Well, we'd like to do both actually. So 
we are going to filter a list and we'll use a predicate that non-deterministically 
both keeps and drops every element from the list. Here's our <span 
class="fixed">powerset</span> function:
</p>

<pre name="code" class="haskell:hs">
powerset :: [a] -&gt; [[a]]
powerset xs = filterM (\x -&gt; [True, False]) xs
</pre>

<p>
Wait, that's it? Yup. We choose to drop and keep every element, regardless of 
what that element is. We have a non-deterministic predicate, so the resulting 
list will also be a non-deterministic value and will thus be a list of lists. Let's 
give this a go:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; powerset [1,2,3]
[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
</pre>

<p>
This takes a bit of thinking to wrap your head around, but if you just consider 
lists as non-deterministic values that don't know what to be so they just decide 
to be everything at once, it's a bit easier.
</p>

<h3>foldM</h3>

<p>
The monadic counterpart to <code class="fixed">foldl</code> is <span 
class="fixed">foldM</span>. If you remember your folds from the <a href="folds.html">folds section</a>, you know that <code class="fixed">foldl</code> takes a binary 
function, a starting accumulator and a list to fold up and then folds it from the left 
into a single value by using the binary function. <code class="fixed">foldM</code> does the same
thing, except it takes a binary function that produces a monadic value and folds 
the list up with that. Unsurprisingly, the resulting value is also monadic. The 
type of <code class="fixed">foldl</code> is this:
</p>

<pre name="code" class="haskell:hs">
foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
</pre>

<p>
Whereas <code class="fixed">foldM</code> has the following type:
</p>

<pre name="code" class="haskell:hs">
foldM :: (Monad m) =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; [b] -&gt; m a
</pre>

<p>
The value that the binary function returns is monadic and so the result of the 
whole fold is monadic as well. Let's sum a list of numbers with a 
fold:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; foldl (\acc x -&gt; acc + x) 0 [2,8,3,1]
14
</pre>

<p>
The starting accumulator is <code class="fixed">0</code> and then <span 
class="fixed">2</span> gets added to the accumulator, resulting in a new 
accumulator that has a value of <code class="fixed">2</code>. <span 
class="fixed">8</span> gets added to this accumulator resulting in an 
accumulator of <code class="fixed">10</code> and so on and when we reach the 
end, the final accumulator is the result.
</p>

<p>
Now what if we wanted to sum a list of numbers but with the added condition that 
if any number is greater than <code class="fixed">9</code> in the list, the 
whole thing fails? It would make sense to use a binary function that checks if 
the current number is greater than <code class="fixed">9</code> and if it is, 
fails, and if it isn't, continues on its merry way. Because of this added 
possibility of failure, let's make our binary function return a <span 
class="fixed">Maybe</span> accumulator instead of a normal one. Here's the 
binary function:
</p>

<pre name="code" class="haskell:hs">
binSmalls :: Int -&gt; Int -&gt; Maybe Int
binSmalls acc x
    | x &gt; 9     = Nothing
    | otherwise = Just (acc + x)
</pre>

<p>
Because our binary function is now a monadic function, we can't use it with the
normal <code class="fixed">foldl</code>, but we have to use <span 
class="fixed">foldM</span>. Here goes:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; foldM binSmalls 0 [2,8,3,1]
Just 14
ghci&gt; foldM binSmalls 0 [2,11,3,1]
Nothing
</pre>

<p>
Excellent! Because one number in the list was greater than <span 
class="fixed">9</span>, the whole thing resulted in a <span 
class="fixed">Nothing</span>. Folding with a binary function that returns a 
<code class="fixed">Writer</code> value is cool as well because then you log 
whatever you want as your fold goes along its way.
</p>

<h3>Making a safe RPN calculator</h3>

<img src="lyah/miner.png" alt="i've found yellow!" class="left" width="280" 
height="396">

<p>
When we were solving the problem of <a href="reverse-polish-notation-calculator.html">implementing a RPN calculator</a>,
we noted that it worked fine as long as the input that it got made sense.
But if something went wrong, it caused our whole program to crash. Now that we
know how to take some code that we have and make it monadic, let's take our RPN 
calculator and add error handling to it by taking advantage of the
<code class="fixed">Maybe</code> monad.
</p>

<p>
We implemented our RPN calculator by taking a string like <span 
class="fixed">"1 3 + 2 *"</span>, breaking it up into words to get something 
like <code class="fixed">["1","3","+","2","*"]</code> and then folding over that 
list by starting out with an empty stack and then using a binary folding 
function that adds numbers to the stack or manipulates numbers on the top of the 
stack to add them together and divide them and such.
</p>

<p>
This was the main body of our function:
</p>

<pre name="code" class="haskell:hs">
import Data.List

solveRPN :: String -&gt; Double
solveRPN = head . foldl foldingFunction [] . words
</pre>

<p>
We made the expression into a list of strings, folded over it with our folding 
function and then when we were left with just one item in the stack, we returned 
that item as the answer. This was the folding function:
</p>

<pre name="code" class="haskell:hs">
foldingFunction :: [Double] -&gt; String -&gt; [Double]
foldingFunction (x:y:ys) "*" = (x * y):ys
foldingFunction (x:y:ys) "+" = (x + y):ys
foldingFunction (x:y:ys) "-" = (y - x):ys
foldingFunction xs numberString = read numberString:xs
</pre>

<p>
The accumulator of the fold was a stack, which we represented with a list of 
<code class="fixed">Double</code> values. As the folding function went over the RPN expression, if 
the current item was an operator, it took two items off the top of the stack, 
applied the operator between them and then put the result back on the stack. If 
the current item was a string that represented a number, it converted that 
string into an actual number and returned a new stack that was like the old one, 
except with that number pushed to the top.
</p>

<p>
Let's first make our folding function capable of graceful failure. Its type is 
going to change from what it is now to this:
</p>

<pre name="code" class="haskell:hs">
foldingFunction :: [Double] -&gt; String -&gt; Maybe [Double]
</pre>

<p>
So it will either return <code class="fixed">Just</code> a new stack or it will 
fail with <code class="fixed">Nothing</code>. 
</p>
<p>The <code class="fixed">reads</code> function is like
<code class="fixed">read</code>, only it returns a list with a single element in 
case of a successful read. If it fails to read something, then it returns an 
empty list. Apart from returning the value that it read, it also returns the 
part of the string that it didn't consume. We're going to say that it always has 
to consume the full input to work and make it into a <code class="fixed">readMaybe</code> function
for convenience. Here it is:
</p>

<pre name="code" class="haskell:hs">
readMaybe :: (Read a) =&gt; String -&gt; Maybe a
readMaybe st = case reads st of [(x,"")] -&gt; Just x
                                _ -&gt; Nothing
</pre>

<p>
Testing it out:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; readMaybe "1" :: Maybe Int
Just 1
ghci&gt; readMaybe "GO TO HELL" :: Maybe Int
Nothing
</pre>

<p>
Okay, it seems to work. So, let's make our folding function into a monadic 
function that can fail:
</p>

<pre name="code" class="haskell:hs">
foldingFunction :: [Double] -&gt; String -&gt; Maybe [Double]
foldingFunction (x:y:ys) "*" = return ((x * y):ys)
foldingFunction (x:y:ys) "+" = return ((x + y):ys)
foldingFunction (x:y:ys) "-" = return ((y - x):ys)
foldingFunction xs numberString = liftM (:xs) (readMaybe numberString)
</pre>

<p>
The first three cases are like the old ones, except the new stack gets 
wrapped in a <code class="fixed">Just</code> (we used <span 
class="fixed">return</span> here to do this, but we could have written
<code class="fixed">Just</code> just as well). In the last case, we do
<code class="fixed">readMaybe numberString</code> and then we map <span 
class="fixed">(:xs)</span> over it. So if the stack <code class="fixed">xs</code>
is <code class="fixed">[1.0,2.0]</code> and <span class="fixed">readMaybe 
numberString</span> results in a <code class="fixed">Just 3.0</code>, the result 
is <code class="fixed">Just [3.0,1.0,2.0]</code>. If <code class="fixed">readMaybe numberString</code> results in a <span 
class="fixed">Nothing</span> then the result is <code class="fixed">Nothing</code>. 
Let's try out the folding function by itself:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; foldingFunction [3,2] "*"
Just [6.0]
ghci&gt; foldingFunction [3,2] "-"
Just [-1.0]
ghci&gt; foldingFunction [] "*"
Nothing
ghci&gt; foldingFunction [] "1"
Just [1.0]
ghci&gt; foldingFunction [] "1 wawawawa"
Nothing
</pre>

<p>
It looks like it's working! And now it's time for the new and improved
<code class="fixed">solveRPN</code>. Here it is ladies and gents!
</p>

<pre name="code" class="haskell:hs">
import Data.List

solveRPN :: String -&gt; Maybe Double
solveRPN st = do
    [result] &lt;- foldM foldingFunction [] (words st)
    return result
</pre>

<p>
Just like before, we take the string and make it into a list of words. Then,
we do a fold, starting with the empty stack, only instead of doing a normal
<code class="fixed">foldl</code>, we do a <code class="fixed">foldM</code>. The 
result of that <code class="fixed">foldM</code> should be a <span 
class="fixed">Maybe</span> value that contains a list (that's our final stack) 
and that list should have only one value. We use a <code class="fixed">do</code>
expression to get that value and we call it <code class="fixed">result</code>. In 
case the <code class="fixed">foldM</code> returns a <code class="fixed">Nothing</code>, the whole thing
will be a <code class="fixed">Nothing</code>, because that's how <span 
class="fixed">Maybe</span> works. Also notice that we pattern match in the 
<code class="fixed">do</code> expression, so if the list has more than one value 
or none at all, the pattern match fails and a <code class="fixed">Nothing</code> 
is produced. In the last line we just do <code class="fixed">return result</code> to present
the result of the RPN calculation as the result of the final <span 
class="fixed">Maybe</span> value.
</p>

<p>
Let's give it a shot:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; solveRPN "1 2 * 4 +"
Just 6.0
ghci&gt; solveRPN "1 2 * 4 + 5 *"
Just 30.0
ghci&gt; solveRPN "1 2 * 4"
Nothing
ghci&gt; solveRPN "1 8 wharglbllargh"
Nothing
</pre>

<p>
The first failure happens because the final stack isn't a list with one element 
in it and so the pattern matching in the <code class="fixed">do</code> 
expression fails. The second failure happens because <code class="fixed">readMaybe</code>
returns a <code class="fixed">Nothing</code>.
</p>

<h3>Composing monadic functions</h3>

<p>
When we were learning about the monad laws, we said that the 
<code class="fixed">&lt;=&lt;</code> function is just like composition, only 
instead of working for normal functions like <code class="fixed">a -&gt; b</code>, it
works for monadic functions like <code class="fixed">a -&gt; m b</code>. For 
instance:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; let f = (+1) . (*100)
ghci&gt; f 4
401
ghci&gt; let g = (\x -&gt; return (x+1)) &lt;=&lt; (\x -&gt; return (x*100))
ghci&gt; Just 4 &gt;&gt;= g
Just 401
</pre>


<p>
In this example we first composed two normal functions, applied the 
resulting function to <code class="fixed">4</code> and then we composed two 
monadic functions and fed <code class="fixed">Just 4</code> to the resulting 
function with <code class="fixed">&gt;&gt;=</code>.
</p>

<p>
If we have a bunch of functions in a list, we can compose them one all into one 
big function by just using <code class="fixed">id</code> as the starting 
accumulator and the <code class="fixed">.</code> function as the binary 
function. Here's an example:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; let f = foldr (.) id [(+1),(*100),(+1)]
ghci&gt; f 1
201
</pre>

<p>
The function <code class="fixed">f</code> takes a number and then adds 
<code class="fixed">1</code> to it, multiplies the result by
<code class="fixed">100</code> and then adds <code class="fixed">1</code> to
that. Anyway, we can compose monadic functions in the same way, only instead 
normal composition we use <code class="fixed">&lt;=&lt;</code> and instead of
<code class="fixed">id</code> we use <code class="fixed">return</code>. We don't 
have to use a <code class="fixed">foldM</code> over a <span 
class="fixed">foldr</span> or anything because the <code class="fixed">&lt;=&lt;</code>
function makes sure that composition happens in a monadic fashion.
</p>

<p>
When we were getting to know the list monad in the <a href="a-fistful-of-monads.html#the-list-monad">previous chapter</a>, we used 
it to figure out if a knight can go from one position on a 
chessboard to another in exactly three moves. We had a function
called <code class="fixed">moveKnight</code> which took the knight's position on 
the board and returned all the possible moves that he can make next. Then, to
generate all the possible positions that he can have after taking three moves, 
we made the following function:
</p>

<pre name="code" class="haskell:hs">
in3 start = return start &gt;&gt;= moveKnight &gt;&gt;= moveKnight &gt;&gt;= moveKnight 
</pre>

<p>
And to check if he can go from <code class="fixed">start</code> to 
<code class="fixed">end</code> in three moves, we did the following:
</p>

<pre name="code" class="haskell:hs">
canReachIn3 :: KnightPos -&gt; KnightPos -&gt; Bool
canReachIn3 start end = end `elem` in3 start
</pre>

<p>
Using monadic function composition, we can make a function like <span 
class="fixed">in3</span>, only instead of generating all the positions that the 
knight can have after making three moves, we can do it for an arbitrary number 
of moves. If you look at <code class="fixed">in3</code>, we see that we 
used <code class="fixed">moveKnight</code> three times and each time we used
<code class="fixed">&gt;&gt;=</code> to feed it all the possible previous 
positions. So now, let's make it more general. Here's how to do it:
</p>

<pre name="code" class="haskell:hs">
import Data.List

inMany :: Int -&gt; KnightPos -&gt; [KnightPos]
inMany x start = return start &gt;&gt;= foldr (&lt;=&lt;) return (replicate x moveKnight)
</pre>

<p>
First we use <code class="fixed">replicate</code> to make a list that contains 
<code class="fixed">x</code> copies of the function <code class="fixed">moveKnight</code>. Then,
we monadically compose all those functions into one, which gives us a function 
that takes a starting position and non-deterministically moves the knight 
<code class="fixed">x</code> times. Then, we just make the starting position
into a singleton list with <code class="fixed">return</code> and feed it to the 
function.
</p>

<p>
Now, we can change our <code class="fixed">canReachIn3</code> function to be 
more general as well:
</p>

<pre name="code" class="haskell:hs">
canReachIn :: Int -&gt; KnightPos -&gt; KnightPos -&gt; Bool
canReachIn x start end = end `elem` inMany x start
</pre>

<a name="making-monads"></a>
<h2>Making monads</h2>
<img src="lyah/spearhead.png" alt="kewl" class="center" width="780" height="244">

<p>
In this section, we're going to look at an example of how a type gets made, 
identified as a monad and then given the appropriate 
<code class="fixed">Monad</code> instance. We don't usually set out to make 
a monad with the sole purpose of making a monad. Instead, we usually make a type 
that whose purpose is to model an aspect of some problem and then later on if we 
see that the type represents a value with a context and can act like a monad, we 
give it a <code class="fixed">Monad</code> instance.
</p>

<p>
As we've seen, lists are used to represent non-deterministic values. A list like
<code class="fixed">[3,5,9]</code> can be viewed as a single non-deterministic 
value that just can't decide what it's going to be. When we feed a list into 
a function with <code class="fixed">&gt;&gt;=</code>, it just makes all the 
possible choices of taking an element from the list and applying the function to it 
and then presents those results in a list as well.
</p>

<p>
If we look at the list <code class="fixed">[3,5,9]</code> as the numbers
<code class="fixed">3</code>, <code class="fixed">5</code> and
<code class="fixed">9</code> occurring at once, we might notice that there's no 
info regarding the probability that each of those numbers occurs. What if we 
wanted to model a non-deterministic value like <code class="fixed">[3,5,9]</code>,
but we wanted to express that <code class="fixed">3</code> has a 50% chance of 
happening and <code class="fixed">5</code> and <code class="fixed">9</code> both 
have a 25% chance of happening? Let's try and make this happen!
</p>

<p>
Let's say that every item in the list comes with another value, a probability 
of it happening. It might make sense to present this like this then:
</p>

<pre name="code" class="haskell:hs">
[(3,0.5),(5,0.25),(9,0.25)]
</pre>

<p>
In mathematics, probabilities aren't usually expressed in percentages, but 
rather in real numbers between a 0 and 1. A 0 means that there's no chance in 
hell for something to happen and a 1 means that it's happening for sure. Floating 
point numbers can get real messy real fast because they tend to lose 
precision, so Haskell offers us a data type for rational numbers that doesn't lose 
precision. That type is called <code class="fixed">Rational</code> and it lives
in <code class="fixed">Data.Ratio</code>. To make a <code class="fixed">Rational</code>,
we write it as if it were a fraction. The numerator and the denominator are 
separated by a <code class="fixed">%</code>. Here are a few examples:
</p>


<pre name="code" class="haskell:hs">
ghci&gt; 1%4
1 % 4
ghci&gt; 1%2 + 1%2
1 % 1
ghci&gt; 1%3 + 5%4
19 % 12
</pre>

<p>
The first line is just one quarter. In the second line we add two halves to get 
a whole and in the third line we add one third with five quarters and get 
nineteen twelfths. So let'use throw out our floating points and use
<code class="fixed">Rational</code> for our probabilities:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; [(3,1%2),(5,1%4),(9,1%4)]
[(3,1 % 2),(5,1 % 4),(9,1 % 4)]
</pre>

<p>
Okay, so <code class="fixed">3</code> has a one out of two chance of happening while
<code class="fixed">5</code> and <code class="fixed">9</code> will happen one 
time out of four. Pretty neat.
</p>

<p>
We took lists and we added some extra context to them, so this represents values 
withs contexts too. Before we go any further, let's wrap this into a 
<code class="fixed">newtype</code> because something tells me we'll be making 
some instances.
</p>

<pre name="code" class="haskell:hs">
import Data.Ratio

newtype Prob a = Prob { getProb :: [(a,Rational)] } deriving Show
</pre>

<p>
Alright. Is this a functor? Well, the list is a functor, so this should probably 
be a functor as well, because we just added some stuff to the list. When we map 
a function over a list, we apply it to each element. Here, we'll apply it to 
each element as well, only we'll leave the probabilities as they are. Let's make 
an instance:
</p>

<pre name="code" class="haskell:hs">
instance Functor Prob where
    fmap f (Prob xs) = Prob $ map (\(x,p) -&gt; (f x,p)) xs
</pre>

<p>
We unwrap it from the <code class="fixed">newtype</code> with pattern matching, 
apply the function <code class="fixed">f</code> to the values while keeping the 
probabilities as they are and then wrap it back up. Let's see if it works:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; fmap negate (Prob [(3,1%2),(5,1%4),(9,1%4)])
Prob {getProb = [(-3,1 % 2),(-5,1 % 4),(-9,1 % 4)]}
</pre>

<p>
Another thing to note is that the probabilities should always add up to
<code class="fixed">1</code>. If those are all the things that can happen, it 
doesn't make sense for the sum of their probabilities to be anything other than 
<code class="fixed">1</code>. A coin that lands tails 75% of the time and 
heads 50% of the time seems like it could only work in some other strange 
universe.
</p>

<p>
Now the big question, is this a monad? Given how the list is a monad, this 
looks like it should be a monad as well. First, let's think about 
<code class="fixed">return</code>. How does it work for lists? It takes a value 
and puts it in a singleton list. What about here? Well, since it's supposed to 
be a default minimal context, it should also make a singleton list. What about 
the probability? Well, <code class="fixed">return x</code> is supposed to make a 
monadic value that always presents <code class="fixed">x</code> as its result, 
so it doesn't make sense for the probability to be <code class="fixed">0</code>. 
If it always has to present it as its result, the probability should be 
<code class="fixed">1</code>!
</p>

<p>
What about <code class="fixed">&gt;&gt;=</code>? Seems kind of tricky, so let's 
make use of the fact that <code class="fixed">m &gt;&gt;= f</code> always equals
<code class="fixed">join (fmap f m)</code> for monads and think about how we 
would flatten a probability list of probability lists. As an example, let's 
consider this list where there's a 25% chance that exactly one of 
<code class="fixed">'a'</code> or <code class="fixed">'b'</code> will happen. Both
<code class="fixed">'a'</code> and <code class="fixed">'b'</code> are equally 
likely to occur. Also, there's a 75% chance that 
exactly one of <code class="fixed">'c'</code> or <code class="fixed">'d'</code> 
will happen. <code class="fixed">'c'</code> and <code class="fixed">'d'</code> 
are also equally likely to happen. Here's a picture of a probability list that 
models this scenario:
</p>

<img src="lyah/prob.png" alt="probs" class="left" width="456" height="142">

<p>
What are the chances for each of these letters to occur? If we were to draw this 
as just four boxes, each with a probability, what would those probabilities be? 
To find out, all we have to do is multiply each probability with all of 
probabilities that it contains. <code class="fixed">'a'</code> would occur one 
time out of eight, as would <code class="fixed">'b'</code>, because if we 
multiply one half by one quarter we get one eighth. <span 
class="fixed">'c'</span> would happen three times out of eight because 
three quarters multiplied by one half is three eighths. <span 
class="fixed">'d'</span> would also happen three times out of eight. If we sum 
all the probabilities, they still add up to one.
</p>

<p>
Here's this situation expressed as a probability list:
</p>

<pre name="code" class="haskell:hs">
thisSituation :: Prob (Prob Char)
thisSituation = Prob
    [( Prob [('a',1%2),('b',1%2)] , 1%4 )
    ,( Prob [('c',1%2),('d',1%2)] , 3%4)
    ]
</pre>

<p>
Notice that its type is <code class="fixed">Prob (Prob Char)</code>. So now that 
we've figure out how to flatten a nested probability list, all we have to do is 
write the code for this and then we can write <code class="fixed">&gt;&gt;=</code> simply as
<code class="fixed">join (fmap f m)</code> and we have ourselves a monad! So 
here's <code class="fixed">flatten</code>, which we'll use because the name <code class="fixed">join</code>
is already taken:
</p>

<pre name="code" class="haskell:hs">
flatten :: Prob (Prob a) -&gt; Prob a
flatten (Prob xs) = Prob $ concat $ map multAll xs
    where multAll (Prob innerxs,p) = map (\(x,r) -&gt; (x,p*r)) innerxs
</pre>

<p>
The function <code class="fixed">multAll</code> takes a tuple of probability 
list and a probability <code class="fixed">p</code> that comes with it and then 
multiplies every inner probability with <code class="fixed">p</code>, returning 
a list of pairs of items and probabilities. We map <code class="fixed">multAll</code> over
each pair in our nested probability list and then we just flatten the resulting 
nested list.
</p>

<p>
Now we have all that we need, we can write a <code class="fixed">Monad</code> 
instance!
</p>

<pre name="code" class="haskell:hs">
instance Monad Prob where
    return x = Prob [(x,1%1)]
    m &gt;&gt;= f = flatten (fmap f m)
    fail _ = Prob []
</pre>

<img src="lyah/ride.png" alt="ride em cowboy" class="right" width="177" height="406">

<p>
Because we already did all the hard work, the instance is very simple. We also 
defined the <code class="fixed">fail</code> function, which is the same as it is 
for lists, so if there's a pattern match failure in a <code class="fixed">do</code>
expression, a failure occurs within the context of a probability list.
</p>

<p>
It's also important to check if the monad laws hold for the monad that we just 
made. The first one says that <code class="fixed">return x &gt;&gt;= f</code> 
should be equal to <code class="fixed">f x</code>. A rigorous proof would be 
rather tedious, but we can see that if we put a value in a default context 
with <code class="fixed">return</code> and then <code class="fixed">fmap</code> 
a function over that and flatten the resulting probability list, every 
probability that results from the function would be multiplied by the <span 
class="fixed">1%1</span> probability that we made with <span 
class="fixed">return</span>, so it wouldn't affect the context. The reasoning 
for <code class="fixed">m &gt;&gt;= return</code> being equal to just
<code class="fixed">m</code> is similar. The third law states that 
<code class="fixed">f &lt;=&lt; (g &lt;=&lt; h)</code> should be the same as
<code class="fixed">(f &lt;=&lt; g) &lt;=&lt; h</code>. This one holds as well, 
because it holds for the list monad which forms the basis of the probability 
monad and because multiplication is associative. <span class="fixed">1%2 * (1%3 
* 1%5)</span> is equal to <code class="fixed">(1%2 * 1%3) * 1%5</code>.
</p>

<p>
Now that we have a monad, what can we do with it? Well, it can help us do 
calculations with probabilities. We can treat probabilistic events as values 
with contexts and the probability monad will make sure that those probabilities 
get reflected in the probabilities of the final result.
</p>

<p>
Say we have two normal coins and one loaded coin that gets tails an astounding 
nine times out of ten and heads only one time out of ten. If we throw all the 
coins at once, what are the odds of all of them landing tails? First, let's make 
probability values for a normal coin flip and for a loaded one:
</p>

<pre name="code" class="haskell:hs">
data Coin = Heads | Tails deriving (Show, Eq)

coin :: Prob Coin
coin = Prob [(Heads,1%2),(Tails,1%2)]

loadedCoin :: Prob Coin
loadedCoin = Prob [(Heads,1%10),(Tails,9%10)]
</pre>

<p>
And finally, the coin throwing action:
</p>

<pre name="code" class="haskell:hs">
import Data.List (all)

flipThree :: Prob Bool
flipThree = do
    a &lt;- coin
    b &lt;- coin
    c &lt;- loadedCoin
    return (all (==Tails) [a,b,c])
</pre>

<p>
Giving it a go, we see that the odds of all three landing tails are not that 
good, despite cheating with our loaded coin:
</p>

<pre name="code" class="haskell:hs">
ghci&gt; getProb flipThree
[(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),
 (False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]
</pre>

<p>
All three of them will land tails nine times out of forty, which is less than 
25%. We see that our monad doesn't know how to join all of the 
<code class="fixed">False</code> outcomes where all coins don't land tails into
one outcome. That's not a big problem, since writing a function to put all the 
same outcomes into one outcome is pretty easy and is left as an exercise to the 
reader (you!)
</p>

<p>
In this section, we went from having a question (what if lists also carried 
information about probability?) to making a type, recognizing a monad and 
finally making an instance and doing something with it. I think that's quite 
fetching! By now, we should have a pretty good grasp on monads and what they're 
about.
</p>
                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                                        <a href="a-fistful-of-monads.html" class="prevlink">A Fistful of Monads</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters.html">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="zippers.html" class="nxtlink">Zippers</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="shBrushHaskell.js"></script>
    <script type="text/javascript" src="shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = 'sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script>
</body>

<!-- Mirrored from learnyouahaskell.com/for-a-few-monads-more by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 19 Nov 2013 17:20:41 GMT -->
</html>
